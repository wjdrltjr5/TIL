# 스레드와 관련된 문제들

## 4.6.1 Fork() 및 Exec() 시스템 콜

다중 스레드 프로그램에서는 fork()와 exec()의 의미가 달라질 수 있다.

만일 한 프로그램의 스레드가 fork()를 호출하면 새로운 프로세스는 모든 스레드를 복제해야 하는가 아니면 한개의 스레드만 가지는 프로세스여야 하는가

몇몇 UNIX기종은 이 두가지 버전 fork()를 다 제공한다. 하나는 모든 스레드를 복사하는 것과 다른 하나는 fork()를 호출한 스레드만 복제하는 것

어떤 스레드가 exec() 시스템 콜을 부르면 exec()의 매개변수로 지정된 프로그램이 모든 스레드를 포함한 전체 프로세스를 대체시킨다.

두 버전의 fork()중 어떤것을 사용할지는 응용 프로그램에 달려있다. fork()를 부르자마자 다시 exec을 부른다면 모든 스레드를 다 복제해서 만들어주는 것은 불필요하다. exec에서 지정한 프로그램으로 대체할 것이니까

이경우 fork()시스템 콜을 호출한 스레드만 복사하는 것이 적절 하지만 새 프로세스가 fork()후 exec()를 하지 않는다면 새 프로세스는 모드 ㄴ스레드를 복제해야 한다.

## 4.6.2 신호 처리

`신호 (시그널)`은 UNIX에서 프로세스에 어떤 이벤트가 일어났음을 알려주기 위해 사용된다. 신호는 알려줄 이벤트의 근원지나 이유에 따라 동기식 또는 비동기식으로 전달될 수 있다.

모든 신호는 다음과 같은 형태로 전달된다

-   신호는 특정 이벤트가 일어나야 생성된다.
-   생성된 신호가 프로세스에 전달된다.
-   신호가 전달되면 반드시 처리되어야 한다.

동기식 신호의 예로는 불법적인 메모리 접근, 0으로 나누기 등이 있다. 실행 중인 프로그램이 이러한 행동을 하면 신호가 발생한다.

`동기식 신호를 발생시킨 연산을 수행한 동일한 프로세스에 전달된다.`

신호가 실행 중인 프로세스 외부로부터 발생하면 그 프로세스는 신호를 비동기식으로 전달받는다. 이러한 신호의 예로는 Ctrl + C 같은 특수한 키를 눌러스 프로세스를 강제 종료시키거나 타이머가 만료되는경우

`비동기식 신호는 통상 다른 프로세스에 전달된다.`

모든 신호는 둘 중 하나의 처리기에 의해 처리된다.

-   디폴트 신호 처리기
-   사용자 정의 신호 처리기

모든 신호마다 커널이 실행시키는 `디폴트 신호 처리기`가 있다. 이 디폴트 처리기는 신호를 처리하기 위하여 호출되는 `사용자 정의 처리기`에 의해 대체될 수 있다.

신호는 다른 방식으로 처리될 수 있다. 일부 신호는 무시될 수 있지만 다른 신호(예: 불법 메모리 액세스)는 프로그램을 종료하여 처리된다.

단일 스레드 프로그램에서의 신호 처리는 간단하다. 신호는 항상 프로세스에 전달된다.

그러나 프로세스가 여러 스레드를 가지고 있는 다중스레드 프로그램에서의 신호 처리는 더욱 복잡하다.

일반적으로 다음과 같은 선택이 존재한다.

-   신호가 적용될 스레드에게 전달한다.
-   모든 스레드에 전달한다.
-   몇몇 스레드들에만 선택적으로 전달한다.
-   특정 스레드가 모든 신호를 전달받도록 지정한다.

신호를 전달하는 방법은 신호의 유형에 따라 다르다. 동기식 신호는 그 신호를 야기한 스레드에 전달되어야 하고 다른 스레드에 전달되면 안된다.

그러나 비동기식 신호는 명확하지 않다. Control + C 같은 키를 쳐서 프로세스를 강제 종료하는 신호와 같은 비동기적 신호는 그 프로세스 내 모든 스레드에 전달되어야 한다.

신호를 전달하는 데 사용되는 표준UNIX 함수

```unix
kill(pid_t pid, int signal)
```

대부분의 다중스레드 UNIX는 스레드에 받아들일 신호와 봉쇄할 신호를 지정할 수 있는 선택권을 준다.

따라서 어떤 경우에는 비동기식 신호를 봉쇄하지 않고 있는 스레드들에게만 신호를 전달해야 할 수 있다. 하지만 신호는 오직 한 번만 처리되어야 하기 때문에 해당 신호를 봉쇄하지 않고 있는 첫 번째 스레드에만 신호가 전달된다.

POSIX Pthreads 는 tid로 지정된 스레드에만 전달이 되도록 허용하는 다음과 같은 함수를 제공한다.

```shell
pthread_kill(pthread_t tid, int signal)
```

Windows는 신호를 명시적으로지원 하지는 않지만 `비동시기 프로시저 호출(asynchronous procedure calls, APC)`이라는 것을 사용해서 이를 대리 실행(emulate) 할 수 있다.

APC는 사용자 스레드들이 특정 이벤트의 발생을 전달받았을 때 호출될 함수를 지정할 수 있게 한다.

이름이 의미하는 바와 같이 APC는 UNIX의 비동기식 신호와 유사하다. 그러나 UNIX에서는 다중 스레드 환경에서 신호를 어떻게 처리해야 할지를 고민해야 하지만 APC는 프로세스에 전달되는 것이 아니라 특정 스레드에 전달되기 때문에 더 간단한다.

## 4.6.3 스레드 취소

`스레드 취소`는 스레드가 끝나기 전에 그것을 강제 종료시키는 작업을 일컫는다.

예로 스레드가 데이터베이스를 병렬로검색하고 있다가. 그중 한 스레드가 결과를 찾았다면 나머지 스레드는 취소되어도 된다.

이처럼 취소되어야 할 스레드를 `목적 스레드`라고 부른다. 목적 스레드의 취소는 다음과 같은 두 가지 방식으로 발생할 수 있다.

-   비동기식 취소 (asynchronous cancellation) : 한 스레드가 즉시 목적 스레드를 강제 종료시킨다.

-   지연 취소(deferred cancellation) : 목적 스레드가 주기적으로 자신이 강제 종료되어야 할지를 점검한다. 이경우 목적 스레드가 질서정연하게 강제 종료될 수 있는 기회라 만들어진다. (주로 사용)

스레드 취소를 어렵게 만드는 것은 취소 스레드들에 할당된 자원 문제이다. 또한 스레드가 다른 스레드와 공유하는 자료구조를 갱신하는 도중에 취소 요청이 와도 문제가 된다.

후자의 문제는 비동기식 취소의 경우 더욱 심각하다. 종종 운옃ㅇ체제는 취소된 스레드로부터 시스템 자원을 회수할 수도 있지만, 모든 시스템 자원을 다 회수하지 못하는 경우도 있다.

따라서 비동기식으로 스레드를 취소하면 필요한 시스템 자원을 다 사용가능한 상태로 만들지 못할 수도 있다.

반대로 지연 취소의 경우에는 한 스레드가 목적 스레드를 취소해야 한다고 표시하지만 실제 취소는 목적 스레드가 취소 여부를 결정하기 위한 플래그를 검사한 이후에야 일어난다.

스레드는 자신이 취소되어도 안전하다고 판단되는 시점에서 취소 여부를 검사할 수 있다.

기본 취소 유형은 지연 취소이다. 그러나 스레드가 `취소 점`에 도달한 경우메나 취소가 발생한다.

## 4.6.4 스레드-로컬 저장장치

한 프로세스에 속한 스레드들은 프로세스의 데이터를 모두 공유한다 데이터 공유는 다증 스레드 프로그래밍의 큰 장점 중 하나이다.

상항에 따라서는 스레드가 자기만 액세스할 수 있는 데이터를 가져야할 필요도 있다. 그러한 장치를 `스레드 로컬 저장장치`(TLS)라고 부른다.

예로 트랜잭션 처릿 시스템에서 각 트랜잭션을 독립된 스레드가 처리해 준다고 가정 트랜잭션은 고유한 트랜잭션 식별자가 주어질때 스레드마다 고유한 식별자를 연관시키기 위해서는 스레드 국지 저장소가 있어야만한다.

TLS를 지역변수와 혼동하기 쉽다. 그러나 지역변수가 하나의 함수가 호출되든 동안에만 보이지만 TLS는 전체 함수 호출에 걸쳐 보인다. 또한 개발자가 스레드 생성 과정에 대해 제어할 수 없는 경우 (스레드 풀과 같은 암묵적 기법을 사용하는 경우) 다른 방법이 필요하다.

TLS는 정적 데이터와 유사하다. 차이점은 TLS데이터는 스레드마다 고유하다는 것(TLS는 보통 static으로 선언된다.)

대부분의 스레드 라이브러리 및 컴파일러는 TLS를 지원한다. 예를 들어 Java는 ThreadLocal<T>객체에 대한 set() 및 get() 메소드와 함께 제공한다.

Pthread에는 pthread_key_t 유형이 포함되어 있으며 각 스레드에 고유한 키를 제공한다. 그런 다음이 키를 사용하여 TLS 데이터에 접근할 수 있다.

## 4.6.5 스케줄러 액티베이션

다중 스레드 프로그램과 관련하여 마지막으로 고려할 문제는 스레드 라이브러리와 커널의 통신문제

이 통신은 다대다 및 두 수준 모델에서 반드시 해결해야 할 문제이다. 이러한 통신의 조정은 응용 프로그램이 최고의 성능을 보이도록 보장하기 위하여 커널 스레드의 수를 동적으로 조절하는 것을 가능하게 한다.

다대다 또는 두 수준 모델을 구현하는 많은 시스템은 사용자와 커널 스레드 사이에 중간 자료구조를 둔다.

이 자료구조는 통상 `경량 프로세스` 또는 `LWP`라고 불린다. 사용자 스레드 라이브러리에 LWP 방식은 응용이 사용자 스레드를 수행하기 위하여 스레줄 할 가장 처리기처럼 보인다.

각 LWP는 하나의 커널 스레드에 부속되어 있으며 물리 처리기에서 스케줄 하는 대상은 바로 이 커널 스레드이다.

입출력이 완료되기를 기다리는 동안 같이 커널 스레드가 봉쇄되면 LWP도 같이 봉쇄된다. 이 연관을 따라 LWP에 부속된 사용자 수준 스레드도 역시 봉쇄된다

응용은 효율적으로 실행되기 위하여 임의의 개수의 LWP를 필요로 할 수도있다. 통상 동시에 발생하는 봉쇄형 시스템 콜마다 하나의 LWP가 필요하다.

사용자 스레드 라이브러리와 같은 커널 스레드 간의 통신 방법의 하나는 `스케줄러 액티베이션`이라고 알려진 방법이다.

이것의 동작은 커널은 응용에 가상 처리기(LWP)의 집합을 제공하고 응용은 사용자 스레드를 가용한 가상 처리기로 스케줄한다.

게다가 커널은 응용에게 특정 이벤트에 대해 알려줘야 한다. 이 프로시저를 `upcall`이라고 부른다. UpCall은 스레드 라이브러리의 upcall 처리기에 의해 처리되고, `upcall 처리기`는 가상 처리기 상에서 실행되어야 한다.

Upcall을 일으키는 한 이벤트는 응용 스레드가 봉쇄하려고 할 때 발생한다. 이 시나리오에서 커널은 스레드가 봉쇄하려고 한다는 사실과 그 스레드의 식별자는 알려 주는 upcall을한다. 그 후 커널은 새로운 가상 처리기를 응용에 할당한다.

응용은 이 새로운 가상 처리기상에서 upcall 처리기를 수행하고 이 upcall 처리기는 봉쇄 스레드의 상태를 저장하고 이 스레드가 실행 중이던 가상 처리기를 반환한다. 그리고 upcall처리기는 새로운 가상 처리기에서 실행 가능한 다른 스레드를 스케줄한다.

봉쇄 스레드가 기다리던 이벤트가 발생하면 커널은 이전에 봉쇄되었던 스레드가 이제 실행할 수 있다는 사실을 알려주며 또 다른 upcall을 스레드 라이브러리에 한다.

이 이벤트를 처리하는 upcall 처리기도 가상 처리기가 필요하고 커널은 새로운 가상 처리기를 할당하거나 사용자 스레드 하나를 선점하여 그 처리기에서 이upcall 처리기를 실행한다. 봉쇄가 풀린 스레드를 실행 가능 상태로 표시한 후 응용은 가상 처리기상에서 다른 실행 가능한 스레드를 실행한다.

| 항목                           | 설명                                                                        |
| ------------------------------ | --------------------------------------------------------------------------- |
| **스케줄러 액티베이션**        | 사용자 스레드 ↔ 커널 스레드 간 협력 구조. 사용자에게 스케줄링 권한 부여     |
| **LWP (Light Weight Process)** | 커널이 제공하는 실행 가능한 가상 처리기                                     |
| **Upcall**                     | 커널이 사용자(스레드 라이브러리)에 이벤트 발생을 알리는 메커니즘            |
| **Upcall 처리기**              | 사용자 스레드 라이브러리에서 이벤트를 처리하는 코드. 항상 LWP 상에서 실행됨 |
| **장점**                       | 사용자 스레드의 성능/유연성과 커널 스레드의 효율성을 결합한 구조            |

> **스케줄러 액티베이션은 커널과 사용자 스레드 간의 협력을 위해 upcall을 통해 정보를 주고받으며, 사용자 스레드가 가상 처리기(LWP) 위에서 효율적으로 스케줄링되도록 지원하는 메커니즘이다.**

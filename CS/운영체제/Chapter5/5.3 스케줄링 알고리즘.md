# 스케줄링 알고리즘

CPU스케줄링은 준비 큐에 있는 어느 프로세스에 CPU 코어를 할당할 것인지를 결정하는 문제를 다룬다.

## 5.3.1 선입 선처리 스케줄링 (First-Come, First-Served Schedule)

가장 간단한 CPU 스케줄링 알고리즘은 `선입 선처리(FCFS)` 스케줄링 알고리즘이다. CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당 받는다.

프로세스가 준비 큐에 진입하면 이 프로세스의 프로세스 제어 블록을 큐의 끝에 연결한다. CPU가 가용 상태가 되면, 준비 큐의 앞부분에 있는 프로세스에 할당되고 준비큐에서는 제거된다.

단점으로는 평균 대기 시간은 종종 길 수 있다.

| 프로세스 | 실행 시간(Burst Time) | 시작 시간 | 종료 시간 | 대기 시간 |
| -------- | --------------------- | --------- | --------- | --------- |
| P1       | 5                     | 0         | 5         | 0         |
| P2       | 3                     | 5         | 8         | 5         |
| P3       | 8                     | 8         | 16        | 8         |

모든 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것을 `호위 효과(convoy effect)`라고한다. 이 효과는 짧은 프로세스들이 먼저 처리되도록 허용될 때보다 CPU와 장치 이용률이 저하되는 결과를 낳는다.

`선입 선처리 스케줄링 알고리즘은 비전섬형이라는 것 CPU가 한 프로세스에 할당되면 그 프로세스가 종료되거나 I/O 처리를 요구하든지 CPU를 방출할때까지 점유한다.`

대화형 시스템에서는 치명적인 단점인데 대화형 시스템에서는 각 프로세스가 규칙적인 간격으로 CPU의 몫을 얻는것이 중요하기 때문

## 5.3.2 최단 작업 우선 스케줄링 (Shortest-Job-First Scheduling)

CPU 스케줄링의 다른 접근 방법은 `최단 작업 우선(SJF)` 알고리즘이다. 이 알고리즘은 각 프로세스에 다음 CPU 버스트 길이를 연관시킨다. CPU가 이용가능해지면 가장 작은 다음 CPU 버스트 가진 프로세스에 할당한다.

두 프로세스가 동일한 길이의 CPU 버스트를 가지면 순위를 정하기 위해 선입 선처리 스케줄링을 적용한다.

이 스케줄링은 프로세스의 전체 길이가 아니라 다음 CPU 버스트의 길이에 의해 스케줄링 되기 때문에, 최단 다음 CPU 버스트 알고리즘이라는 용어가 더 적합하다.

SJF 스케줄링 알고리즘은 주어진 프로세스 집합에 대해 최소의 평균 대기 시간을 가진다는 점에서 최적임을 증명할 수 있다.

하지만 다음 CPU 버스트의 길이를 알 방법이 없기 때문에 CPU 스케줄링 수준에서는 구현할 수 없다.

한 가지 접근 방식은 SJF 스케줄링과 근사한 방법을 사용하는것 다음 CPU 버스트의 길이를 알 수는 없으나, 그 값을 예측 할 수는 있다.

우리는 다음 CPU 버스트가 이전의 버스트와 길이가 비슷하다고 기대한다. 다음 CPU 버스트 길이의 근삿값을 계산해 가장 짧은 예상 CPU 버스트를 가진 프로세스를 선택한다.

다음 CPU 버스트는 일반적으로 측정된 이전의 CPU 버스트들의 길이를 `지수 평균`한 것으로 예측한다.

SJF 알고리즘은 선점형이거나 또는 비선점형일 수 있다. 앞의 프로세스가 실행되는 동안 새로운 프로세스가 준비 큐에 도착하면 선택이 발생한다.

새로운 프로세스가 현재 실행되고 있는 프로세스의 남은 시간보다도 더 짧은 CPU 버스트를 가질 수도 있다.

선점형 SJF알고리즘은 현재 실행하는 프로세스를 선점할 것이고 비선점형 SJF알고리즘은 현재 실행하고 있는 프로세스가 자신의 CPU버스트를 끝내도록 허용한다.

선점형 SJF 알고리즘은 때때로 `최소 잔여 시간 우선`스케줄링이라고도 불린다.

### ✅ SJF 스케줄링 예시 - 평균 대기 시간 계산

| 프로세스 | 실행 시간(Burst Time) | 시작 시간 | 종료 시간 | 대기 시간 |
| -------- | --------------------- | --------- | --------- | --------- |
| P2       | 3                     | 0         | 3         | 0         |
| P1       | 5                     | 3         | 8         | 3         |
| P3       | 8                     | 8         | 16        | 8         |

## 5.3.3 라운드 로빈 스케줄링

`라운드 로빈(RR)` 스케줄링 알고리즘은 선입 선처리 스케줄링과 유사하지만 시스템이 프로세스들 사이를 옮겨 다닐 수 있도록 선점이 추가된다.

`시간 할당량 또는 타임 슬라이스`라고 하는 작은 단위의 시간을 정의한다.

시간 할당량을 인반적으로 10에서 100밀리초 동안이다 준비 큐는 원형 큐로 동작한다.

CPU 스케줄러는 준비 큐를 돌면서 한 번에 한 프로세스에 한번의 시간 할당량 동안 CPU를 할당한다.

라운드 로빈 스케줄링을 구현하기 위해 다시 큐가 선입선출로 동작하게 만든다.
새로운 프로세스들은 준비 큐의 꼬리에 추가된다. CPU 스케줄러는 준비 큐에서 첫 번째 프로세스를 선택해 한 번의 시간 할당량 이후에 인터럽트를 걸도록 타이머를 설정한 후, 프로세스를 디스패치 한다.

두 가지 경우중 하나가 발생할 것이다.

-   프로세스의 CPU 버스트가 한 번의 시간 할당량보다 작을 수 있다. 이경우 프로세스 자신이 CPU를 자발적으로 방출 할것

-   현재 실행 중인 프로세스의 CPU 버스트가 한번의 시간 할당량 보다 긴 경우로 타이머가 끝나고 운영체제에 인터럽트를 발생
    -   문맥 교환이 일어나고 실행하던 프로세스는 준비 큐의 꼬리에 넣어진다.

RR알고리즘의 성능은 시간 할당량의 크기에 매우 많은 영향을 받는다. 시간 할당량이 너무 크면 RR 정책은 선입 선처리 정책과 같다. 반대로 시간 할당량이 너무 적다면 RR 정책은 매우 많은 문맥 교환을 야기한다.

시간 할당량이 문맥 교환 시간과 비교해 더 클 것을 원한다. 문맥 교환시간이 시간 할당량의 10%에 근접한다면 CPU 시간의 약 10%는 문맥 교환에 사용될 것

실제로 대부분의 현대 운영체제들은 10에서 100 밀리초 범위의 시간 할당량을 가지고 있다. 문맥 교환을 하는 데 걸리는 시간은 보통 10마이크로초 미만이다.

따라서 문맥 교환 시간은 시간 할당량의 작은 부분을 차지한다.

시간 할당량이 문맥 교환 시간에 비해 커야 하지만 너무 커서는 안된다. 너무 크다면 결국 선입 선처리 정책으로 퇴보한다. 경험으로 CPU버스트 80%는 시간 할당량 보다 짧아야 한다.

### ✅ Round Robin 스케줄링 예시 (Time Quantum = 4)

-   프로세스는 모두 도착 시간이 0으로 같다고 가정

| 프로세스 | 실행 시간(Burst Time) | 종료 시간 | 대기 시간 |
| -------- | --------------------- | --------- | --------- |
| P1       | 10                    | 18        | 9         |
| P2       | 4                     | 8         | 4         |
| P3       | 5                     | 17        | 12        |

## 5.3.4 우선순위 스케줄링

SJF 알고리즘은 일반적인 `우선순위 스케줄링`알고리즘의 특별한 경우이다. 우선순위가 각 프로세스들에 연관되어 있으며, CPU는 가장 높은 우선순위를 가진 프로세스에 할당된다.

우선순위가 같은 프로세스들은 선입 선처리(FCFS)순서로 스케줄된다. SJF 알고리즘은 우선순위가 다음 CPU 버스트의 역인 단순한 우선순위 알고리즘이다.

우선순위는 내부적 또는 외부적으로 정의될 수 있다. 내부적으로 정의된 우선순위는 프로세스의 우선순위를 계산하기 위해 어떤 측정 간으한 양들을 사용한다

예를 들어 시간제한, 메모리 요구, 열린 파일의 수, 평균 I/O 버스트의 평균 CPU 버스트에 대한 비율 등이 우선순위의 계산에 사용된다.

외부적 우선순위는 프로세스의 중요성, 컴퓨터 사용을 위해 지불되는 비용의 유형과 양, 그 작업을 후원하는 부서 그리고 정치적인 요인 등과 같은 운영체제 외부적 기준에 의해 결정된다.

우선순위 스케줄링은 선점형이거나 또는 비선점형이 될 수 있다. 프로세스가 준비 큐에 도착하면 새로 도착한 프로세스의 우선순위를 현재 실행 중인 프로세스의 우선순위와 비교한다.

`선점형 우선순위 스케줄링 알고리즘은 새로 도착한 프로세스의 우선순위와 비교한다. 새로 도착한 프로세스의 우선순위가 현재 실행중인 프로세스의 우선순위 보다 높다면 CPU를 선점한다.`

비선점형 우선순위 스케줄링 알고리즘은 단순히 준비완료 큐의 머리 부분에 새로운 프로세스를 넣는다.

우선순위 스케줄링 알고리즘의 주요 문제는 `무한 봉쇄` 또는 `기아 상태`이다.

실행 준비는 되어 있으나 CPU를 사용하지 못하는 프로세스는 CPU를 기다리면서 봉쇄된 것으로 간주할 수 있다.

우선순위가 낮은 프로세스는 CPU를 무한히 대기하는 경우가 발생한다. 결국에는 프로세스가 실행되거나, 컴퓨터 시스템이 결국 크래시하여 프로세스들을 읽어버린다.

낮은 우선순위의 프로세스들이 무한히 봉쇄되는 문제에 대한 한가지 해결방안은 `노화`이다. 노화는 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시킨다.

## 5.3.5 다단계 큐 스케줄링

우선순위와 라운드 로빈 스케줄링을 사용할 떄 모든 프로세스가 단일 큐에 배치되고 스케줄러는 우선순위가 가장 높은 프로세스를 선택하여 실행시킬 수 있다.

큐가 관리되는 방식에따라 우선순위가 가장 높은 프로세스 결정하기 위해 O(n)검색이 필요할 수 있다. 실제로 우선순위마다 별도의 큐를 갖는 것이 더 쉬운 때도 있으며 우선순위 스케줄링은 우선순위가 가장 높은 큐에서 프로세스를 스케줄 한다.

`다단게 큐`라고 하는 이 방법은 우선순위 스케줄링이 라운드 로빈과 결합한 경우에도 효과적이다. 우선순위가 가장 높은 큐에 여러 프로세스가 있는 경우 라운드 로빈 순서로 실행된다.

이 방식의 가장 일반적인 형태에서 우선순위가 각 프로세스에 정적으로 할당되며 프로세스는 실행시간 동안 동일한 큐에 남아있다.

프로세스 유형에 따라 프로세스를 여러 개의 개별 큐로 분할하기 위해 다단계 큐 스케줄링 알고리즘을 사용할 수도 있다. 예로 `포그라운드(대화형)` 프로세스와 `백그라운드(배치)` 프로세스를 구분한다.

이 두 가지 유형의 프로세스는 응답시간 요구사항이 다르므로 스케줄링 요구 사항이 다를 수 있다.

추가로 큐와 큐 사이의 스케줄링도 반드시 있어야 하며, 일반적으로 고정 우선순위의 선점형 스케줄링으로 구현된다. 예로 실시간 큐는 대화형 큐보다 절대적으로 높은 우선순위를 가질 수 있다.

4개의 큐를 가진 다단계 스케줄링 알고리즘에서의 우선순위 예

1. 실시간 프로세스
2. 시스템 프로세스
3. 대화형 프로세스
4. 배치 프로세스

각 큐는 낮은 우선순위의 큐보다 절대적인 우선순위를 가진다. 배치 프로세스는 상위 큐가 모두 비어있지 않으면 실행될 수 없다. 배치 프로세스 진행중 대화형 프로세스가 준비 큐에 들어가면 배치 프로세스는 선점된다.

또는 각 큐에서 시간을 나누어 사용하는 것 각 큐에서 CPU 시간의 일정량을 받아서 자기 큐에 있는 프로세스들을 스케줄한다. 예로 포그라운드 80% 백그라운드 20%의 CPU 시간 할당

## 5.3.6 다단계 피드백 큐 스케줄링

다단계 큐 스케줄링 알고리즘에서는 일반적으로 프로세스들이 시스템 진입 시에 영구적으로 하나의 큐에 할당된다.

예로 포그라운드와 백그라운드 프로세스를 위해 별도의 큐가 있으면, 프로세스들은 한 큐에서 다른 큐로 이동하지 않는다. 프로세스들이 포그라운드와 백그라운드의 특성을 바꾸지 않기 때문

이러한 방식은 스케줄링 오버헤드가 장점이 있으나 융통성이 적다

대조적으로 `다단계 피드백 큐 스케줄링 알고리즘`에서는 프로세스가 큐들 사이를 이동하는 것을 허용한다.

프로세스들을 CPU 버스트 성격에 따라서 구분한다. 어떤 프로세스가 CPU 시간을 너무 많이 사용하면, 낮은 우선순위의 큐로 이동된다.

이방법에서는 I/O 중심의 프로세스와 대화형 프로세스들을 높은 우선수위 큐에 넣는다(CPU 버스트 시간이 통상적으로 짧다)

마찬가지로 낮은 우선수위의 큐에서 너무 오래 대기하는 프로세스는 높은 우선순위의 큐로 이동할 수 있다. (기아 상태 예방)

큐0,1,2가 있을때

이 스케줄링 알고리즘은 CPU 버스트가 예로 8 밀리초 이하인 모든 프로세스에 최고의 우선순위를 부여한다. 이러한 프로세스는 빨리 CPU를 할당받아서 CPU 버스트를 끝내고 I/O 버스트로 간다. 8밀리초 이상 24밀리초 이하의 프로세스들은 더 짧은 프로세스들보다 낮은 우선순위를 받지만 역시 서비스를 빨리 받는다. 긴 프로세스들은 자동으로 큐 2로 가게되며 큐0과 큐1이 사용하지 않는 CPU 주기에 선입 선처리 방식으로 처리된다.

일반적으로 다단계 피드백 큐 스케줄러는 다음의 매개변수에 의해 정의된다.

-   큐의 개수
-   각 큐를 위한 스케줄링 알고리즘
-   한 프로세스를 높은 우선순위 큐로 올려주는 시기를 결정하는 방법
-   한 프로세스를 낮은 우선순위 큐로 강등시키는 시기를 결정하는 방법
-   프로세스에 서비스가 필요할 때 프로세스가 들어갈 큐를 결정하는 방법

다단계 피드백 큐 스케줄러의 정의에 의하면 이 스케줄링 알고리즘은 가장 일반적인 CPU 스케줄링 알고리즘이다.

이 알고리즘은 설계 중인 특정 시스템에 부합하도록 구성 가능하다. 그러나 가장 좋은 스케줄러로 동작하기 위해서는 모든 매개변수들의 값을 선정하는 특정 방법이 필요하기 때문에 가장 복잡한 알고리즘이기도 하다.

# 운영체제 사례들

## 5.7.1 Linux 스케줄링

Linux의 프로세스 스케줄링은 버전 2.5 까지는 전통적인 UNIX 스케줄링 알고리즘의 변형을 사용하였다.

하지만 이 알고리즘은 SMP(대칭 다중 처리) 시스템을 염두에 두고 설계되지 않았기 때문에 다중 처리기 시스템을 충분히 지원하지 않는다. 매우 많은 프로세스가 실행되는 시스템에서는 저조한 성능을 보인다.

버전 2.5에서 이 스케줄러는 철저하게 분석, 수정되어 시스템에 존재하는 태스크 개수와 상관없이 항상 상수 시간에 실행되는 O(1)이라고 알려진 스케줄링 알고리즘이 포함되었다.

이 새로운 스케줄러는 또한 처리기 진화 정책과 처리기 사이에 부하를 균등하게 하는 기능등 SMP를 위한 향상된 지원을 제공한다.

실제 운용 면에서 O(1)스케줄러는 SMP 시스템에서 출중한 성능을 보이지만 대화형 프로세스에 대해서는 느린 응답시간을 보인다.

2.6 커널을 개발하는 동안 스케줄러는 다시 개선되었고, 2.6.23 커널부터는 완전 공평 스케줄러가 Linux시스템의 디폴트 스케줄링 알고리즘이 되었다.

Linux 스케줄러는 각 클래스별로 특정 우선순위를 부여받는 `스케줄링 클래스`에 기반을 두고 동작한다. 다른 스케줄링 클래스를 사용하여 시스템과 프로세스의 요구 조건에 따라 커널은 다른 스케줄링 알고리즘을 수용할 수 있다.

표준 Linux 커널은 (1) CFS 스케줄링 알고리즘을 사용하는 디폴트 스케줄링 클래스와 (2) 실시간 스케줄링 클래스의 두 스케줄링 클래스를 구현한다.

CFS 스케줄러는 상대 우선운위에 상응하는 시간 할당량의 길이가 정해져 있는 경직된 규칙을 사용하지 않고 각 태스크에 CPU 처리시간의 비율을 할당한다.

## 5.7.2 Windows 스케줄링

Windows 우선순위에 기반을 둔 선점 스케줄링 알고리즘을 사용한다. 커널 중 스케줄링을 담당하는 부분을 디스패처라고 부른다.

디스패처에 의해 선택된 스레드는 높은 우선순위 스레드에 의해 선점되든지, 연산이 다 끝나든지, 시간 할당량이 만료되든지, 입출력을 위한 것과 같은 봉쇄를 일으키는 시스템 콜을 호출할 때까지 실행된다.

디스패처는 스레드의 실행 순서를 정하기 위하여 32단계의 우선순위를 두고 있다. 우선순위는 두 클래스로 구분된다

-   가변클래스 : 1~15
-   실시간 클래스 : 16~31

우선순위가 0인 스레드도 존재하는데 이 스레드는 메모리 관리를 위해서 사용된다.

디스패처는 각 우선순위를 위하여 큐를 사용하고 이들 큐를 높은 우선순위부터 낮은 우선순위까지 조사하면서 준비 상태의 스레드가 있는 지를 본다.

준비 상태에 있는 스레드가 없으면 디스패처는 `idle스레드`라고 불리는 특수한 스레드를 실행시킨다.

Windows API는 프로세스들이 속할 수 있는 몇 가지 6 우선순위 클래스를 제공한다.

-   IDLE PRIORITY CLASS
-   BELOW NORMAL PRIORITY CLASS
-   NORMAL PRIORITY CLASS
-   ABOVE NORMAL PRIORITY CLASS
-   HIGH PRIORITY CLASS
-   REALTIME PRIORITY CLASS

프로세스는 통상 NORMAL PRIORITY CLASS 에 속한다. 부모 프로세스가 IDLE PRIORITY CLASS에 속하지 않고 프로세스가 생성될 때 다른 클래스는 명시되지 않는 한 프로세스는 이 클래스에 속하게 된다.

프로세스 우선순위 클래스는 SetPriorityClass()함수를 사용하여 변경될 수 있다.

REALTIME PRIORITY CLASS를 제외한 모든 우선순위 클래스는 가변적이고 이는 클래스에 속한 스레드의 우선순위가 변할 수 있다는 것을 뜻한다.

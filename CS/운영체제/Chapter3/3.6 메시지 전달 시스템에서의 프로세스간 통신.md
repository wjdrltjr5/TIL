# 메시지 전달 시스템에서의 프로세스간 통신

메시지 전달 방식은 동일한 주소 공간을 공유하지 않고도 프로세스들이 통신을 하고, 그들의 동작을 동기화할 수 있도록 허용하는 기법을 제공

통신하는 프로세스들이 네트워크에 의해 연결된 다른 컴퓨터들에 존재할 수 있는 분산 환경에서 특히 유용하다. (채팅기능)

메시지 전달 시스템은 최소한 두 가지 연산을 제공한다.

-   send(message)
-   receive(message)

프로세스가 보낸 메시지는 고정 길이일 수도 있고 가변 길이일 수도 있다. 프로세스 P, Q가 통신을 원하면 반드시 서로 메시지를 보내고 받아야 한다. 이들 사이에 통신 연결이 설정되어야 한다.

하나의 링크와 send()/receive() 연산을 논리적으로 구현하는 다수의 방법은 다음과 같다.

-   직접 또는 간접 통신
-   동기식 또는 비동기식 통신
-   자동 또는 명시적 버퍼링

## 3.6.1 명명

`직접 통신`하에서 , 통신을 원하는 각 프로세스는 통신의 수신자 또는 송신자의 이름을 명시해야 한다.

-   send(P, message) : 프로세스 P에 메시지를 전송
-   receive(Q, message) : 프로세스 Q로부터 메시지를 수신

이 기법에서 통신 연결은 다음의 특성을 가진다.

-   통신을 원하는 각 프로세스의 쌍들 사이에 연결이 자동으로 구축된다. 프로세스들은 상대방의 신원만 알면 된다.
-   연결은 정확히 두 프로세스 사이에만 연관된다.
-   통신하는 프로세스들의 각 쌍 사이에는 정확하게 하나의 연결이 존재해야 한다.

이 기법은 주소 방식에서의 대칭성을 보인다. 즉 송신자와 수신자 프로세스가 모두 통신하려면 상대방의 이름을 제시해야한다.

이 기법의 변형으로 주소 지정시에 비대칭을 사용할 수도 있다. 송신자만 수신자의 이름을 지명하며, 수신자는 송신자의 이름을 제시할 필요가 없다.

이 기법에서의 send(), receive()

-   send(P, message) : 메시지를 프로세스 P에 전송한다.
-   receive(id, message) : 임의의 프로세스로부터 메시지를 수신한다. 변수id는 통신을 발생시킨 프로세스의 이름으로 설정된다.

이들 대칭적, 비대칭적 모두 프로세스를 지정하는 방식 때문에 모듈성을 제한한다는 것이 단점이다. 프로세스의 이름을 바꾸면 모든 다른 프로세스 지정 부분을 검사할 필요가 있을 수 있다.

일반적으로 이러한 하드코딩 기법은 이 상황에서는 신원을 명시적으로 표시해야 한다. 다음에 설명할 간접적인 방식에 비해 바람직하지 않다.

간접 통신에서 메시지들은 메일 박스 또는 포트로 송신되고, 그것으로부터 수신된다. 메일박스는 추상적으로 프로세스들에 의해 메시지들이 넣어지고, 메시지들이 제거될 수 있는 객체라고도 볼 수 있다

각 메일박스는 고유의 id를 가진다. POSIX 메시지 큐는 메일박스를 식별하기 위하여 정수 값을 사용한다.

이 기법에서 프로세스는 다수의 상이한 메일박스를 통해 다른 프로세스들과 통신할 수 있다. 두 프로세스들이 공유 메일박스를 가질 때만 이들 프로세스가 통신할 수 있다.

-   send(A, message) : 메시지는 메일박스 A로 송신한다.
-   receive(A, message) : 메시지를 메일박스 A로부터 수신한다.

이 방법에ㅐ서 통신 연결은 다음의 성질을 가진다.

-   한 쌍의 프로세스들 사이의 연결은 이들 프로세스가 공유 메일박스를 가질 때만 구축된다.

-   연결은 두 개 이상의 프로세스들과 연관될 수 있다.

-   통신하고 있는 각 프로세스 사이에는 다수의 서로 다른 연결이 존재할 수 있고, 각 연결은 하나의 메일박스에 대응된다.

프로세스 p1,p2,p3가 모두 메일박스 A를 공유한다고 가정하자. 프로세스 p1은 메시지를 A에 송신하고 p2, p3는 각각 A로부터 receive()를 실행한다.

어느 프로세스가 메시지를 수신받는지 여부

-   하나의 링크는 최대 두 개의 프로세스와 연관되도록 허용한다.
-   한순간에 최대로 하나의 프로세스가 receive() 연산을 실행하도록 허용한다.
-   어느 프로세스가 메시지를 수신할 것인지 시스템이 임의로 선택되도록 한다. (즉 두 프로세스는 모두는 아니고 p2나 p3중 하나가 메시지를 수신한다.)
    -   시스템이 어느 프로세스가 수신할 것인지를 선택하는 알고리즘을 정의할 수 있다. (예를 들어 라운드 로빈 방식에서는 프로세스가 돌아가면서 메시지를 수신한다.)
    -   시스템은 송신자에게 수신자를 알려 줄 수 있다.

메일박스는 한 프로세스 또는 운영체제에 의해 소유될 수 있다. 메일박스가 한 프로세스에 의해 소유된다면(즉, 메일박스가 프로세스의 주소 공간의 일부이다.), 우리는 소유자(이 메일박스로부터 메시지를 수신만 가능한 프로세스)와 메일박스의 사용자를(메일박스에 메시지를 송신만 할 수 있는 프로세스) 구분할 수 있다.

각 메일박스가 고유한 소유자를 가지고 있기 떄문에, 이 메일박스로 보내진 메시지를 어느 프로세스가 수신할지에 대한 혼란이 있을 수 없다.

메일박스를 소유하고 있는 프로세스가 종료할때, 메일박스는 사라지므로 이 메일박스로 메시지를 송신하는 모든 프로세스는 메일박스가 존재하지 않는다는 사실을 반드시 통보받아야 한다.

반면 운영체제가 소유한 메일박스는 자체적으로 존재한다. 이것은 독립적인 것으로 어떤 특정한 프로세스에 예속되지 않는다 운영체제는 한 프로세스에 다음을 할 수 있도록 허용하는 기법을 반드시 제공해야 한다.

-   새로운 메일박스를 생성한다.
-   메일박스를 통해 메시지를 송신하고 수신한다.
-   메일박스를 삭제한다.

새로운 메일 박스를 생성하는 프로세스는 디폴트로 메일박스의 소유자가 된다. 초기에는 소유자 만이 이 메일박스를 통해 메시지를 수신할 수 있는 유리한 프로세스이다.

추후에 소유권한 수신 특권은 적절한 시스템 콜을 통해 다른 프로세스에 전달될 수 있다. 이런 규칙으로 인해 메일박스마다 복수의 수신자들을 낳을 수 있다.

## 3.6.2 동기화

프로세스간 통신은 send와 receive 피리미티브에 대한 호출에 의해 발생한다. 각 프리미티브를 구현하기 위한 서로 다른 설계 옵션이 있다.

메시지 전달은 `봉쇄형 (blocking)`이거나 `비봉쇄형(nonblocking)` 이 두가지 방식은 각각 `동기식`, `비동기식`이라고도 알려져 있다.

-   봉쇄형 보내기 : 송신하는 프로세스는 메시지가 수신 프로세스 또는 메일박스에 의해 수신될 때까지 봉쇄된다.
-   비봉쇄형 보내기 : 송신하는 프로세스가 이 메시지를 보내고 작업을 재시작한다.
-   봉쇄형 받기 : 메시지가 이용 가능할 때까지 수신 프로세스가 봉쇄된다.
-   비봉쇄형 받기 : 송신하는 프로세스가 유효한 메시지 또는 null을 받는다.

send()와 receive()의 다른 조합도 가능하다. send()와 receive()가 모두 봉쇄형일 때, 우리는 송신자와 수신자 간에 `랑데부`를 하게된다 이러면 생산자와 소비자 문제에 대한 해결책은 사소한 문제가 된다.

생산자는 단순히 봉쇄형 send()를 호출하고 메시지가 수신자 또는 메일박스에 전달될 때까지 기다린다. 유사하게 소비자가 receive()를 호출하면 메시지가 전달될 때까지 봉쇄된다.

예외조건

-   프로세스 종료 : 메시지 처리되기전에 송/수신자 종료
-   메시지 유실 : 하드웨어나 통신고장으로 네트워크상 어디서 유실
-   훼손 메시지 : 배달은 되었으니 훼손

## 3.6.3 버퍽링

통신이 직간접적이든 간에 통신하는 프로세스들에 의해 교환되는 메시지는 임시 큐에 들어있다 이러한 큐를 구현하는 방식 세가지

-   무용량(zero capacity) : 큐의 최대 길이가 0이다. 즉, 링크는 자체 안에 대기하는 메시지들을 가질 수 없다. 이 경우에, 송신자는 수신자가 메시지를 수신할 때까지 기대려야 한다.

-   유한 용량(bounded capacity) : 큐는 유한한 길이 n을 가진다. 새로운 메시지 전송시 큐가 만원이 아니라면 메시지는 큐에 놓이며(복사 or 메시지에 대한 포인터가 유지된다.), 송신자는 대기하지 않고 실행을 계속한다.

    -   링크가 만원이면 송신자는 큐 안에 공간을 이용 가능할 때까지 봉쇄되어야 한다.

-   무한 용량(unbounded capacity) : 큐는 잠재적으로 무한한 길이를 가진다. 까라서 메지시들이 얼마든지 큐 안에서 대기할 수 있다 송신자는 절대 봉쇄되지 않는다.

무용량의 경우 때떄로 버퍼가 없는 메시지 시스템이라고 부른다. 다른 경우들은 자동 버퍼링이라고 불린다.

# 프로세스에 대한 연산

프로세스들은 병행 실행될 수 있으며 반드시 동적으로 생성되고, 제거되어야 한다. 운영체제는 프로세스 생성 및 종료를 위한 기법을 제공해야 한다.

## 3.3.1 프로세스 생성

실행되는 동안 프로세스는 여러 개의 새로운 프로세스들을 생성할 수 있다. 같이 생성하는 프로세스를 부모 프로세스라고 부르고 새로운 프로세스는 자식 프로세스라고 부른다.

이 새로운 프로세스들은 각각 다시 다른 프로세스들을 생성할 수 있으며, 그 결과 프로세스의 `트리`를 형성한다.

UNIX, Linux 및 Windows와 같은 대부분의 현대 운영체제들은 `프로세스 식별자 (PID)`를 사용하여 프로세스를 구분한다.

식별자를 통하여 커널이 유지하고 있는 프로세스의 다양한 속성에 접근하기 위한 인덱스로 사용된다.

Linux의 경우(프로세스보다 태스크라는 용어를 선호) 언제나 PID가 1인 systemd 프로세스가 모든 사용자 프로세스의 루트 부모 프로세스 역할을 수행하고 시스템이 부트될때 생성되는 첫 번째 사용자 프로세스이다.

시스템에 부팅되면 systemd 프로세스는 다양한 사용자 프로세스를 추가한다.

systemd의 두 자식 프로세스 logind와 sshd 프로세스를 볼 수 있다.

logind 프로세스는 시스템에 직접 로그인하는 클라이언트를 관리하는 책임을 진다.

sshd 프로세스는 ssh을 (secure shell의 축약어)사용하여 시스템에 접속하는 클라이언트의 관리를 책임진다.

UNIX와 Linux시스템에서는 ps명령어를 이용하여 프로세스들의 목록을 얻을 수 있다.

```shell
//현재 시스템에 활성화 되어있는 모든 프로세스의 정보 나열
ps -el

// 프로세스 트리를 보여주는 명령
pstree
```

자식 프로세스의 자원은 운영체제로부터 직접 얻거나, 부모 프로세스가 가진 자원의 부분집합만을 사용하도록 제한될 수 있다.

부모 프로세스는 자원을 분할하여 자식 프로세스들에게 나눠 주거나 메모리나 파일과 같은 몇몇 자원들은 자식 프로세스들이 같이 사용하게 할 수 있다.

물리적, 논리적 자원을 제공하는 것 이외에 부모 프로세스는 자식 프로세스에 초기화 데이터(입력)를 전달할 수 있다.

프로세스가 새로운 프로세스를 생성할 때, 두 프로세스를 실행시키는 데 두가지 가능한 방법이 존재한다.

-   부모는 자식과 병행하게 실행을 계속한다.
-   부모는 일부 또는 모든 자식이 실행을 종료할 때 까지 기다린다.

새로운 프로세스들의 주소 공간 측면에서 볼 때 다음과 같은 두 가지 가능성이 있다.

-   자식 프로레스는 부모 프로세스의 복사본이다(자식 프로세스는 부모와 똑같은 프로그램과 데이터를 가진다.)

-   자식 프로세스가 자신에게 적재될 새로운 프로그램을 가지고 있다.

이둘의 차이는 UNIX에서 새로운 프로세스는 fork()시스템 콜로 생성된다.

새로운 프로세스는 원래 프로세스의 주소 공간의 복사본으로 구성된다.

이 기법은 부모 프로세스가 쉽게 자식 프로세스와 통신 할 수 있게 한다.

두 개의 프로세스(부모와 자식)은 fork() 후의 명령어에서부터 실행을 계속하며, 이때 한가지 다른 점은 fork() 의 복귀 코드가 다르다는것

자식프로레스의(0이아닌) 식별자가 부모로 복귀되는데 반해 새로운(자식) 프로세스는 0이 복귀된다.

fork()시스템 콜 다음에 두 프로세스 중 한 프로세스가 exec() 시스템 콜을 사용하여 자신의 메모리 공간을 새로운 프로그램으로 교체한다.

exec()시스템 콜은 이진 파일을 메모리로 적재(load)(이때 exec() 시스템 콜을 포함하는 원래의 프로그램의 메모리 이미지를 파괴) 그프로그램을 실행한다. 이와 같은 방법으로 두 프로세스는 통신할 수 있으며, 그들 각자의 길을 간다.

그후 부모는 자식을 더 생성하거나 자식이 실행하는 동안 할 일이 없으면 자식이 종료될때까지 준비 큐에서 자신을 제거하기 위해 wait()시스템 콜을 한다.

fork()는 현재 프로세스를 그대로 복제해서 새로운 프로세스를 생성하고,
exec()는 그 복제된 프로세스 위에 새로운 프로그램을 덮어쓰기 해서 실행하는 역할

## 3.3.2 프로세스 종료

프로세스가 마지막 문장의 실행을 끝내고 exit 시스템 콜을 사용하여 운영체제에 자신의 삭제를 요청하면 종료한다

이 시점에서 프로세스는 자신을 기다리고 있는 부모 프로세스에 (wait 시스템 콜을 통해) 상태 값(통상 정수값)을 반환할 수 있다. 프로세스의 모든 자원이 할당 해제되고 운영체제로 반납된다.

종료가 발생하는 또 다른 경우는 한 프로세스는 적당한 시스템콜을 통해서 다른 프로세스의 종료를 유발할 수 있다. (통상적으로 이런 시스템콜은 프로세스의 부모만이 호출할 수 있다.)

부모가 자식을 종료시키기 위해서는 자식의 PID를 알아야 한다. 그러므로 한 프로세스가 새로운 자식을 만들때 자식의 신원이 부모에게 전달된다.

부모가 자식을 종료하는 이유들

-   자식이 자신에게 할당된 자원을 초과하여 사용할때

    -   이때는 부모가 자식들의 상태를 검사할 수 있는 방편이 주어져야 한다.

-   자식에게 할당된 태스크가 더 이상 필요 없을 때

-   부모가 exit를 하는데 운영체제는 부모가 exit 한 후에 자식이 실행을 계속하는 것을 허용하지 않는 경우

몇몇 시스템에서는 부모 프로세스가 종료한 이후에 자식 프로세스가 존재할 수 없다.

그러한 시스템에서는 프로세스가 종료되면 그로부터 비롯된 모든 자식 프로세스들도 종료되어야 한다. `연쇄식 종료`라고 부르며 운영체제가 시행한다.

브로프로세스는 wait 시스템콜을 사용해서 자식 프로세스가 종료할 떄를 기다릴 수 있다.

wait 시스템 콜은 부모가 자식의 종료 상태를 얻어낼 수 있도록 하나의 인자를 전달받는다. 이 시스템 콜은 부모가 어느 자식이 종료되었는지 구별할 수 있도록 종료된 자식의 프로세스 식별자를 반환한다.

종료되었지만 부모 프로세스가 아직 wait() 호출을 하지 않은 프로세스를 `좀비`프로세스 라고 한다.

부모가 wait()를 호출하면 좀비 프로세스의 프로세스 식별자와 프로세스 테이블의 해당 항목이 운영체제에 반환된다.

부모 프로세스가 wait()를 호출하는 대신 종료한다면 자식 프로세스는 `고아`프로세스가 된다.

UNIX의 경우 새로운 부모프로세스로 init프로세스(루트)를 지정함으로써 이문제를 해결한다.

init 프로세스는 주기적으로 wait()를 호출하여 고아 프로세스의 종료 상태를 수집하고 프로세스 식별자와 프로세스 테이블 항목을 반환한다.

대부분의 Linux시스템은 init를 systemd로 대체했지만, 후자의 프로세스는 여전히 동일한 역할을 수행할 수 있지만 Linux는 systemd이외의 프로세스가 고아프로세스를 상속하고 종료를 관리하도록 허용한다.

# 배경
- 프로그램에는 잘 발생하지 않는 오류 상황을 처리하는 코드가 종종 존재한다. 이러한 오류들은 실질적으로 거의 발생하지 않으므로 이 코드들은 거의 실행되지 않는다.

- 배열, 리스트, 테이블 등은 필요 이상으로 많은 공간을 점유하는 수가 있다. 가령 배열이 실제로는 10 * 10 정도만 사용되는데오 100 * 100으로 선언될 수 있다.

- 프로그램 내의 어떤 옵션이나 기능들은 거의 사용되지 않는다. 전체 프로그램이 필요한 경우라도 그 프로그램의 모든 부분이 모두 동시에 요구되지 않을 수 있다.

만일 프로그램을 일부분만 메모리에 올려놓고 실행할 수 있다면 다음과 같은 많은 이점이 있다.,
- 프로그램은 물리 메모리 크기에 의해 더는 제약받지 않게 된다. 사용자들은 매우 큰 가상 주소 공간을 가정하고 프로그램을 만들 수 있으므로, 프로그래밍 작업이 간단해진다.

- 각 프로그램이 더 작은 메모리를 차지마흐로 더 많은 프로그램을 동시에 수행할 수 있게 된다. 이에 따라 응답시간은 늘어나지 않으면서도 CPU이용률과 처리율이 높아진다.

- 프로그램을 메모리에 올리고 스왑하는 데 필요한 I/O 횟수가 줄어들기 떄문에 프로그램들이 보다 빨리 실행된다.

따라서 프로그램의 일부만을 메모리에 올려놓고 실행하게 되면, 시스템과 사용자 모두에게 이득이 된다. 가상 메모리는 실제 물리 메모리 개념과 개발자의 논리 메모리 개념을 분리한 것

이렇게 함으로써 얻어지는 장점은 작은 메모리를 가지고도 얼마든지 큰 가상 주소 공간을 프로그래머에게 제공할 수 있다는 점이다.

한 프로세스의 가상 주소 공간은 그 프로세스가 메모리에 저장되는 논리적인 모습을 말한다.

물리 메모리는 페이지 프레임들로 구성되며 프로세스에 할당된 페이지 프레임들이 실제적으로는 연속적인 것들이 아닐 수 있다. 물리적인 페이지프레임을 논리적인 페이지로 사상하는 것은 메모리 관리 장치에 달린 것이다.

논리메모리를 물리 메모리로부터 분리해주는 것 외에 가상 메모리는 페이지 공유를 통해 파일이나 메모리가 둘 또는 그 이상의 프로세스들에 의해 공유되는 것을 가능하게 한다. 이는 다음과 같은 장점이 있다.
- 표준 C라이브러리와 같은 시스템 라이브러리가 여러 프로세스들에 공유될 수 있다. 각 프로세스는 라이브러리가 자신의 가상 주소 공간 일부라고 생각하지만, 실제로는 라이브러리가 존재하는 물리 메모리 페이지들은 모든 프로세스에 공유되고 있다. (읽기만이 허용 되는 상태)

- 마찬가지로, 프로세스들이 메모리를 공유할 수 있다. 둘 또는 그 이상의 프로세스가 공유 메모리를 통해 통신할 수 있다. 가상 메모리는 한 프로세스가 다른 프로세스와 공유할 수 있는 영역을 만들 수 있도록 해 준다. 이 영역을 공유하고 있는 프로세스들에는 각자 자신의 주소 공간상에 있는 것처럼 보이지만 실제 물리 메로리는 공유되고 있다.

- 페이지는 fork() 시스템 콜을 통해 프로세스 생성 과정 중에 공유될 수 있기 떄문에 프로세스 생성 속도를 높일 수 있다.


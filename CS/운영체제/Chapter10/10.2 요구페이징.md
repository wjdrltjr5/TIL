# 요구 페이징
필요한 페이지만 적재하는 것을 요구 페이징이라고 하며 가상 메모리 시스템에서 일반적으로 사용된다. 요구 페이징 가상 메모리를 사용하면 프로그램 실행 중 필요할 때만 페이지가 적재된다.

요구 페이징 가상 메모리를 사용하면 프로그램 실행 중 필요할 때만 페이지가 적재된다. 따라서 접근되지 않은 페이지는 물리 메모리로 적재되지 않는다. 

요구 페이징 시스템은 프로세스가 보조 메모리에 상주하는 스와핑을 사용하는 페이징 시스템과 유사하다. 요구 페이징은 가상 메모리의 주요 이점 중 하나를 설명한다. 필요한 프로그램의 일부만 적재하여 메모리가 더 효율적으로 사용된다.

## 10.2.1 기본 개념
프로세스가 실행되는 동안 일부 페이지는 메모리에 있고 일부는 보조저장장치에 있다. 따라서 이 둘을 구별하기 위해 어떤 형태로든 하드웨어 지원이 필요하다.

메모리에 올라오는 페이지에 대해서는 유효로 설정하며, 현재 메모리에 올라와 있지 않은 페이지의 페이지 테이블 항목은 무효로 설정하기만 한다.

프로세스가 메모리에 올라와있지 않은 페이지에 접근하려고 하면 무효상태이므로 페이지 폴트 트랩을 발생시킨다. 페이징 하드웨어는 페이지 테이블을 이용한 주소 변환 과정에서 무효 비트를 발견하고 운영체제에 트랩을 건다.

페이지 폴트를 처리하는 과정은 다음과 같다.
1. 프로세스에 대한 내부 테이블을 검사해서 그 메모리 참조가 유효한지 무효한지를 알아낸다.
2. 만약 무효한 페이지에 대한 참조라면 그 프로세스는 중단된다. 만약 유효한 참조인데 페이지가 아직 메모리에 올라오지 않았다면, 그것을 보조저장장치로부터 가져와야 한다.
3. 빈 공간, 즉 가용 프레임을 찾는다.
4. 보조저장장치에 새로이 할당된 프레임으로 해당 페이지를 읽어 들이도록 요청한다.
5. 보조저장장치 읽기가 끝나면, 이 페이지가 이제는 메모리에 있다는 것을 알리기 위해 페이지 테이블을 갱신하며, 프로세스가 유지하고 있는 내부 테이블을 수정한다.
6. 트랩에 의해 중단되었던 명령어를 다시 수행한다. 이제 프로세스는 마치 그 페이지가 항상 메모리에 있었던 것처럼 해당 페이지에 접근할 수 있다.

극단적인 경우 메모리에 페이지가 하나도 안올라와 있는 상태에서도 프로세스를 실행시킬 수 있다. 이 경우 요구 -> 폴트 -> 적재 -> 요구 -> 폴트 -> 적재 과정을 거친다 이것이 순수 요구 페이징이다. 어떤 페이지가 필요해지기 전에는 결코 그 페이지를 메모리로 적재하지 않는 방법이다.

프로그램들은 한 명령어에서도 여러 개의 페이지 폴트를 일으킬 수 있다. (명령문을 위한 한 페이지, 데이터마다 한페이지씩) 

이렇게되면 시스템의 성능 저하를 초래하지만 실행 중인 프로세스들은 분석해보면 이런 경우는 거의 없다. 모든 프로그램들은 참조 지역성이라는 성질이 있어서 프로그램의 어느 한 특정 작은 부분을 한동안 집정적으로 참조하기 때문에 요구 페이징은 만족할 만한 성능을 보인다.

요구 페이징을 지원하기 위해 필요한 하드웨어는 페이징과 스와핑을 위한 하드웨어와 동일하다.
- 페이지 테이블 : 보호비트와 특별한 값 또는 유효/무효 비트를 통해 특정 항목을 무효로 설정할 수 있어야 한다.
- 보조저장장치 : 메인 메모리에 없는 모든 페이지를 가지고 있다. 보통은 고성능의 디스크 또는 NVM장치이다. 이를 스왑 장치라고도 하며, 이 목적을 위해 사용하는 저장장치 영역을 스왑공간이라고 한다.

요구 페이징을 위한 필수적인 요구 사항은 페이지 폴트 오류 처리 후에 명령어 처리를 다시 시작할 수 있어야 한다는 것이다. 페이지 폴트가 발생하여 중단된 프로세스 상태를 보관해 두면, 다시 이 프로세스를 시작할 때 해당 페이지가 메모리로 올라와서 접근 가능하다는 것 외에는 정확히 같은 위치, 같은 상태에서 프로세스를 다시 수행할 수 있다.

대부분은 이 요구사항은 쉽게 만족한다. 어떤 기억 공간 참조시에도 페이지 폴트가 일어날 수 있다. 만약 페이지 폴트가 명령어 인출 시에 발생했다면 명령어를 메모리로 읽어 온 후 다시 수행을 시도하면 된다.

만약 오퍼랜드를 인출하는 동안에 페이지 폴트가 발생했다면 나중에 그 명령어를 다시 읽어오고 해독하여 오퍼랜드를 인출하면 된다.

최악의 경우로 A,B를 더하여 연산 결과를 C에 넣는 ADD와 같은 3-주소 명령어를 생각했을때 실행 단계는 다음과 같다.
1. 명령어(ADD)를 인출해서 해독한다.
2. A를 인출
3. B를 인출
4. A와 B를 더한다.
5. 합을 C에 저장한다.

여기서 결과를 C에 기억시키려 할 때 페이지 폴트가 발생하면 C가 속한 페이지를 메모리로 가져오고 페이지 테이블을 수정한 다음 그 명령어를 처음부터 다시 시작한다.

재시작 시 명령어 인출, 해독, A,B의 인출, 덧셈 연산 작업이 다시 수행된다. 반복 작업이 그렇게 많지는 않으며 페이지 폴트가 발생할 떄에만 필요하다.

페이징은 컴퓨터 시스템에서 CPU와 메모리 사이에 들어간다. 일반 프로그매러의 눈에는 전혀 드러나지 않기 때문에 어느 시스템에서나 페이징을 쉽게 추가할 수 있는 것으로 생각할 수 있다. 이는 페이지 폴트 오류가 심각한 오류인 요구 페이징이 없는 환경에서는 사실이지만, 페이지 폴트가 단순히 한 페이지를 메모리에 적재하고 다시 실행을 계속해야 하는 상황에서는 쉽지 않은 일이다.

## 10.2.2 가용 프레임 리스트
페이지 폴트가 발생하면 운영체제는 요청된 페이지를 보조저장장치에서 메인 메모리로 가져와야 한다. 페이지 폴트를 해결하기 위해 대부분의 운영체제는 이러한 요청을 충족시키기 위해 사용하기 위한 가용 프레임의 풀인 가용 프레임 리스트를 유지한다.

프로세스의 스택 또는 힙 세그먼트가 확장될 때도 가용 프레임이 할당되어야 한다. 운영체제는 일반적으로 zero-fill-on-demand라는 기법을 사용하여 가용 프레임을 할당한다.

Zero-fill-on-demand 프레임은 할당되기 전에 0으로 모두 채워져 이전 내용이 지워진다. 프레임을 다시 할당하기 전에 프레임의 내용을 지우지 않을경우 잠재적인 보안 취약점이 될 수도 있다.

시스템이 시작되면 모든 가용 메모리가 가용 프레임 리스트에 넣어진다 가용 프레임이 요청되면 가용 프레임 리스트의 크기가 줄어든다. 어떤 시점에서, 리스트의 크기는 0으로 떨어지거나 특정 임계값 밑으로 떨어지며 이 시점에서 다시 채워져야 한다.

## 10.2.3 요구 페이징의 성능
요구 페이징은 컴퓨터 시스템의 성능에 큰 영향을 줄 수 있다. 페이지 폴트가 없는 한 실질 접근 시간은 메모리 접근 시간과 같지만 페이지 폴트가 발생하면 먼저 보조저장장치에서 해당 페이지를 읽은 다음 원하는 워드에 접근해야 한다.

페이지 폴트는 다음과 같은 순서로 처리된다.
1. 운영체제에 트랩을 요청한다.
2. 레지스터들과 프로세스 상태를 저장한다.
3. 인터럽트 원인이 페이지 폴트임을 알아낸다.
4. 페이지 참조가 유효한 것인지 확인하고, 보조저장장치에 있는 페이지의 위치를 알아낸다.
5. 저장장치에 가용 프레임으로의 읽기 요구를 낸다.
    - 읽기 차례가 돌아오기까지 대기 큐에서 기다린다.
    - 디스크에서 찾는 시간과 회전 지연 시간 동안 기다린다.
    - 가용 프레임으로 페이지 전송을 시작한다.
6. 기다리는 동안에 CPU 코어는 다른 사용자에게 할당된다.
7. 저장장치가 다 읽었다고 인터럽트를 건다.
8. 다른 프로세스의 레지스터들과 프로세스 상태를 저장한다.
9. 인터럽트가 보조저장장치로부터 왔다는 것을 알아낸다.
10. 새 페이지가 메모리로 올라왔다는 것을 페이지 테이블과 다른 테이블들에 기록한다.
11. CPU코어가 자기 차례로 오기까지 다시 기다린다.
12. CPU 차례가 오면 위에서 잦ㅇ시켜 두었던 레지스터들, 프로세스 상태, 새로운 페이지 테이블을 복원시키고 인터럽트 되었던 명령어를 다시 실행한다.


따라서 성능을 위해서는 페이지 폴트율을 낮게 유지하는 것이 상당히 중요하다. 그렇지 않으면 실질 접근 시간이 커지고 프로세스 수행은 심각하게 느려진다.

요구 페이징의 또 다른 특성 중 하나는 스왑 공간의 관리이다. 스왑 공간에서의 디스크 I/O은 일반적으로 파일 시스템에서의 입출력보다 빠른데, 그 이유는 스왑 공간은 파일 시스템보다 더 큰 블록을 사용하기 때문이고 스왑 공간과 입출력을 할 때는 파일 찾기나 간접 할당 방법등은 사용하지 않기 때문이다.


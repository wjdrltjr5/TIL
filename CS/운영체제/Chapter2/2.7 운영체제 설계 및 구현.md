# 운영체제 설계 및 구현

## 2.7.1 설계 목표

시스템을 설계하는 데에 첫째 문제점은 시스템의 목표와 명세를 정의하는 일이다. 시스템 설계는 최상위 수준에서는 하드웨어와 시스템 유형(일괄처리, 시분할, 단일 사용자, 다중 사용자, 분산, 실시간 혹은, 범용)의 선택에 의해 영향을 받을 것이다.

최상쉬 설계 수준을 넘어서면 요구 조건들을 일일이 명시하는 것이 훨씬 어려워진다. 요구조건은 근본적으로 `사용자 목적`과 `시스템 목적`의 두 가지 기본 그룹으로 나눌 수 있다.

운영체제는 설계, 구현, 유지보수가 쉬워야 하며, 적응성, 신뢰성, 무오류, 효율성을 가져야 한다.

`소프트웨어 공학` 분약에 의해 개발된, 특별히 운영체제에 적용 가능한 일반적인 원칙들이 존재한다.

## 2.7.2 기법과 정책

중요한 원칙은 `기법`으로부터 `정책`을 분리하는 것

-   기법 : 어떤 일을 어떻게 할 것인가를 결정하는 것
    -   ex. 타이머 구조는 CPU를 보호하기 위한 기법
-   정책 : 무엇을 할 것인가를 결정하는 것
    -   ex. 특정 사용자를 위해 타이머를 얼마나 오랫동안 설정할지를 결정

정책과 기법의 분리는 융통성을 위해 아주 중요하다. 정책은 장소가 바뀌거나 시간이 흐름에 따라 변경될 수 있다.

마리크로 커널 기반 운영체제는, 프리미티브 빌딩 블록의 기본 집합을 구현합으로써 기법과 정책의 분리를 극단적으로 추구한다.

이 블록들은 정책으로부터 거의 자유로우며, 더 고급의 기법과 정책들이 사용자 생성 커널 모듈이나 사용자 프로그램 자체를 통해 첨가 될 수 있도록 한다.

Window의 경우에는 운영체제를 실행하는 모든 장치에서 전체적인 모양과 느낌을 통일하기 위해 기법과 정책이 밀접해지도록 인코딩하였다.

인터페이스 자체가 커널 및 시스템 라이브러리에 내장되어 있으므로 모든 응용프로그램의 인터페이스는 비슷하다. (Apple 도 비슷한 전략)

정책 결정은 모든 자원 할당 문제에 있어 중요하다. 자원의 할당 여부를 결정할 필요가 있을 때마다 정책 결정을 해야 한다. 질문이 `무엇`이 아니라 `어떻게`일때마다 반드시 결정되어야 하는 것은 기법이다.

## 2.7.3 구현

운영체제의 설계가 완료되면 구현되어야 한다. 초기 운영체제는 어셈블리 언어로 작성되었다. 이제는 대부분은 C또는 C++와 같은 고급 언어로 작성되며 극히 일부 시스템에 어셈블리 언어로 작성된다.

커널의 최하위 레벨은 어셈블리 언어 및 C로 작성될 수 있다. 상위 레벨 루틴은 C및 C++로 작성될 수 있으며 시스템 라이브러리는 C++또는 상위 레벨 언어로 작성될 수 있다.

안드로이드의 경우 커널은 약간의 어셈블리와 C로 작성되었고 대부분의 시스템 라이브러리는 C또는 C++ 시스템에 개발자 인터페이스를 제공하는 응용프로그램 프레임워크는 Java로 작성된다.

운영체제를 구현하기 위해 고급언어나 최소한 시스템 구현 언어를 사용함으로써 생기는 장점은 그 언어가 응용프로그램을 위해 사용될때 생기는 장점과 마찬가지이다.

-   코드를 빨리 작성 가능
-   간결하고 이해하기 쉽다
-   디버그하기도 쉽다.
-   컴파일러 기술의 향상은 재 컴파일에 의한 전체 운영체제를 위해 생성된 코드를 향상시킬것
-   다른 하드웨어로의 이식이 쉬움

단점으로는

-   속도가 드리고
-   저장장치가 많이 소요되는것

이 단점들은 현재의 시스템에서는 주된 문제가 아니다. 전문적인 어셈블리어 프로그래머는 효율적인 작은 루틴을 생산할 수 있지만 현대의 컴파일러는 대규모 프로그램을 위해 복잡한 분석을 수행하고 정교한 최적화를 적용하여 우수한 코드를 생산할 수 있다.

현재의 처리기는 깊은 파이프라이닝과 다수의 기능 장치를 가지며 인간이 할 수 있는 것보다 훨씬 쉽게 복잡한 의존성의 상세 사항들을 처리할 수 있다.

`다른 시스템에서도 알려진 사실이지만 운영체제의 주요 성능 향상은 우수한 어셈블리어 코드보다는 좋은 자료구조와 알고리즘의 결과일 가능성이 크다`

운영체제가 크긴 하지만, 단시 소량의 코드만이 고성능이 중요하다. (인터럽트 핸들러, 입출력 관리자, 메모리 관리자와 CPU 스케줄러가 가장 긴급한 루틴)

시스템이 개발되고 올바르게 작동된 후 병목 지점을 식별하고 보다 효율적으로 작동하도록 재 구성할 수 있다.

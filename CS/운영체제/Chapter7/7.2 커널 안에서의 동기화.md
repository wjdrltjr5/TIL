# 커널 안에서의 동기화

## 7.2.1 Windows의 동기화

Windows 운영체제는 실시간 응용과 다중 처리기 지원을 제공하는 다중 스레드 커널이다.

Windows 커널이 단일 처리기에서 전역 정보를 액세스할 때에는 동일한 전역 정보를 액세스할 가능성이 있는 인터럽트 핸들러가 실행되지 않도록, 인터럽트를 잠시동안 못걸리게 막는다.

다중 처리기 시스템에서는 Windows는 스핀락을 써서 전역 정보 액세스를 통제한다.

windows 커널은 짧은 코드에 대해서만 스핀락을 사용한다. 게다가 효율성을 위해서 스레드가 스핀락을 가지고 있는 동안에는 선점되지 않도록 보장한다.

커널 외부에서 스레드를 동기화하기 위하여 `dispatcher` 객체를 제공한다. 스레드는 dispatcher 객체를 사용하여 mutex락, 세마포, event 및 타이머를 포함한 다양한 기법에 맞추어 동기화할 수 있다.

`event`는 조건 변수와 유사하다. 기다리는 조건이 만족하면 기다리고 있는 스레드에 통지해 줄 수 있다. 타이머는 지정한 시간이 만료되면 하나(또는 둘 이상의)스레드에 통지하는 데 사용된다.

Dispatcher 객체는 signaled 상태에 있을 수도 있고 nonsignaled 상태에 있을 수 도 있다.

`signaled 상태`는 객체가 사용 가능하고 그 객체를 얻을 때 그 스레드가 봉쇄되지 않음을 뜻한다.

`NonSignaled 상태`는 객체가 사용할 수 없고 그 객체를 얻으려고 시도하면 그 스레드가 봉쇄됨을 뜻한다.

Dispatcher 객체의 상태와 스레드 상태 간에는 연관성이 있다. 스레드가 nonsignaled 상태에 있는 dispatcher 객체 때문에 봉쇄되면 그 스레드의 상태는 준비로부터 대기 상태로 바뀌고 그 스레드는 그 객체의 대기 큐에 넣어지게 된다.

추후 dispatcher 객체의 상태가 signaled 상태로 바뀌면 커널은 그 객체를 기다리는 스레드가 있는지 여부를 알아내어 있으면 그 하나의 스레드(가능하다면 여러 스레드)를 대기 상태로부터 준비 상태로 바꾸어 다시 실행을 재개할 수 있도록 조치한다.

커널이 대기 큐로부터 선택하는 스레드의 개수는 각 스레드가 기다리고 있는 dispatcher 객체의 유형에 달려있다. (mutex는 한개만 가능, Event객체의경우 이벤트를 기다리는 모든 스레드 선택)

`Critical-section 객체`는 커널의 개입 없이 획득하거나 방출할 수 있는 사용자 모드 mutex이다.

다중 처리기 시스템에서 critical-section 객체는 처음에는 스핀락을 사용하여 다른 스레드가 객체를 방출하기를 기다린다. 회전이 길어지게 되면 락을 획득하려는 프로세스는 커널 mutex를 할당하고 CPU를 양도한다.

Critical-section 객체는 커널 mutex는 객체에 대한 경쟁이 발생할 때만 할당되기 때문에 특히 효율적이다. 실제로는 경쟁은 거의 발생하지 않기 때문에 CPU 절약은 상당히 좋아진다.

## 7.2.2 Linux의 동기화

버전 2.6 이전 Linux는 비선점형 커널이었다. 즉 커널 모드에서 실행 중인 프로세스는 더 높은 우선순위의 프로세스가 실행 가능한 상태가 되더라도 선점될 수 없었다.

그러나 지금의 Linux 커널은 완전히 선점 가능하며, 따라서 커널 모드에서 실행 중일 때도 태스크는 선점될 수 있다.

대부분의 컴퓨터 구조가 간단한 수학 연산의 원자적 버전을 제공하기 때문에 Linux 커널안에서의 가장 간단한 동기화 기법은 원자적 정수이다.

이러한 정수는 차단된 데이터 형인 atomic_t 데이터 형을 사용하여 표현된다. 원자적 정수를 사용하는 모든 수학 연산은 중단됨 없이 수행된다.

```c
atomic_t counter;
int value;
```

| Atomic Operation               | Effect                |
| ------------------------------ | --------------------- |
| atomic_set(&counter, 5);       | counter = 5           |
| atomic_add(10, &counter);      | counter = counter + 5 |
| atomic_sub(4, &counter);       | counter = counter - 4 |
| atomic_inc(&counter);          | counter = counter + 1 |
| value = atomic_read(&counter); | value = 12            |

원자적 정수는 counter 와 같은 정수형 변수가 갱신되어야 하는 상황에서 특히 효율적이다. 원자적 연산을 락 기법을 사용할 떄의 오버헤드가 필요 없기 때문.

하지만 발생 가능성이 있는 경쟁 조건에 기여하는 많은 변수가 존재하는 경우에는 더 정교한 락킹 도구가 사용되어야 한다.

Linux에서 커널 안의 임계구역을 보호하기 위해 mutex 락이 제공된다. 여기서 태스크는 임계구역에 들어가기 전에 mutex_lock()함수를 호출해야 하고 나오기 전에 mutex_unlock() 함수를 호출해야 한다.

mutex락을 획득할 수 없다면 mutex_lock()을 호출한 함수는 수면 상태에 놓이고 락의 소유자가 mutex_unlock()을 호출할 때 깨어나게 된다.

커널 안에서의 라킹을 위하여 스핀락과 세마포 및 두 락의 read_writer 버전도 제공한다.

SMP 기계에서는 기본적인 락킹 기법은 스핀락이다. 스핀락이 단지 짧은 시간동안만 소유되도록 커널이 설계되었다.

하나의 처리 코어를 가지고 있는 임베디드 시스템과 같은 단일 처리기에서는 스핀락을 사용하는 것은 부적합하므로 커널 선점을 가능하게 하고 불가능하게 하는 것으로 대치된다.

-   단일 처리기 : 커널 선점을 가능케한다 / 불능케 한다.
-   다중 처리기 : 스핀락을 획득한다 / 방출한다.

Linux 커널에서 스핀락과 Mutex 락은 재귀적이지 않다. 즉 스레드가 이러한 락중 하나를 획득했다면 획득한 락을 해제하지 않고는 같은 락을 다시 획득할 수 없다. 해제하지 않으면 락을 획득하려는 두번째 시도는 봉쇄된다.

Linux는 커널 선점을 불능케 하고 가능케 하는데 항미로운 방식을 사용한다.

Linux는 preempt_disable()과 preempt_enable() 이라는 두 개의 간단한 시스템 콜을 제공한다.

커널에서 실행 중인 태스크가 락을 소유하고 있으면 커널은 선점 가능하지 않다.

이를 강제하기 위하여 시스템의 각 스레드는 thread_info 구조체를 가지고 있고 이 구조체에는 태스크가 소유하고 있는 락의 개수를 나타내는 preempt_count라는 카운터 필드가 있다.

락을 획특하면 증가하고 방출되면 이 필드는 감소한다. 현재 수행 중인 태스크의 preempt_count의 값이 0 보다 크면 커널을 선점하는 것은 안전하지 않다. (태스크가 락을 소유하고 있기 때문)

카운트가 0이고 대기 중인 preempt_disable() 호출이 없다고 가정하면 커널은 안전하게 인터럽트 될 수 있다.

스핀락과 커널 선점 불능 및 가능은 오직 락(또는 커널 선점 불가능)이 짧은 시간 동안만 유지될 때 사용된다. 락이 오랜 시간동안 유지되어야 한다면 세마포 또는 mutex락을 사용하는 것이 적절하다.

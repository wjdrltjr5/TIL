`# 1.2 컴퓨터 시스템의 구성

현대의 범용 컴퓨터 시스템은 하나 이상의 CPU와 구성요소와 공유 메모리 상의 액세스를 제공하는 `버스`를 통해 연결된 여러 장치 컨트롤러로 구성된다

각 장치 컨트롤러는 특정 유형의 장치가 담당한다.(디스크드라이브, 오디오장치, 그래픽 디스크플레이 등)

각 장치 컨트롤러는 일부 로컬 버퍼 저장소와 특수 목적 레지스터 집합을 유지 관리한다. 장치 컨트롤러는 제어하는 주변 장치와 로컬 버퍼 저장소 간에 데이터를 이동한아.

운영체제에는 각 장비 컨트롤러마다 `장치 드라이버`가 있다. 드라이버는 장치 컨트롤러의 작동을 잘 알고 있고 나머지 운영체제에 장치에 대한 일관된 인터페이스를 제공한다.

CPU와 장치 컨트롤러는 병렬로 실행되어 메모리 사이클을 놓고 경쟁한다. 공유메모리를 질서 있게 액세스하기 위해 메모리 컨트롤러는 메모리에 대한 액세스를 동기화한다.

## 1.2.1 인터럽트

입출력 작업의 과정

-   장치 드라이버는 장치 컨트롤러의 적절한 레지스터에 값을 적재한다.
-   장치 컨터롤로는 레지스터 내용을 검사하여 수행할 작업을 결정한다(ex. 키보드에서 문자 읽기)
-   컨트롤러는 장치에서 로컬 버퍼로 데이터 전송을 시작한다.
-   데이터 전송이 완료되면 장치 컨트롤러는 장치에서 로컬 버퍼로 데이터 전송을 시작한다.
-   `데이터 전송이 완료되면 장치 컨트롤러는 장치 드라이버에게 작업이 완료되었음을 알린다.` (인터럽트가 알림)
-   장치드라이버는 읽기 요청이면 데이터 또는 데이터에 대한 포인터를 반환하며 운영체제의 다른 부분에 제어를 넘긴다.
-   다른 작업의 경우 장치 드라이버는 쓰리 완료 또는 장치 사용중 과 같은 상태 정보를 반환한다.

`컨트롤러가 장치 드라이버에게 작업을 완료했다는 사실은 인터럽트를 통해 이뤄진다.`

### 1.2.1.1 개요

하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있다.

인터럽트는 다른 목적으로도 많이 사용되며 운영체제와 하드웨어의 상호 작용 방식의 핵심 부분이다.

CPU가 인터럽트 되면, 하던일을 중단하고 즉시 고정된 위치로 실행을 옮긴다.

고정된 위치는 일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작 주소를 가지도 있다 그리고 인터럽트 서비스 루틴이 실행된다.

인터럽트 서비스 루틴의 실행이 완료되면, CPU는 인터럽트 되었던 연산을 재개한다.

-   입출력 요청
-   전송완료
-   인터럽트 보내짐
-   인터럽트 처리됨

인터럽트는 매우 빈번하게 발생되기 때문에 빠르게 처리되어야 한다. 필요한 속도를 제공하기 위해 인터럽트 루틴에 대한 포인터들의 테이블을 대신 이용할 수 있다.

이 경우 중간 루틴을 둘 필요 없이, 테이블을 통하여 간접적으로 인터럽트 루틴이 호출될 수 있다.

일반적으로 포인터들은 테이블의 하위 메모리에 저장되며 이들 위치에는 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 들어있다.

`인터럽트가 요청되면 인터럽트를 유발한 장치를 위한 입터럽트 서비스 루틴의 주소를 제공하기 위해 이 주소의 배열 즉 인터럽트 벡터가` 인터럽트 요청과 함께 주어진 고유의 유일한 장치 번호로 색인된다.

### 1.2.1.2 구현

기본 인터럽트 메커니즘

CPU 하드웨어에는 `인터럽트 요청 라인`이라는 선이 있는데 이는 하나의 명령어 실행을 완료할때마다 CPU가 이선을 감지한다.

CPU는 컨트롤러가 인터럽트 요청 라인에 신호를 보낸것을 감지하면, 인터럽트 번호를 읽고 이 번호를 인터럽트 벡터의 인덱스로 사용하여 `인터럽트 핸들러 루틴`으로 점프한다.

그런 다음 해당 인덱스와 관련된 주소에서 실행을 시작한다.

인터럽트 처리기는 작업 중에 변경될 상태를 저장하고, 인터럽트 원인을 확인하고, 필요한 처리를 수행하고, 상태 복원을 수행하고, return_from_interrupt 명령어를 실행하여 CPU를 인터럽트 전 실행 상태로 되돌린다.

`장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언하여 인터럽트를 발생시키고 CPU는 인터럽트를 포착하여 인터럽트 핸들러로 디스패치하고 핸들러는 장치를 서비스하여 인터럽트를 지운다.`

입출력 사이클

1. (CPU) 장치 드라이버 입출력 개시
2. (I/O 컨트롤러) 입출력 개시
3. (I/O 컨트롤러)입력 준비 완료, 출력 완료, 혹은 에러시 인터럽트 신호를 발생
4. (CPU)CPU는 인터럽트를 전달받으면 제어를 인터럽트 핸들러에게 넘김
5. (CPU)인터럽트 핸들러가 데이터를 처리하고 인터럽트에서 복귀
6. (CPU)CPU는 인터럽트로 중단된 작업의 처리를 재개함

디스패치 ： 인터럽트를 처리하기 위해 CPU가 인터럽트 핸들러로 분기(jump)하는 과정

최신 운영체제에서는 더욱 정교한 처리기능이 필요

-   중요한 처리중에 인터럽트 처리를 연기할 수 있어야 한다
-   정치의 적절한 인터럽트 핸들러로 효율적인 디스패치 할 방법이 필요하다
-   운영체제가 우선순위가 높은 인터럽트와 낮은 인터럽으를 구분하고 적절한 긴급도로 대응할 수 있도록 다단계 인터럽트가 필요하다.

최신 하드웨어에서 위 세가지 기능은 CPU 및 인터럽트 컨트롤러 하드웨어에 의해 제공된다.

대부분의 CPU 2가지 인터럽트 요청라인

-   마스크 불가능 인터럽트 : 복구할 수 없는 메모리 오류와 같은 이벤트를 위해 예약
-   마스킹 가능 : 인터럽트 되어서는 안되는 중요한 명령 시퀀스를 실행하기전에 CPU에 꺼질 수 있음
    -   장치 컨트롤러가 서비스를 요청하기 위해 사용

`벡터 방식 인터럽트 기법의 목적은 서비스가 필요한 장치를 결정하기 위해 하나의 인터럽트 핸들러가 가능한 모든 인터럽트 소스를 검색할 필요를 줄이기 위한 것을 상기 `

실제로는 인터럽트 벡터의 주소 개수보다 더 많은 장치(따라서 인터럽트 처리기)가 있다 해결하는 일반적인 방법은 `인터럽트 체인`을 사용하는 것

인터럽트 기법은 또한 인터럽트 `우선순위 레벨`을 구한현다. 이를 가지고 CPU 는 모든 인터럽트를 마스킹 하지 않고도 우선순위가 낮은 인터럽트 처리를 연기할 수 있고 우선순위가 높은 인터럽트가 낮은 인터럽트 실행을 선점할 수 있다.

```
-- 요약
인터럽트는 최신 운영체제에서 비동기 이벤트를 처리하기 위해 사용
장치 컨트롤러 및 하드웨어 오류로 인해 인터럽트 발생
긴급한 작업의 수행을 위해 최신 컴퓨터는 인터럽트 우선순쉬 시스템사용
민감한 처리에 빈번하게 사용되므로 성능을 좋게 하려면 효율적인 처리가 필요
```

### 1.2.2 저장장치 구조

CPU는 메모리에서만 명령을 적재할 수 있으므로 프로그램을 먼저 메인메모리(RAM)에서 가져온다. (DRAM 이라 불리는 반도체 기술로 구성된다.)

다른 형태의 메모리도 사용한다. 전원을 켤 때 가장 먼저 실행되는 프로그램은 `부트스트랩 프로그램`이며 운영체제를 적재한다.

RAM은 `휘발성`이므로 부트스트랩 프로그램 유지 용도로 사용할 수 없다. 컴퓨터는 전지적으로 소거가능한 읽기 전용 메모리(EEPROM) 및 기타 형태의 `펌웨어(쓰기 작업이 자주 발생하지 않고 비휘발성 저장장치)`를 사용한다.

EEPROM : 변경은 가능하지만 자주 변경할 수 없다, 속도가 느리므로 주로 사용되지 않는 정적프로그램과 데이터가 포함됨

상호작용은 특정 메모리 주소들에 대한 적재 또는 저장명령을 통해서 이뤄진다.

-   적재 : 메인 메모리로부터 CPU 내부의 레지스터로 한바이트 또는 한 워드를 옮기는 것
-   저장 : 레지스트의 내용을 메인 메모리로 옮긴다.

CPU는 프로그램 카운터에 저장된 위치부터 실행하기 위해 메인 메모리에서 명령을 자동으로 적재한다.

`폰 노이만 구조 시스템에서는 명령 - 실행 사이클은 메모리로부터 명령을 인출해 명령 레지스터에 저장한다.`

-   메인메모리는 모든 필요 프로그램과 데이터를 영구저장하기에는 너무 작다
-   휘발성이다.

그러므로 `보조저장장치를 제공한다` (HDD, SDD, NVM(비휘발성메모리))등 비휘발성

-   기계적 저장장치 : HDD, 광디스크, 홀로그램 저장 장치 및 자기 테이프
-   전지적 저장장치(NVM) : 플래시 메모리, FRAM, NRAM, SSD

### 1.2.3 입출력 구조

운영체제 코드의 상당 부분은 시스템의 안정성과 성능에 대한 중요성과 장치의 다양한 특성으로 인해 I/O 관리에 할애된다.

인터럽트 구동I/O의 형태는 소량의 데이터를 이동하는 데는 좋지만 NVS I/O 와 같은 대량 데이터 이동에 사용시 높은 오버헤드를 유발할 수 있다.

NVS I/O : 전원이 꺼져도 유지되는 저장장치(SSD, Flash 등)에서의 입출력 작업

이 문제를 해결하기 위해 `직접 메모리 액세스(DMA)`가 사용된다. 장치에 대한 버퍼 및 포인터, 입출력 카운트를 세팅한 후 장치 제어기는 CPU의 개입 없이 메모리로부터 자신의 버퍼 장치로 또는 버퍼로부터 메모리로 데이터 블록 전체를 전송한다.

바이트마다 인터럽트가 아니라 데이터 블록 전송이 완료될 때마다 인터럽트가 발생한다.

장치 컨트롤러가 전송작업 수행동안 CPU는 다른작업을 수행할 수 있다.

몇몇 고가의 시스템은 버스 대신에 스위치 구조를 사용한다. 공유버스를 사용하기 위한 사이클을 경쟁하지 않고 다수의 구성요소가 다른 구성요소들간에 통신이 가능(이경우 DMA는 더욱 효과적)

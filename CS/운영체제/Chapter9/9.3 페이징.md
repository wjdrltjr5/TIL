# 페이징
지금까지 논의된 메모리 관리는 프로세스의 물리 주소 공간이 연속적이여야 했지만 페이징은 프로세스의 물리 주소 공간이 연속되지 않아도 되는 메모리 관리기법이다.

페이징은 연속 메모리 할당을 괴롭히는 두 가지 문에진 외부 단편화와 관련 압축의 필요성을 피한다. 많은 이점을 제공하기 때문에 대형 서버용 시스템에서 모바일 장치용 시스템에 이르기까지 대부분의 운영체제에서 다양한 형태의 페이징이 사용된다.

페이징은 운영체제와 컴퓨터 하드웨어 간의 협력을 통해 구현된다.

## 9.3.1 기본 방법
물리 메모리는 프레임이라 불리는 같은 크기 블록으로 나누어진다. 논리 메모리는 `페이지`라 불리는 같은 크기의 블록으로 나누어진다.

프로세스가 실행될 때 그 프로세스의 페이지는 파일 시스템 또는 예비 저장장치로부터 가용한 메인 메모리 프레임으로 적재된다.

예비 저장장치는 메모리 프레임 혹은 프레임의 묶음인 클러스터와 동일한 크기의 고정 크기 블록으로 나누어진다. 이러한 방식이 엄청난 기능을 수행하고 폭넓은 영향을 끼쳤다. (논리 주소 공간이 물리 주소 공간으로부터 완전히 분리)

CPU에서 나오는 모든 주소는 페이지 번호(p)와 페이지 오프셋(d: offset) 두개의 부분으로 나누어진다. 페이지 번호는 프로세스 페이지 테이블을 액세스할 때 사용된다. 

페이지 테이블은 물리 메모리의 각 프레임의 시작 주소를 저장하고 있으며 오프셋은 참조되는 프레임 안에서의 위치이다. 따라서 프레임의 시작 주소와 페이지 오프셋이 결합하여 물리 메모리 주소가된다.

CPU에 의해 생성된 논리 주소를 물리 주소로 변환하기 위해 MMU가 취한 단계 요약
- 페이지 번호 p를 추출하여 페이지 테이블의 인덱스로 사용한다.
- 페이지 테이블에서 해당 프레임 번호 f를 추출한다.
- 논리 주소의 페이지 번호 p를 프레임 번호 f로 바꾼다.

오프셋 d는 변하지 않기 때문에 대체되지 않으며, 프레임 번호와 오프셋은 물리 주소를 구성한다. 프레임 크기와 마찬가지로 페이지 크기는 하드웨어에 의해 정해진다. 페이지 크기는 2의 거듭제곱으로 일반적으로 컴퓨터 아키텍처에 따라 페이지당 4kb와 1gb사이이다. (크기를 2의 거듭제곱으로 하는 이유는 논리 주소를 페이지 번호 및 오프셋으로 쉽게 변환할 수 있기 때문)

페이징 자체는 일종의 동적 재배치이다. 모든 논리 주소는 페이징 하드웨어에 의해 실제 주소로 바인딩된다. 페이징을 사용하는 것은 각 메모리 프레임마다 하나씩 기준(또는 재배치) 레지스터를 테이블로 유지하는 것과 유사하다.

페이징 기법을 사용하면 외부 단편화가 발생하지 않는다. 모든 놀고 있는 프레임이 프로세스에 할당될 수 있기 때문이다. 그러나 이제는 내부 단편화가 발생한다. (할당은 항상 프레임의 정수배로 할당되기 때문)

만약 프로세스가 페이지 경계와 일치하지 않는 크기의 메모리를 요구한다면, 마지막 페이지 프레임은 전부 할당되지 않는다.

프로세스의 크기가 페이지 크기와 무관하다면 평균적으로 프로세스당 반 페이지 정도의 내부 단편화가 예상된다 이런 측면에서는 작은 페이지 크기가 바람직하다는 것을 알 수 있지만 그에 반비례하여 페이지 테이블의 크기가 커지게 되고 이 테이블이 차지하는 공간은 낭비된다.

디스크의 입장에서는 페이지의 크기가 클수록 효율적이다. 일반적인 추세는 페이지 크기가 프로세스, 자료, 그리고 메인 메모리가 커짐에 따라 함께 커져왔다.

한 프로세스가 실행되기 위해 도착하면 그 프로세스의 크기가 페이지 몇 개 분에 해당하는 가를 조사한다. 각 사용자 페이지는 한 프레임씩 필요하다. 즉 프로세스가 n개의 페이지를 요구하면 메모리에서 이용할 수 있는 프레임이 n개 있어야 한다.

n개의 프레임을 사용할 수 있다면 이 프레임들은 이 프로세스에 할당된다. 그리고는 프로세스의 처음 페이지가 할당된 프레임 중 하나에 적재되고, 그 프레임 번호가 페이지 테이블에 기록된다.

페이징의 가장 중요한 특징은 메모리에 대한 프로그래머의 인식과 실제 내용이 서로 다르다는 것이다. 프로그래머는 메모리가 하나의 연속적인 공간이며, 메모리에는 이 프로그램만 있다고 생각하지만 실제로는 프로그램은 여러 곳에 프레임 단위로 분산되어 있고, 많은 다른 프로그램이 올라와 있다.

프로그래머가 생각하는 메모리와 실제 물리 메모리의 차이는 주소 변환 하드웨어에 의해 해소된다. 논리 주소는 물리 주소로 변환된다. 이 사상은 운영체제에 의해 조성된다. 따라서 사용자 프로세스는 자기의 것이 아닌 메모리는 접근조차 할 수 없다.

페이지 테이블을 통하지 않고서는 다른 공간에 접근할 길이 없으며 페이지 테이블은 그 프로세스가 소유하고 있는 페이지들만을 가리키고 있기 때문이다.

운영체제ㅐ는 물리 메모리를 관리하기 떄문에 물리 메모리의 자세한 할당에 대해 파악하고 있어야 한다. 어느 프레임이 할당되어 있고 어느 프레임이 사용가능한지 총 프레임은 몇 개나 되는지 등을 알아야 한다.

이런 정보는 일반적으로 프레임 테이블이라는 시스템에 하나밖에 없는 자료구조에 있다. 프레임 테이블은 각 프레임당 하나의 항목을 가지고 있으며, 프레임이 비어 있는지, 할당되었는지, 그리고 할당되었다면 어느 프로세스의 어느 페이지에 할당되었는지를 나타낸다.

운영체제는 모든 프로세스의 주소들을 실제 주소로 사상할 수 있어야 한다. 만약 사용자가 시스템 콜을 호출하여 인자로 어떤 주소를 주면, 제대로 사상하여 정확히 그 물리 주소를 찾아가야 한다.

프로세스가 CPU에 할당될 때 CPU 디스패처가 하드웨어 디스패처 테이블을 설정하는 데 사용된다 따라서 페이징은 문맥 교환 시간을 늘린다.

## 9.3.2 하드웨어 지원
페이지 테이블은 프로세스별 자료구조이므로 페이지 테이블에 대한 포인터는 각 프로세스의 프로세스 제어 블록에 다른 레지스터값과 함께 저장된다.

CPU 스케줄러가 실행할 프로세스를 선택하면 사용자 레지스터를 다시 적재하고 저장된 사용자 페이지 테이블로부터 적절한 하드웨어 페이지 테이블 값을 다시 적재해야 한다.

대부분의 컴퓨터는 페이지 테이블을 메인 메모리에 저장하고 페이지 테이블 기준 레지스터로 하여금 페이지 테이블을 가리키도록 한다. 다른 페이지 테이블을 사용하려면 단이 이 레지스터만을 변화시키면 되고, 따라서 문맥 교환 시간을 줄일 수 있다.

### 9.3.2.1 Translation Look-Aside Buffer(TLB)
메인 메모리에 페이지 테이블을 저장하면 문맥 교환 속도가 빨라지지만 메모리 액세스 시간이 느려질 수도 있다. 

메모리 i에 액세스 하려고 할때 먼저 페이지 번호를 기준으로 PTBR 오프셋의 값을 사용해서 페이지 테이블의 항목을 찾는다. 이 작업에는 한 번의 메모리 액세스가 필요하다.

이렇게 얻은 프레임 번호와 페이지 오프셋을 결합하여 실제 주소를 생성한다. 그런 다음 메모리에서 원하는 위치에 액세스 할 수 있다. 이 기법을 사용하면 데이터에 액세스하려면 두 번의 메모리 액세스가 필요하다.

따라서 메모리 접근 시간은 2배로 느려지고 이는 대부분의 상황에서 허용할 수 없는 지연시간이다. 해당 문제에 대한 해결에는 TLB라고 불리는 특수한 소형 하드웨어 캐시가 사용된다.

TLB는 매우 빠른 연관 메모리로 구성된다. TBL내 각 항목은 키와 값의 두부분으로 구성된다. TLB에 페이지를 찾아달라고 요청이 들어오면 이 찾고자 하는 페이지를 동시에 여러 개의 키와 비교한다. 페이지 번호와 같은 것이 발견되면 그에 대응하는 프레임 번호를 알려준다.


TBL는 페이지 테이블의 일부분만을 저장한다. CPU가 논리 주소를 생성하면 MMU는 해당 페이지 번호가 TLB에 있는지 확인한다. 있다면 프레임 번호를 바로 알 수 있고 메모리를 접근하는데 사용된다.

페이지 번호가 TLB에 없으면 주소 변환은 기본 방식으로 진행되며 페이지 테이블에 대한 메모리 참조가 이루어 져야 한다. 그런다음 찾은 정보를 TLB에 저장한다. (이거 그냥 진짜 캐시네)

만약 TLB가 가득 차면 기존 항목 중에서 교체될 항목을 선택해야 한다. 교체 적책은 LRU부터 라운드 로빈, 무작위 등 다양한 정책이 사용된다.

## 9.3.3 보호
페이징 환경에서 메모리 보호는 각 페이지에 붙어있는 보호 비트에 의해 구현된다. 이 비트들은 보통 페이지 테이블에 속해있다.

각 비트는 이 페잊가 읽고,쓰기 또는 읽기 전용임을 각각 정의할 수 있다. 메모리에 대한 모든 접근은 페이지 테이블을 거치므로 이때 주소 변환과 함께 쓰기가 허용되는지 안되는지와 같은 검사도 할 수가 있다.

읽기 전용에 쓰기를 시도하면 운영체제가 하드웨어로 트랩을 걸어준다.

페이지 테이블의 각 엔트리에는 유효/무효 라는 하나의 비트가 더 있다. 이 비트가 유효로 설정되면 관련된 페이지가 프로세스의 합법적인 페이지임을 나타내며, 이 비트가 무효로 설정되면 그 페이지는 프로세스의 논리 주소 공간에 속하지 않는다는 것을 나타낸다.

운영체제는 이 비트를 이용해서 그 페이지에 대한 접근을 허용하던지 또는 허용하지 않든지 할 수 있다. 프로세스가 자신의 모든 주소 범위를 늘 사용하는경우는 드물다. 많은 프로세스는 일정한 시각에는 단지 일부분만을 집중적으로 사용한다. 

이런 경우에 모든 페이지에 페이지 테이블 항목을 배정하는 것은 낭비일 것이다. 몇몇 시스템은 페이지 테이블의 크기를 나타내기 위해 페이지 테이블 길이 레지스터라는 레지스터를 제공한다.

프로세스가 제시한 주소가 유효한 범위 내에 있는지를 확인하기 위해 모든 논리 주소 값이 PTLR값과 비교된다. 이러한 검사에서 오류가 나타나면 트랩을 발생시킨다.

## 9.3.4 공유 페이지
페이지의 장점은 공통의 코드르 공유할 수 있다는 점이다. 여러 프로세스가 있는 환경에서 특히 중요하게 고려해야 할 점이다. 

재진입 코드인 경우 공유할 수 있다. 재진입 코드는 자체 수정을 할 수 없는 코드로서 실행 중이에는 절대 변경되지 않는다. 따라서 두 개 이상의 프로세스가 동일한 코드를 동시에 실행할 수 있다.

각 프로세스는 자신의 실행을 위해 데이터를 보유하기 위한 자체 레지스터 사본과 데이터 저장영역이 있다. 물론 두 프로세스가 가진 데이터는 서로 다를 수 있다. 표준 C라이브러리는 물리 메모리에 하나의 사본만 저장하면 되고, 각 사용자 프로세스의 페이지 테이블은 동일한 물리적 사본으로 매핑시킨다.

따라서 여러개의 프로세스를 지원하려면 라이브러리 사본이 하나만 필요하며 크게 절약할 수 있다.

libc와 같은 실행 시간 라이브버리 외에도 컴파일러, 윈도 시스템, 데이터베이스 시스템 등과 같이 많이 사용되는 다른 프로그램도 공유할 수 있다.

공유 라이브러리는 일반적으로 공유 페이지로 구현된다. 공유가 가능하게 하려면 재진입 코드로 구현되어야 한다. 공유 코드의 읽기 전용 특성을 지키는 것을 코드의 정확성에만 의존해서는 안된다. 운영체제가 이속성을 강제해야 한다.

시스템에서 프로세스들 사이의 메모리 공유는 스레드에서의 주소 공간 공유와 유사하다. 프로세스간의 상호 통신의 방법으로 메모리 공유가 사용된다. 어떤 운영체제는 메모리공유를 페이지 공유를 통해 구현하기도 한다.

페이지를 통한 메모리 관리는 같은 물리 페이지 프레임을 여러 프로세스가 공유한다는 것뿐만 아니라 다양한 이익을 가져다 준다.
# 페이지 테이블의 구조

현대의 컴퓨터 구조에서 모든 페이지 테이블을 메인 메모리에 연속적으로 할당기에는 용량에 부담이 있다.

## 9.4.1 계층적 페이징
-  한 가지 방법은 페이지 테이블을 여러 개의 작은 조각으로 나누는 것
    - 2단계 페이징 기법 : 페이지 테이블 자체가 다시 페이징되게 하는 방법 이 방식에서는 주소 변환이 바깥 페이지 테이블에서 시작하여 안쪽으로 들어오므로 이 방식을 forward-mapped페이지 테이블이라고도 부른다.
    
64비트 논리 주소 공간을 가진 시스템에서는 2단계 페이징 기법도 적절하지 못하다. 3단계나 뭐 4단계 페이징 등등을 적용하더로 논리 주소를 사상하기 위해 너무 많은 메모리 접근을 필요로 하기 때문에 비현식적이다.

결론적으로 64비트 구조에서는 계층적 페이지 테이블이 부적합하다.

## 9.4.2 해시 페이지 테이블
주소공간이 32비트보다 커지면 가상 주소를 해시로 사용하는 해시 페이지 테이블을 많이 쓴다. 해시 페이지 테이블의 각 항목은 연결 리스트를 가지고 있다.

연결리스트에는 충돌을 일으켜서 모두 이곳으로 해시되는 원소들이 매달리게 된다. 각 원소는 세개의 필드를 가진다 
- 가상 페이지 번호
- 사상되는 페이지 프레임 번호
- 연결 리스트 상의 다음 원소 포인터

가상 주소 공간으로부터 페이지 번호가 오면 그것을 해싱한다. 그것으로 해시 페이지 테이블에서 연결리스트를 따라가며 첫 번째 원소와 가상 페이지 번호를 비교한다 일치하면 그에 대응하는 페이지 프레임번호를 가져와 물리 주소를 얻는다 일치하지 않으면 연결 리스트의 그 다음 원소로 똑같은 일을 반복한다.

64비트 시스템에서 유용하도록 변형된 해시 테이블 기법이 제안되었다. 이 변경 기법은 해시 테이블과 비슷한 클러스터 페이지 테이블을 사용한다.

해시 페이지 테이블의 각 항목이 한 개의 페이지만 가리키는 것에 반해 클러스터 페이지 테이블의 각 항목은 여러 페이지를 가리킨다.

따라서 한 개의 페이지 테이블 항목이 여러 페이지 프레임에 대한 변환 정보를 지닐 수 있다. 클러스터 페이지 테이블은 성긴 주소 공간에 유용하게 사용된다. 즉 메모리 액세스가 비연속적이면서 전 주소 공간으로 넓게 펴저 나오는 경유에 유용하다.

## 9.4.3 역 페이지 테이블
운영체제는 프로세스가 가상 페이지 주소를 제시할 때마다 테이블에 와서 그것을 실제 페이지 주소로 변환시켜 주어야 한다.

테이블은 가상 주소에 대해 오름차순으로 정렬되어 있고 운영체제는 테이블 내의 어느 곳에 원하는 물리 페이지가 있는지를 계산할 수 있고, 이 값을 통해서 메모리를 액세스할 수 있다.

위 기법의 단점 중 하나는 각 페이지 테이블 항목의 개수가 수백만 개가 될 수 있다는 것이다. 이러한 테이블은 물리 메모리의 사용을 추적하기 위해 많은 양의 물리 메모리를 소비한다.

위 문제를 해결하는 한 방법이 역페이지 테이블이다. 역 페이지 테이블에서는 메모리 프레임마다 한 항목씩을 할당한다. 각 항목은 그 페임에 올라와 있는 페이지 주소, 그리고 그 페이지를 소유하고 있는 프로세스의 ID를 표시하고 있다.

이렇게 되면 시스템에는 단 하나의 페이지 테이블만이 존재하게 되고, 테이블 내 각 항목은 메모리 한 프레임씩을 가리키게 된다.

논리페이지마다 항목을 가지는 대신 물리 프레임에 대응되는 항목만 테이블에 저장하기 때문에 메모리에서 훨씬 작은 공간을 점유한다. 그러나 역페이지 테이블은 주소 변환 시간이 더 오래 걸릴 수 있다.

역 페이지 테이블은 물리 주소에 따라 정렬되어 있고 탐색은 가장 수조를 기준으로 하므로 테이블 전체를 탐색하여야 할 수도 있다.

이 문제를 해결하기 위해 하나 또는 몇 번의 페이지 테이블을 탐색하도록 해시 테이블을 사용한다. 접근마다 해시 테이블을 참조해야 하므로메모리 참조 횟수를 증사기키게 된다. 성능 향상을 위하여 해시 테이블이 참조되기 전에 우선 TLB가 참조된다는 것을 기억하라.

역 페이지 테이블의 문제 중 하나는 공유 메모리와 관련이 있다. 표준 페이징을 사용하면 프로세스마다 고유한 페이지 테이블이 있으므로 여러 가장 주소를 동일한 물리 주소에 매핑할 수 있다. 이방법은 역 페이지 테이블과 함께 사용할 수 없다.

물리 페이지마다 하나의 가상 페이지 항목만 있으므로 하나의 물리 페이지는 두 개 이상의 공유 가상 주소를 가질 수 없다. 따라서 역 페이지 테이블의 경우 한 번의 하나의 가상 주소만 공유 물리 주소에 매핑할 수 있다.

메모리를 공유하는 다른 프로세스가 참조하면 페이지 폴트가 발생하고 매핑이 다른 가상 주소로 바뀐다.

## 9.4.4 Oracle SPARC Solaris
SPARC CPU에서 실행되는 Solaris는 완전한 64 비트운영체제이며 여러 단계의 페이지 테이블을 메모리에 유지하기 위하여 물리 메모리를 소진하지 않으면서 가상 메모리 문제를 해결해야만 한다.

해당 문제를 해시 테이블을 사용하여 효율적으로 해결하였다. 2개의 해시 테이블을 커널과 모든 사용자 프로세스들을 위하여 유지한다.

각 테이블의 가상 메모리 주소로부터 물리 메모리 주소로 변환한다. 각 해시 테이블 항목은 사상된 가상 메모리 주소로부터 물리 메모리 주소로 변환한다. 각 해시 테이블 항목은 사상된 가상 메모리의 연속된 영역을 나타낸다.

이렇게 하는 것이 각 페이지별로 한 항목씩을 할당하는 것 보다 효율적이다. 각 항목은 기준 주소와 이 항목이 나타내는 페이지의 개수를 나타내는 범위를 가진다.

변환ㄷ 때마다 해시 테이블을 검색해야 한다면 가상-물리 주소 변환에 시간이 오래걸리므로 CPU는 빠른 하드웨어 검색을 위하여 TLB를 구현한다. TLB 탐색 기능은 많은 현대 CPU에서 찾아볼 수 있다.



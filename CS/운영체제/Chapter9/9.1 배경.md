# 배경
메인메모리는 현대 컴퓨터 시스템의 운영에 중심적인 역할을 한다. 메모리는 각각 주소가 할당된 일련의 바이트들로 구성된다.

CPU는 PC가 지시하는 대로 메모리로부터 다음 수행할 명령어를 가져오는데 그 명령어는 필요한 경우 데이터를 더 가져올 수 있으며 반대로 데이터를 메모리로 내보낼 수도 있다.

전형적인 명령어 실행은 먼저 메모리로부터 한 명령어를 가져오는 데서부터 시작된다. 그런 다음 명령어를 해독하고, 메모리에서 피연산자를 가져와 피연산자에대한 명령어를 실행한 후에 계산 결과를 메모리에 다시 저장한다.

## 9.1.1 기본 하드웨어
메인 메모리와 각 처리 코어에 내장된 레지스터들은 CPU가 직접 접근할 수 있는 유일한 범용 저장장치이다.  기계 명령어들은 메모리 주소만을 인수로 취하고, 디스크의 주소를 인수로 취하지 않는다.

CPU와 메인 메모리간 속도 차이가 존재하기 떄문에 둘 사이에 빠른 속도의 메모리 캐시를 추가 해서 사용한다.  물리 메모리의 상대적은 접근 속도의 차이를 고려하는 것에 추가로 올바른 동작을 보장해야만 한다.

운영체제가 CPU와 메모리 간의 접근 중에 개입하게 되면 성능이 떨어지기 때문에 이러한 보호 기법은 반드시 하드웨어가 지원하여야 한다.

먼저 각각의 프로세스가 독립적인 메모리 공간을 가지도록 보장해야 한다. 개별적인 프로세스별 메모리 공간은 서로를 보호하고 병행 실행을 위해 여러 프로세스가 메모리에 적재되게 하는 것이 필수적이다.

기준 레지스터는 가장 작은 합법적인 물리 메모리 주소 값을 저장하고 상한 레지스터는 주어진 영역의 크기를 저장한다. 만약 기준 레스터의 값이 300040이고 상한 레지스터의 값이 120900이라면 프로그램은 300040에서 420940(기준 + 상한)까지의 모든 주소를 접근할 수 있다.

메모리 공간의 보호는 CPU 하드웨어가 사용자 모드에서 만들어진 모든 주소와 레지스터를 비교함으로써 이루어진다. 사용자 모드에서 수행되는 프로그램이 운영체제의 메모리 공간이나 다른 사용자 프로그램의 메모리 공간에 접근하면 운영체제는 오류로 간주하고 트랩을 발생시킨다.

기준과 상한 레지스터는 여러 가지 특권 명령을 사용하는 운영체제에 의해서만 적재된다. 특권 명령은 오직 커널 모드에서만 수행되고 운영체제만 커널 모드에서 수행되기 때문이다.

이러한 기법은 운영체제만 레지스터들의 값을 변경할 수 있도록 허가해 줌으로써 사용자 프로그램이 레지스터의 내용을 변경하는 것을 막는다.

## 9.1.2 주소의 할당
프로그램을 실행하려면 프로그램을 메모리로 가져와서 프로세스 문맨 내에 배치해야 한다. 이 시점에만 가용한 CPU에서 실행할 수 있게 된다.

대부분의 경우 사용자 프로그램은 여러 단계를 거쳐 실행되기 떄문에 이들 단체를 거치는 동안 주소들은 여러 가지 다른 표현 방식을 거치게 된다.

전통적인 메모리 주소 공간에서 명령어와 데이터의 바인딩은 그 바인딩이 이루어 지는 시점에 따라 다음과 같이 구분된다. 

- 컴파일 시간 바인딩 : 만일 프로세스가 메모리 내에 들어갈 위치를 컴파일 시간에 미리 알 수 있으면 컴파일러는 `절대 코드`를 생성할 수 있다.
    -  번역할 코드를 그 위치에서 시작해 나간다. 하지만 이 위치가 변경된다면 이 코드는 다시 컴파일 되야 한다.

- 적재 시간 바인딩 : 만일 프로세스가 메모리 내 어디로 올라오게 될지를 컴파일 시점에 알지 못하면 컴파일러는 일단 이진 코드를 `재배치 가능 코드`로 만들어야 한다.
    -  이 경우에 심볼과 진짜 번지수와의 바인딩은 프로그램이 메인 메모리로 실제로 적재되는 시간에 이루어지게 된다.
    - 이렇게 만들어진 재배치 가능 코든느 시작 주소가 변경되면 아무 떄나 사용자 코드를 다시 적재하기만 하면 된다.

- 실행 시간 바인딩 : 만약 프로세스가 실행하는 중간에 메모리 내의 한 세그먼트로부터 다른 세그먼트로 옮겨질 수 있다면 우리는 바인딩이 실행 시간까지 허용되었다고 이야기 한다.

## 9.1.3 논리 대 물리 주소 공간
CPU가 생성하는 주소를 일반적으로 논리 주소라 하며, 반면에 메모리가 취급하는 주소(메모리 주소 레지스터(MAR)에 주어지는 주소)는 일반적으로 물리 주소라 한다.

컴파일 또는 적재 시에 주소를 바인딩하면 논리 주소와 물리 주소가 같다. 그러나 실행 시간 바인딩 기법에서는 논리, 물리 주소가 다른다.

논리 주소를 가상주소라 하며 프로그램에 의해 생성된 모든 논리 주소 집합을 논리 주소 공간이라 하며 이 논리 주소와 일치하는 모든 물리 주소 집합을 물리 주소 공간이라 한다.

프로그램의 실행 중에는 이와 같은 가상 주소를 물리 주소로 바꾸어 줘야 하는데 이 변환 작업은 하드웨어 장치인 `메모리 관리 장치(Memory Management Unit)`에 의해 실행된다.

## 9.1.4 동적 적재
프로세스의 크기는 메모리 크기보다 커서는 안된다. 메모리 공간의 더 효율적 이용을 위해서는 `동적 적재(Dynamic Loading)`을 해야 한다.

동적 적재에서 각 루틴(명령)은 실제 호출되기 전까지는 메모리에 올라오지 않고 재배치 가능한 상태로 디스크에서 대기하고 있다.

동적 적재의 장점은 루틴이 필요한 경우에만 적재된다는 것이다. 동적 적재는 운영체제로부터 특별한 지원이 필요 없다. 사용자 자신이 프로그램의 설계를 책임져야 한다. 운영체제는 동적 적재를 구현하는 라이브러리 루틴을 제공해 줄 수 있다.

## 9.1.5 동적 연결 및 공유 라이브러리
`동적 연결 라이브러리(DLL)`는 사용자 프로그램이 실행될 때, 사용자 프로그램에 연결되는 시스템 라이브러리이다. 어떤 운영체제는 정적 연결만을 지원한다.

동적 적재시에는 로딩이 실행 시까지 미루어졌었지만 동적 연결에서는 연결이 실행 시기까지 미뤄지는 것

동적 연결은 주로 표준 C언어 라이브러리와 같은 시스템 라이브러리에 사용된다. 이 기능이 없으면 시스템의 각 프로그램은 실행 가능 이미지에 해당 언어 라이브러리(또는 최소한 프로그램이 참조하는 루틴)의 사본을 포함해야 한다.

이 요구 사항은 실행 가능 이미지의 크기를 증가시킬 뿐만 아니라 메인 메모리를 낭비할 수도 있다. DDL의 두 번째 장점은 이러한 라이브러리를 여러 프로세스 간에 공유할 수 있어 메인 메모리에 DLL 인스턴스가 하나만 있을 수 있다는 것이다.

이러한 이유로 DDL은 공유 라이브러리라고도 하며 여러 OS에서 광범위 하게 사용된다. 동적 적재와는 달리 동적 연결과 공유 라이브러리는 일반적으로 운영체제의 도움이 필요하다. 메모리에 있는 프로세스들이 각자의 공간은 자기만 액세스할 수 있도록 보호된다면 운영체제만이 기억 공간에 루틴이 있는지를 검사해 줄 수 있고 운영체제만이 여러 프로세스가 같은 메모미 주소를 공용할 수 있도록 해줄 수 있다.




# 연속 메모리 할당
메모리는 일반적으로 두 개의 부분으로 나누어지는데, 하나는 운영체제를 위한 것 하나는 사용자 프로세스를 위한 것

운영체제를 낮은 메모리 주소 또는 높은 메모리 주소에 배치할 수 있다.  이 결정은 인터럽트 백터의 위치와 같은 많은 요소에 따라 달라진다. 그러나 많은 운영체제는 운영제체를 높은 메모리에 배치한다.

일반적으로 여러 사용자 프로세스가 동시에 메모리에 상주하기를 원한다. 따라서 메모리에 적재되기를 기다리는 프로세스에 사용 가능한 메모리를 할당하는 방법을 고려해야 한다.

`연속적인 메모리 할당`에서 각 프로세스는 다음 프로세스가 적재된 영역과 인접한 하나의 메모리 영역에 적재된다. 

## 9.2.1 메모리 보호
프로세스가 자신이 소유하지 않은 메모리를 접근할 수 없게 강제할 수 있다. 만일 시스템이 상한 레지스터와 재배치 레스트러를 가지고 있다면 목적을 달성할 수 있다.

재배치 레지스터는 가장 작은 물리 조수의값을 저장하고, 상한 레지스터는 논리 주소의 범위 값을 저장한다. 각각의 논리 주소는 상한 레지스터가 지정한 범위 안에 존재해야 한다. MMU는 동적으로 논리 주소에 재배치 레지스터의 값을 더함으로써 주소를 변환하는 역할을 한다.

CP에 의해서 생성되는 모든 주소는 이 레지스터들의 값을 참조해서 확인 작업을 거치기 때문에 운영체제와 다른 사용자 프로그램을 현재 수행 중인 사용자 프로그램의 접근으로부터 보호할 수 있다.

## 9.2.2 메모리 할당
메모리를 할당하는 가장 간단한 방법 중 하나는 프로세스를 메모리의 가변 크기 파티션에 할당하는 것이다. 

각 파티션에는 정확히 하나의 프로세스만 적대될 수 있다. 이 가변 파티션 기법에서 운영체제는 사용 가능한 메모리 부분과 사용 중인 부분을 나타내는 테이블을 유지한다.

처음에는 모든 메모리가 사용자 프로세스에 사용 가능하며, 하나의 큰 사용 가능한 메모리 블록인 hole로 간주한다.

프로세스가 시스템에 들어오면 운영체제는 각 프로세스가 메모리를 얼마나 요구하며, 또 사용 가능한 메모리 공간이 어디에 얼마나 있는지를 고려하여 공간으 할동한다.

프로세스가 공간을 할당받게 되면, 이후로는 CPU를 할당받기 위해 경쟁한다. 프로세스가 끝내면 메모리를 반납하고 운영체제는 다른 프로세스에 이 공간을 할당할 수 있다.

도착 프로세스의 요구를 충족시키기에 메모리가 충분하지 않으면 프로세스를 거부하고 오류 메시지를 제공하거나 프로세스를 대기 큐에 넣는 것이다.

나중에 메모리가 해체되면 운영체제는 대기 큐르르 검사하여 대기 프로세스의 메모리 요구를 충족시킬지 여부를 결정한다.

일반적으로 메모리에는 다양한 크기의 hole이 여기저기 산재하게 된다. 프로세스에 공간이 필요할때 운영체제는 이 hole의 집합에서 적절한 것을 찾아내야 한다.

만약 hole을 찾았는데 그것이 요청한 것보다 약간 크면 두 개로 나누어 한 조각은 프로세스에 할당하고 나머지 하나는 hole 집합으로 되돌아간다.

새로운 hole이 다른 hole과 인접해 있다면 두개의 블록을 합쳐서 한 개의 큰 hole로 만든다. 이러한 기법은 `동적 메모리 할당 문제`의 특별한 예이다.

이러한 문제에 대한 결책은 여러개가 제시되어있다. 아래 3가지는 가장 일반적인 기법들
- 최초 적합(first-fit) : 첫 번째 사용 가능한 가용 공간을 할당한다. 검색은 집합의 시작에서부터 하거나 지난번 검색이 끝났던 곳에서 시작될 수 있다. 충분히 큰 가용 공간을 찾았을 때 검색을 끝낼 수 있다.
- 최적 적합(best-fit) : 사용 가능한 공간 중에서 가장 작은 것을 택한다. 리스트가 크기 순으로 되어 있지 않다면 전 리스트를 검색해야만 한다. 이 방법은 아주 작은 가용 공간을 만들어 낸다.
- 최악 적잡(worst-fit) : 가장 큰 가용 공간을 택한다. 이 방식에서 할당해 주고 남게 되는 가용 공간은 충분히 커러 다른 프로세스들을 위하여 유용하게 사용될 수 있다. 이때 가용 공간들이 크기 순으로 정렬되어 있지 않다면 전 리스트를 다 검색해야만 한다.

모의 실험을 통해서 연구해보면 최초,최적 적합 모두가 시간과 공간 효율 측면에서 최악 적합보다 좋다. 최초 적합이나 최적 적합이나 공간 효율성 측면에서는 우열을 가릴 수 없지만 시간적으로는 최초 적합이 일반적으로 빠르다.

## 9.2.3 단편화
최초 적합 전략과 최적 적합 전략 모두 `외부 단편화(external fragmentation)`로 인해 어려움을 겪는다.

프로세스들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 어떤 가용 공간은 너무 작은 조각이 되어 버린다. 

외부 단편화는 이처럼 유효 공간들을 모두 합치면 충분한 공간이 되지만 그것들이 너무 작은 조각들로 여러 곳에 분산되어 있을 때 발생한다. 메모리는 너무 많은 수의 매우 작은 조각들로 단편화 되어 있는 것이다. 최악의 경우에는 모든 프로세스 사이마다 못 쓰게 된 가용 공간을 가질 수 있다. (이 모든 가용공간을 합치면 충분히 사용 가능한 가용 공간임에도)

적합 또는 최적 적합 전략을 사용할 것인지 사용하지 않을 것인지의 결정은 단편화의 크기에 영향을 받는다. 메모리의 전체 크기와 프로세스 크기들은 모두 외부 단편화에 따라 큰 영향을 미칠 수 있다.(최초적합의 경우 통계적인 분석을 해보면 N개의 블록이 할당되었을때 0.5N개의 블록이 단편화때문에 손실된다. 메모리의 1/3이 사용 불가하게 된다. 이 현상은 50% 규칙으로 알려져 있다.)

메모리 공간을 낭비하는 현상인 단편화는 내부적으로도 발생할 수 있다. 할당된 공간이 요구된 공간보다 크다면 남는 부분이 `내부 단편화(internal fragmentation)`이다 내부 단편화 역시 사용이 못되는 부분이다.

외부 단편화 문제를 해결하는 다른 방법으로는 `압축`이 있다 메모리 모든 내용을 한군데로 몰고 모든 가용 공간을 다른 한군데로 몰아서 큰 블록을 만드는 것이다.

압축은 항상 가능한 것은 아니며 재배치가 어셈블 또는 적재 시점에 정적으로 행해진다면, 압축은 실행될 수 없다.

`압축은 프로세스들의 재배치가 실행 시간에 동적으로 이루어지는 경우에만 가능하다.` 주소가 동적으로 재배치할 수 있다면, 재배치 작업은 프로그램과 데이터를 새로운 위치로 옮기고 새 위치를 반영하기 위하여 기준 레스터만 변경하면 완료된다.

압축이 가능하더라도 비용을 검토해 보아야 한다. 가장 간단한 압축 알고리즘은 단순히 모든 프로세스르르 한쪽 끝으로 이동시켜 모든 가용공간이 그 반대 방향으로 모이도록 하는 방법이지만 이 방법은 비용이 많이 든다.

`외부 단편화 문제를 해결할 수 있는 다른 방법은 한 프로세스의 논리 주소 공간을 여러 개의 비연속적인 공간으로 나누어 필요한 크기의 공간이 가용해지는 경우 물리 메모리를 프로세스에 할당하는 기법이다.`

위 방법은 일반적인 메모리 관리 기법인 페이징에서 사용되는 전략이다.


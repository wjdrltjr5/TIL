# 테스트 개선하기
## 키보드 입력 대체하기
```java
public class Game{
    private Player player;
    private CommandParser commandParser;
    private InputOutput io;
    private boolean running;

    public Game(InputOutput io){
        this.player = new Player(...);
        this.commandParser = new CommandParser();
        this.io = io;
    }

    private void play(){
        start();
        while(isRunning()){
            String input = inputCommand();
            Command command = parseCommand(input);
            execute(command);
        }
    }

    private String inputCommand(){
        showPrompt();
        return input();
    }

    private String input(){
        return io.input();
    }
}

public class FakeInputOutput implements InputOutput{
    int currentInput;
    private List<String> inputs;
    private StringBuilder outputs;

    public FakeInputOutput(String ... inputs){
        this.currentInput = 0;
        this.inputs = List.of(inputs);
    }

    @Override
    public String input(){
        return inputs.get(currentInput++);
    }

    public List<String> outputs(){
        return Arrays.stream(outputs.toString().split("\n")).toList();
    }

    @Override
    public void showLine(String text){
        output.append(text + "\n");
    }

    @Override
    public void show(String text){
        outputs.append(text);
    }
}
```

## 테스트 개선하기
```java
// 입력과 출력이 명확해진 테스트
public class GameTest{
    @Test
    public void move_north_passed(){
        FakeInputOutput io = new FakeInputOutput("go north", "quit");
    
        Game game = new Game(io); // Game은 테스트에서 FakeInputOutput을 사용한다는 사실을 명시적으로 표현
        game.run();
        // FakeInputOutput을 이용해서 결과 검증
        assertThat(io.outputs()).containsSequence(
            "> 당신은 [다리]에 있습니다.",
            "큰 강 위에 돌로 만든 커다란 다리가 있습니다.",
            "> ",
            "게임을 종료합니다.");
    }
}
```

## 여전히 암시적인 테스트 결과
```java
FakeInputOutput io = new FakeInputOutput("go north", "quit");
// 북쪽으로 이동한 위치가 다리인 이유는?
assertThat(io.outputs()).containsSequence(
"> 당신은 [다리]에 있습니다.",
"큰 강 위에 돌로 만든 커다란 다리가 있습니다.",
"> ",
"게임을 종료합니다.");
```
- Game 생성자 내부에 숨겨져 있는 지도의 구조와 플레이어의 위치 -> 숨겨진 의존성을 생성자의 시그니처의 명시적으로 선언
- Main클래스에서 의존성을 주입
```java
public class Game{
    public Game(Player player, CommandParser commandParser, InputOutput io){
        this.player = player;
        this.commandParser = commandParser;
        this.io = io;
    }
}

public class Main{
    public static void main(String[] args){
        Player player = new Player(
                    new WorldMap(
                    Size.with(2, 3),
                    new Room(Position.of(0,0), "샘", "아름다운 ..."),
                    ...
                    Position.of(0, 2)),
                Position.of(0, 2);
        CommandParser commandParser = new CommandParser();
        InputOutput io = new Console();

        Game game = new Game(player, commandParser, io);
        game.run();
    }
}
```

## 테스트 입력과 출력 사이의 연관성을 명시적으로 표현(의존성 드러내기?)

```java
// 입력과 출력이 명확해진 테스트
public class GameTest{
    @Test
    public void move_north_passed(){
        FakeInputOutput io = new FakeInputOutput("go north", "quit");
    
        Player player = new Player(
                    new WorldMap(
                    Size.with(2, 3),
                    new Room(Position.of(0,0), "샘", "아름다운 ..."),
                    ...
                    Position.of(0, 2)),
                Position.of(0, 2));
        CommandParser commandParser = new CommandParser();

        Game game = new Game(player, commandParser, io); 
        game.run();
        // 이제 이동 후 왜 다리에 있는 지 이해하게 됨
        assertThat(io.outputs()).containsSequence(
            "> 당신은 [다리]에 있습니다.",
            "큰 강 위에 돌로 만든 커다란 다리가 있습니다.",
            "> ",
            "게임을 종료합니다.");
    }
}
```

## 테스트하기 쉬운 설계의 특징
`객체가 의존하는 대상이 객체의 인터페이스에 명시적으로 드러나 있는 설계`
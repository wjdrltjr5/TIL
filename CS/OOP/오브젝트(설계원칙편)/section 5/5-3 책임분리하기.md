# 책임 분리하기
단일 책임 원칙 사전 작업 : 단일 추상화 수준 원칙을 만족시키도록 추상화 수준이 동일한 조합 메서드 형태로 리팩터링

책임을 정리한 문자과 메서드 분류는 작업 방향을 정하기 위한 스케치 (클래스를 분리할 수 있을 정도로 정확할 필요가 없음)
- Game
    - 흐름제어
        - run
        - play
        - start
        - stop
        - inRunning
    - 플레이어 이동
        - tryMove
    - 지도 구조 관리
        - isBlocked
        - isExcluded
        - roomAt
    - 사용자입력
        - inputCommand
        - input
    - 명령어 파싱
        - parseCommand
    - 화면 출력
        - welcome
        - showGreetings
        - showRoom
        - showHelp
        - farewell
        - showBlocked
        - showUnknownCommand
        - showPrompt

함께 사용되는 인스턴스 변수들을 그룹으로 묶기
    - size, room

## 객체지향의 핵심은 자신의 상태를 스스로 책임지는 객체
지도를 관리하는 책임을 WorldMap 클래스로 분리

```java
// Game에 존재하던 변수와 메서드를 WorldMap 클래스로 이동
public class WorldMap{
    private Size size;
    private Room[] rooms;

    public WorldMap(Size size, Room[] rooms){
        this.size = size;
        this.rooms = rooms;
        for(Room room : rooms){
            this.room[size.indexOf(room.position())] = room;
        }
    }

    private boolean isBlocked(Position position){
        return isExcluded(Position position){
            return isExcluded(position || roomAt(position)) == null
        }
    }

    private boolean isExcluded(Position position){
        return !size.contains(position);
    }

    private Room roomAt(Position position){
        return rooms[size.indexOf(position)];
    }
}
// WorldMap에 위임
public class Game{
    private WorldMap worldMap;
    private Position position;
    private boolean running;

    ...
    private void tryMove(Direction direction){
        if((worldMap.isBlocked(position.shift(direction)))){
            showBlocked();
        }else{
            position = position.shift(direction);
            showRoom();
        }
    }

    private void showRoom(){
        System.out.println("당신은 [" +
            worldMap.roomAt(position).name() + "]에 있습니다.");
        System.out.println(worldMap.roomAt(position).name().description());
    }
}
```
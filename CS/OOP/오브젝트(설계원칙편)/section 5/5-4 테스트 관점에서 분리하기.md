# 테스트 관점에서 분리하기
## 테스트하기 어려운 private 메서드

- 테스트 하고 싶은 Private 메서드가 있는지 살펴본다.
```java
public class Game{
    private Size size;
    private Room[] rooms;
    private Position position;
    private boolean running;
    ...

    // 외부에서 테스트 불가능한 private 메서드
    private boolean isBlocked(Position position){
        return isExcluded(position) || roomAt(position) == null;
    }

    private boolean isExcluded(Position position){
        return !size.contains(position);
    }

    private Room roomAt(Position position){
        return rooms[size.indexOf(position)];
    }
}

public class WorldMap{
    private Size size;
    private Room[] rooms;

    public WorldMap(Size area, Room ... rooms){
        this.size = area;
        this.rooms = new Room[size.area()];
        for(Room room : rooms){
            this.rooms[size.indexOf(room.position())] = room;
        }
    }

    // 테스트 하기 쉬운 public 메서드로 변경
    public boolean isBlocked(Position position){
        return isExcluded(position) || roomAt(position) == null;
    }

    private boolean isExcluded(Position position){
        return !size.contains(position);
    }

    private Room roomAt(Position position){
        return rooms[size.indexOf(position)];
    }
}
```

단일 책임 원칙은 테스트 가능성을 개선

## 테스트하기 어려운 parseCommand
private 메서드 내부에 존재하는 파싱 로직
```java
public class Game{
    private void play(){
        Scanner scanner = new Scanner(System.in);
        start();
        while(isRunning()){
            String input = inputCommand();
            parseCommand(input);
        }
    }
    // 테스트하기 어려운 private 메서드
    private void parseCommand(String input){
        String[] commands = input.toLowerCase().trim().split("\\s+");
        switch(commands[0]){
            case "go" ->{
                switch(commands[1]){
                    case "north" -> tryMove(Direction.NORTH);
                    case "south" -> tryMove(Direction.SOUTH);
                    case "east" -> tryMove(Direction.EAST);
                    case "west" -> tryMove(Direction.WEST);
                    default -> showUnknownCommand();
                }
            }
            case "look" -> showRoom();
            case "help" -> showHelp();
            case "quit" -> stop();
            default -> showUnknownCommand();
        }
    }
    ...
}
```

## parseCommand를 CommandParser로 이동시킨다면?
```java
public class game{
    private CommandParser commandParser;

    private void play(){
        Scanner scanner = new Scanner(System.in);
        start();
        while(isRunning()){
            String input = inputCommand();
            commandParser.parseCommand(input);
        }
    }

    ...
}


public class CommandParse{
    private Game game;

    private void parseCommand(String input){
        String[] commands = input.toLowerCase().trim().split("\\s+");
        switch(commands[0]){
            case "go" ->{
                switch(commands[1]){
                    case "north" -> game.tryMove(Direction.NORTH);
                    case "south" -> game.tryMove(Direction.SOUTH);
                    case "east" -> game.tryMove(Direction.EAST);
                    case "west" -> game.tryMove(Direction.WEST);
                    default -> game.showUnknownCommand();
                }
            }
            case "look" -> game.showRoom();
            case "help" -> game.showHelp();
            case "quit" -> game.stop();
            default -> game.showUnknownCommand();
        }
    }
}
```


위처럼 변경되면 양방향 참조가 생긴다.
- 의존성 사이클로 인한 높은 결합도
    - 함께 변경되는 두개의 클래스
    - 두 객체 참조 동기화를 위한 복잡성
    - 테스트를 위해 CommandParser와 Game두 객체 모두 필요
    - Game객체가 의존하는 콘솔에 대한 의존성이 그대로 CommandParser로 전이
    - 이러면 메서드 차원에서 다시 고민해봐야 한다.

## 리팩토링 전의 parseCommand 메서드
테스트와 관련있는 로직과 관련 없는 로직이 하나의 메서드 안에 공존
```java
public class Game{
    // 테스트하기 어려운 private 메서드
    private void parseCommand(String input){
        // 테스트와 관련 있는 입력 파싱 로직
        String[] commands = input.toLowerCase().trim().split("\\s+");
        switch(commands[0]){
            case "go" ->{
                switch(commands[1]){
                    // 테스트와 상관없는 메서드 실행 로직들
                    case "north" -> tryMove(Direction.NORTH); 
                    case "south" -> tryMove(Direction.SOUTH);
                    case "east" -> tryMove(Direction.EAST);
                    case "west" -> tryMove(Direction.WEST);
                    default -> showUnknownCommand();
                }
            }
            case "look" -> showRoom();
            case "help" -> showHelp();
            case "quit" -> stop();
            default -> showUnknownCommand();
        }
    }
    ...
}
```

## 해결방법
- 실행 로직은 Game에 남겨두고 파싱 로직만 CommandParse로 이동
- 실행로직과 파싱로직의 연결은 파싱한 결과를 command객체에 담아 실행 로직으로 전달.

```java
public sealed interface Command {
    record Move(Direction direction) implements Command {}
    record Unknown() implements Command {}
    record Look() implements Command {}
    record Help() implements Command {}
    record Quit() implements Command {}
}

public class Game {
    private WorldMap worldMap;
    private Position position;
    private CommandParser commandParser;
    private boolean running;

    ...

    private void play() {
        Scanner scanner = new Scanner(System.in);

        start();
        while (isRunning()) {
            String input = inputCommand(scanner);
            Command command = commandParser.parseCommand(input);
            executeCommand(command);
        }
    }

    private void executeCommand(Command command) {
        switch(command) {
            case Command.Move move -> tryMove(move.direction());
            case Command.Look() -> showRoom();
            case Command.Help() -> showHelp();
            case Command.Quit() -> stop();
            case Command.Unknown() -> showUnknownCommand();
        }
    }
    ...
}
//이제는 파싱 책임만을 담당.
public class CommandParser {
    public Command parseCommand(String input) {
        return parseCommand(split(input));
    }

    private Command parseCommand(String[] commands) {
        return switch (commands[0]) {
            case "go" ->
                switch (commands[1]) {
                    case "north" -> new Command.Move(Direction.NORTH);
                    case "south" -> new Command.Move(Direction.SOUTH);
                    case "east" -> new Command.Move(Direction.EAST);
                    case "west" -> new Command.Move(Direction.WEST);
                    default -> new Command.Unknown();
                };
            case "look" -> new Command.Look();
            case "help" -> new Command.Help();
            case "quit" -> new Command.Quit();
            default -> new Command.Unknown();
        };
    }

    private String[] split(String input) {
        return input.toLowerCase().trim().split("\\s+");
    }
}
```

## 간단해진 단위 테스트
```java
public class CommandParserTest {
    @Test
    public void go() {
        CommandParser parser = new CommandParser();
        assertThat(parser.parseCommand("go north")).isEqualTo(new Command.Move(Direction.NORTH));
        assertThat(parser.parseCommand("go south")).isEqualTo(new Command.Move(Direction.SOUTH));
        assertThat(parser.parseCommand("go east")).isEqualTo(new Command.Move(Direction.EAST));
        assertThat(parser.parseCommand("go west")).isEqualTo(new Command.Move(Direction.WEST));
    }

    @Test
    public void go_north() {
        CommandParser parser = new CommandParser();
        assertThat(parser.parseCommand("go north")).isEqualTo(new Command.Move(Direction.NORTH));
        assertThat(parser.parseCommand("Go North")).isEqualTo(new Command.Move(Direction.NORTH));
        assertThat(parser.parseCommand("go     north")).isEqualTo(new Command.Move(Direction.NORTH));
        assertThat(parser.parseCommand("  go     north  ")).isEqualTo(new Command.Move(Direction.NORTH));
    }

    @Test
    public void look() {
        CommandParser parser = new CommandParser();
        assertThat(parser.parseCommand("look")).isEqualTo(new Command.Look());
    }

    @Test
    public void stop() {
        CommandParser parser = new CommandParser();
        assertThat(parser.parseCommand("quit")).isEqualTo(new Command.Quit());
    }

    @Test
    public void help() {
        CommandParser parser = new CommandParser();
        assertThat(parser.parseCommand("help")).isEqualTo(new Command.Help());
    }
}
```

## 테스트는 단일 책임 원칙의 준수 여부를 판단하는 척도
## 응집도를 높이고 결합도를 낮추기
너무 많은 텍스트 픽스처를 생성해야 하거나 너무 많은 실행 경로를 테스트해야 한다면 단일 책임 원칙을 위반한 것이다. -> 테스트 범위에 따라 클래스를 분리하라.
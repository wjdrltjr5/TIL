# 단일 책임 원칙을 위한 가이드
- 책임을 한 문장으로 적어본다.
    - 클래스의 책임을 설명하는데 `그리고`나 `또는`이 들어가면 여러 개의 책임을 담당하는 클래스다.
    - 변경 전 Schedule
        - 반복되는 일정을 확인`하고` 일정 정보를 JSON으로 변환한다.

- 메서드들을 분류한다.
    - 이름이나 목적이 비슷한 메서드들을 그룹으로 묶어 나열한다. 이 메서드 그룹별로 클래스들을 나눌 수 있는지 살펴본다.

- 인스턴스 변수와 메서드 사이의 관계를 살펴본다.
    - 일부 인스턴스 변수가 일부 메서드에 의해서만 사용되는지 살펴본다.
    - 월단위 일정 필드, 주단위 일정 필드

- 서로 베타적으로 초기화되는 인스턴스 변수가 있는지 살펴본다.
    - 어떤 변수들이 초기화될 때 함께 초기화되지 않는 인스턴스 변수들이 있는지 살펴본다.
    - 월단위 일정 필드, 주단위 일정 필드

- 테스트하고 싶은 private 메서드가 있는지 살펴본다.
    - 너무 많은 private(또는 protected) 메서드가 있을 때 테스트하고 싶은 private 메서드가 존재하는지 살펴본다.

- 외부 의존성을 찾는다.
    - 데이터베이스 연결이나 외부 시스템과의 연동 등과 같이 외부에 위치하는 불안정한 의존성을 찾는다.
    - 변경 전 Schedule
        - Jackson 라이브러리의 Object Mapper에 의존

## 단일 책임 원칙의 가장 중요한 기준
요구사항의 변경 : 요구사항이 변경되면 책임의 범위도 요구사항에 따라 변경

- 새로운 요구사항 추가 : 2025년 1월 13일에 데일리 스크럼이 열리나요?
    - 매주 월요일, 화요일 오전 9시부터 15분간

```java
// 새로운 필드와 생성자 추가
public class Schedule{
    private static final int DAYS_IN_WEEK = 7;

    private String title;
    private LocalTime from;
    private Duration duration;
    // 월간 회의 (서로 다른 시점에 초기화 되는 변수들)
    private Integer ordinal;
    private DayOfWeek dayOfWeek;
    // 데일리 스크럼(서로 다른 시점에 초기화 되는 변수들)
    private Set<DayOfWeek> dayOfWeeks = new HashSet();

    public Schedule(String title, LocalTime from, Duration duration ,
            DayOfWeek dayOfWeek, Integer ordinal){
        this.title = title;
        this.from = from;
        this.duration = duration;
        // 월간 회의 (서로 다른 시점에 초기화 되는 변수들)
        this.ordinal = ordinal;
        this.dayOfWeek = dayOfWeek;
    }

    public Schedule(String title, LocalTime from, Duration duration, Set<DayOfWeek> dayOfWeeks){
        this.title = title;
        this.from = from;
        this.duration = duration;
        // 데일리 스크럼( 서로 다른 시점에 초기화 되는 변수들)
        this.dayOfWeeks = dayOfWeeks;
    }

    public boolean includes(LocalDate day){
        if(ordinal != null){
            if(!day.getDayOfWeek().equals(dayOfWeek)){
                return false;
            }        
            return (day.getDayOfMonth() / DAYS_IN_WEEK) + 1 == ordinal;
        }        
        return dayOfWeeks.contains(day.getDayOfWeek());
    }
}
```

단일 책임 원칙을 적용하기 전 조합메서드로 리팩터링 현재 includes는 추상화 수준이 동일하지 않음
```java
public boolean includes(LocalDate day){
    if(ordinal != null){
        return checkMonthly();
    }
    return checkWeekly();
}
```

함께 사용되는 필드와 메서드를 별도의 클래스로 분리
- MonthlyPlan
    - ordinal
    - dayOfWeek
    - includes(day)
- WeeklyPlan
    - dayOfWeeks
    - includes(day)

```java
public interface RecurringPlan{
    boolean includes(LocalDate day);
}

public class MonthlyPlan implements RecurringPlan{
    private static final in DAYS_IN_WEEK = 7;

    private Integer ordinal;
    private DayOfWeek dayOfWeek;

    @Override
    public boolean includes(LocalDate day){
        if(!day.getDayOfWeek().equals(dayOfWeek)){
            return false;
        }
        return (day.getDayOfMonth() / DAYS_IN_WEEK) + 1 == ordinal;
    }
}

public class WeeklyPlan implements RecurringPlan{
    private Set(DayOfWeek) dayOfWeeks;

    @Override
    public boolean includes(LocalDate day){
        return dayOfWeeks.contains(day.getDayOfWeek());
    }
}
```


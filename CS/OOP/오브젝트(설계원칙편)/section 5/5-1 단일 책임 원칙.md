# 단일 책임 원칙
단일 책임 원칙 : 클래스는 단 한가지 변경 이유만을 가져야 한다. (응집도가 높은 클래스를 만드는 원칙)

## 응집도
- 응집도 : 모듈 내부 요소들이 함께 변경되는 정도
    - 높은 응집도 : 모듈 전체가 동일한 이유로 변경
    - 낮은 응집도 : 모듈 각 부분이 서로 다른 이유로 변경

- 변화율 : 변경의 이유에 따라 클래스를 분리하라
    - 서로 다른 이유로 변경되는 응집도가 낮은 코드
        - 서로 다른 사람이 서로 다른 부분을 변경
        - 상관이 없는 변경으로 인해 영향 받는 코드
        - 수정 사항 충돌
        - 부수 효과로 인한 버그

- 단일 책임 원칙을 지킨 코드
    - 안정적으로 각 변경사항 수정 가능
        - 변경으로 인한 파급효과 제어

## 결합도
- 결합도 : 외부의 다른 모듈에 의해 함께 변경되는 정도
    - 높은 결합도 : 외부의 모듈이 변경될 떄 함께 변경되는 빈도가 상대적으로 높음
    - 낮은 결합도 : 외부의 모듈이 변경될 때 함께 변경되는 빈도가 상대적으로 적음

서로 다른 이유로 변경되는 코드 묶음은 서로 다른 작업을 처리하기 떄문에 서로 다른 클래스에 의존 상관없는 객의 수정으로 인한 파급효과가 있다면 변경과 충돌의 빈도 증가

변경에 이유에 따라 클래스를 나눠서 의존하는 객체를 분리(결합도를 낮춰서 변경의 파급효과 제어) -> 의존 객체의 수정 여파를 각 클래스가 흡수

## 예시
```java
public class Schedule{
    private static final int DAYS_IN_WEEK = 7;

    private String title;
    private LocalTime from;
    private Duration duration;
    private Integer ordinal;
    private DayOfWeek dayOfWeek;

    public Schedule(String title, LocalTime from, Duration duration,
            DayOfWeek dayOfWeek, Integer ordinalWeek){
                ...
    }
    // 일정 확인 방식이 변경될 때 수정 (서로 다른 이유로 수정되는 코드)
    public boolean includes(LocalDate day){
        if(!day.getDayOfWeek().equals(dayOfWeek)){
            return false;
        }
        return (day.getDayOfMonth() / DAY_IN_WEEK) + 1 == ordinal;
    }
    // 출력 포맷이 변경될 때 수정 (서로 다른 이유로 수정되는 코드)
    // 관련없는 JackSon 라이브러리에 결합된 toJson 메서드
    public String toJson() throws JsonProcessingException {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.NONE);
        mapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);

        return mapper.writeValueAsString(this);
    }
}
```
현재 위 코드는 응집도가 낮고 결합도가 높은 단일책임원칙위반 클래스
- 서로 다른 이유로 변경되는 두 부분을 변경의 이유에 따라 독립적인 클래스로 분리

```java
// 출력 포맷에 영향을 받지 않음 이제
public class Schedule{
    private static final int DAYS_IN_WEEK = 7;

    private String title;
    private LocalTime from;
    private Duration duration;
    private Integer ordinal;
    private DayOfWeek dayOfWeek;

    public Schedule(String title, LocalTime from, Duration duration,
            DayOfWeek dayOfWeek, Integer ordinalWeek){
                ...
    }
    
    public boolean includes(LocalDate day){
        if(!day.getDayOfWeek().equals(dayOfWeek)){
            return false;
        }
        return (day.getDayOfMonth() / DAY_IN_WEEK) + 1 == ordinal;
    }
}

public class ScheduleJson{
    private Schedule schedule;
    private ObjectMapper mapper;

    public ScheduleJson(Schedule schedule){
        this.schedule = schedule;
        this.mapper = initializeMapper();
    }

    private ObjectMapper initializeMapper(){
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.NONE);
        mapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);

        return mapper
    }

    public String toJson() throws JsonProcessingException {
        return mapper.writeValueAsString(schedule);
    }
}
```

단일 책임 원칙의 핵심
- 클래스는 작아야 한다.
    - 단 하나의 변경 이유만 가질 정도로 클래스는 작아야 한다.

사실 단일 책임 원칙은 이해하기도 적용하기도 어렵다. 기능이 동일하더라도 변하는 부분이 달라지면 책임도 달라지기 때문


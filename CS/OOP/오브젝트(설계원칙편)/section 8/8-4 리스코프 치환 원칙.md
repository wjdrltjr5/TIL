# 리스코프 치환 원칙
다형적인 개방-폐쇄 원칙을 적용한 컴파일 타임 확장 -> 새로운 플래스를 추가해서 기존 코드 수정 없이 확장 -> 다형적인 개방-폐쇄 원칙은 안정적인 런타임 동작을 보장하지 않음(클라이언트 입장에서 오류 발생 가능)

올바른 상속 관계란 -> 클라이언트 관점에서 기대한 행동 수행

- 서브 타이핑 : 클라이언트 관점에서 호환 가능한 두 타입 사이의 관계 인터페이스 상속이라고 불림

## 서브타이핑을 위한 설계 원칙
리스코프 치환 원칙 : 클라이언트 관점에서 서브타입은 기반 타입을 대체할 수 있어야 한다.

어떤 함수 f가 그 인자로 포인터나 어떤 깁나 클래스 B의 참조를 가진다고 생각해 보자. 그 어떤 B의 어떤 파생 클래스 D가 B를 가장해 f에 넘겨져서 클라이언트 f가 잘못된 종닥을 하도록 한다면, 이 경우 D는 리스코프 치환 원칙을 위반한다.

여기서 요구되는 것은 다음과 같은 치환 특성이다. S형의 각 객체 o1에 대해 T형의 객체 o2가 하나가 있고, T에 의해 정의된 모든 프로그램 P에서 T가 S로 치환될 때, P의 동작이 변하지 않으면 S는 T의 하위 타입이다.

S타입의 객체 o1에 대해 T타입의 객체o2가 하나가 있고, T에 의해 정의된 모든 프로그램 P에서 S가 T를 치환할 때, P의 동작이 변하지 않으면 S는 T의 서브타입이다.

## 리스코프 치환 원칙의 핵심
클라이언트가 이전과 동일한 방식으로 동작하는지 여부가 중요 -> 올바른 상속 계층에서 모든 클래스들은 리스코프 치환 원칙 준수 (서브클래스들이 모두 클라이언트 관점에서 기대한대로 동작)

## 리스코프 치환 원칙을 위반하는 전형적인 케이스
RTTI(Runtime Type Information) 사용
```java
// 클라이언트가 객체의 타입을 확인할 경우 클라이언트가 올바르게 동작하지 않을 가능성 증가
if(reader instanceof CsvReader){ 
    calls = reader.read();
    System.out.println("CSV 포맷을 처리했습니다.");
}else if(reader instanceof JsonReader){
    calls = reader.read();
    System.out.println("JSON포맷을 처리했습니다.");
}else{
    throw new IllegalArgumentException(Reader.class + "는 처리할 수 없습니다.");
}
```

위코드는 새로운 Reader를 추가시 예외가 발생한다. ->  비정상적으로 동작하는 클라이언트 리스코프 치환 원칙 위반

## 모델의 유효성
리스코프 치환 원칙 : 리스코프 치환 원칙은 고립적으로 본 모델은 의미 있게 검증하는 것이 불가능하다 라는 아주 중요한 결론으로 이끈다. 어떤 모델의 유효성은 오직 그 클라이언트의 관점에서만 표현될 수 있다.

RTTI를 사용하는 클라이언트라면 유효하지 않은 설계 -> 클라이언트 관점에서 상속 계층의 전체 클래스 테스트

```java
// 모든 서브타입들이 클라이언트가 기대하는 행동을 만족하는지 테스트
public class CallCollectorWithReaderTest{
    public static Stream<Argument> readers(){
        return Stream.of(
            Arguments.of(new CsvReader("calls.csv")),
            Arguments.of(new JsonReader("calls.json"))
        );
    }
    //ParameterizedTest 어노테이션 : 하나의 테스트 케이스인데 값을 여러개로 테스트 할때
    @ParameterizedTest
    @MethodSource("readers")
    public void collect(Reader reader){
        CallCollector callCollector = new CallCollector(reader);
        // 클라이언트가 기대하는 행동을 모든 서브클래스들이 만족시키는지 테스트
        CallHistory history = CallCollector.collect("010-1111-2222");
        assertThat(history.callDuration()).isEqualTo(Duration.ofSeconds(159));
    }
}
```
# 명령 쿼리 분리 원칙으로 부수효과 관리하기
## 루틴
- 루틴 : 일련의 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈 부수효과와 반환 값의 유무에 따라 프로시저와 함수로 분류
    - 프로시저 : 부수효과 존재 반환 값이 없음
        - 객체의 관점에서 : 명령
    - 함수 : 부수효과 없음 반환 값 존재
        - 객체의 관점에서 쿼리


## 명령 쿼리 분리
명령 쿼리 분리 원칙 : 부수효과를 발생시키지 않는 것만을 함수로 제한하믕로써 소프트웨어에서 말하는 함수의 개념이 수학에서의 개념과 상충되지 않게 한다. `객체를 변경하지만 직접적으로 값을 반환하지 않는 명령과 객체에 대한 정보를 반환하지만 변경하지는 않는 쿼리를 명확히 분리해야 한다.`

- 질문이 답변을 수정해서는 안된다.
    - 객체의 상태를 변경하는 명령은 반환 값을 가질 수 없다.
    - 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다. 

명령과 쿼리를 분리하면 이해하기 쉬운 코드가 만들어진다.

```java
// 명령인 동시에 쿼리인 includes 메서드
// 시그니쳐는 쿼리지만 구현은 명령
public boolean includes(LocalDate day){
    if(!plan.includes(day)){
        plan.reschedule(day);
        return false;
    }
    return true;
}
```
위 코드는 코드 내부를 살펴보기 전까지는 결과 예측이 어려움
```java
public class ScheduleTest{
    @Test
    public void day_of_week_in_month_includes(){
        Schedule schedule = new Schedule(
            "월간회의",
            LocalDateTime.of(14, 0),
            Duration.ofHours(1),
            new MonthlyPlan(DayOfWeek.MONDAY, 2));
        // 처음 호출의 결과는 false지만 두번째 호출의 결과는 true로 예측이 어렵다.
        assertThat(schedule.includes(LocalDate.of(2025, 1, 16))).isFalse();
        assertThat(schedule.includes(LocalDate.of(2025, 1, 16))).isFalse();
    }
}
```

일관성 있는 메서드를 제공해야 한다.
- boolean includes(LocaleDate day);
    -  쿼리 : 부수효과 없음 몇 번을 연이어 호출해도 결과 동일
- void schedule(LocalDate day);
    - 명령 : 부수효과 발생 호출할 때마다 상태 변경

```java
// 명령과 쿼리를 별개의 메서드로 분리
public class Schedule{
    private String name;
    private LocalTime from;
    private Duration duration;
    private RecurringPlan plan;

    public boolean includes(LocalDate day){
        return plan.includes(day);
    }

    public void adjust(LocalDate day){
        plan.reschedule(day);
    }
}
```
일관성 있고 예측이 쉬워진 메서드
```java
public class ScheduleTest{
    @Test
    public void day_of_week_in_month_includes(){
        Schedule schedule = new Schedule(
            "월간회의",
            LocalTime.of(14, 0),
            Duration.ofHours(1),
            new MonthlyPlan(DayOfWeek.MONDAY, 2));
    }
    // 이제 몇번을 호출하더라도 값은 같음
    assertThat(schedule.includes(LocalDate.of(2025, 1, 16))).isFalse();
    assertThat(schedule.includes(LocalDate.of(2025, 1, 16))).isFalse();
    assertThat(schedule.includes(LocalDate.of(2025, 1, 16))).isFalse();
    assertThat(schedule.includes(LocalDate.of(2025, 1, 16))).isFalse();
}
```

일정 조정이 필요하다면 명확하게 의도를 표현하는 adjust메서드를 사용

```java
public class ScheduleTest{
    @Test
    public void day_of_week_in_month_includes(){
        Schedule schedule = new Schedule(
            "월간회의",
            LocalTime.of(14, 0),
            Duration.ofHours(1),
            new MonthlyPlan(DayOfWeek.MONDAY, 2));
    }
    // 이제 몇번을 호출하더라도 값은 같음
    assertThat(schedule.includes(LocalDate.of(2025, 1, 16))).isFalse();
    assertThat(schedule.includes(LocalDate.of(2025, 1, 16))).isFalse();
    assertThat(schedule.includes(LocalDate.of(2025, 1, 16))).isFalse();
    assertThat(schedule.includes(LocalDate.of(2025, 1, 16))).isFalse();

    schedule.adjust(LocalDate.of(2025, 1, 16));

    assertThat(schedule.includes(LocalDate.of(2025, 1, 16))).isTrue();
    assertThat(schedule.includes(LocalDate.of(2025, 1, 16))).isTrue();
    assertThat(schedule.includes(LocalDate.of(2025, 1, 16))).isTrue();
    assertThat(schedule.includes(LocalDate.of(2025, 1, 16))).isTrue();
    
    
}
```

부수효과의 발생 여부에 따른 명령과 쿼리의 분리 -> 부수효과의 제어 단위를 클래스 단위로 확장. -> 불변 값객체 사용

## 명령- 쿼리 분리 원칙 관점에서의 값 객체
`값 객체의 모든 메서드는 쿼리 부수효과가 없으므로 클래스 내부 코드를 확인할 필요가 없음`

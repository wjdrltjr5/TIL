# 디미터 법칙과 묻지 말고 시켜라 원칙
## 캡슐화를 위한 두 가지 설계 원칙
- 묻지 말고 시켜라 : 잘못된 책임 할당 문제 해결
### 디미터 법칙 : 캡슐화 위반 문제 해결
- 협력하는 객체의 내부 구조를 모르고도 협력이 가능해야 함
- 결합도를 낮추기 위해 메시지 전송 대상을 제한
- 구조 변경에 의존하지 않는 설계
- 구조 변경을 캡슐화

모든 클래스 C와 C에 구현된 모든 메서드 M에 대해서, M이 메시지를 전송할 수 있는 모든 객체는 다음과 같아야 한다 :
- M의 인자로 전달된 클래스 (C 자체를 포함)
- C의 인스턴스 변수의 클래스

> M에 의해 생성된 객체나 M이 호출하는 메서드나 함수에 의해 생성된 객체, 전역 변수로 선언된 객체는 모두 M의 인자로 간주한다.

즉 클래스 내부의 메서드는 아래 조건을 만족하는 인스턴스에만 메시지를 전송해야 한다.
- this 객체 
- 메서드의 매개변수
- this의 속성
- this의 속성인 컬렉션의 요소
- 메서드 내에서 생성된 지역 객체

디미터의 다른 표현
- 낮선 자에게 말하지 말라
- 오직 인접한 이웃에게만 말하라
- 오직 하나의 도트만 사용하라

### 묻지 말고 시켜라 
여러분은 객체에게 원하는 작업을 이야기함으로써 명령을 전송해야 합니다. 우리는 객체의 상태를 묻고 결정을 나린 후에, 객체에게 무엇을 수행할지 지시하는 방식을 선호하지 않습니다.

호출자는 호출된 객체의 상태를 바탕으로 결정을 내린 후에 해당 객체의 상태를 변경해서는 안됩니다. 구현하고 있는 논리는 아마도 호출된 객체의 책임이지 호출하는 쪽의 책임은 아닐 것입니다. 객체 외부에서 결정을 내리는 것은 객체의 캡슐화를 위반하며, 버그가 발생하기 쉬운 환경을 만들게 됩니다.





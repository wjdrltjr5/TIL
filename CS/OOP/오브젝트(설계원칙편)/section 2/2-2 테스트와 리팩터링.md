# 테스트와 리팩터링

## 테스트와 리팩터링
외부 동작 변경 없이 내부 설계 개선(이해하고 유지보수하기 쉽게) 내부 구조를 변경하기 때문에 버그가 날 확률이 높다. 따라서 안전장치가 필요한데 바로 테스트

리택터링에서 동작이 변경됐다는건 버그가 발생했다는것 테스트가 있으면 동작이 변경되지 않았는지 검증하는게 쉽다.

안전하게 리팩토링 하려면 회귀테스트는 필수다. 리팩터링 전 테스트/ 후 테스트 실행

>리팩터링을 하기전에 먼저 테스트 코드를 만들어야 한다. 테스트를 자주 실행시켜라 컴파일 할때마다 테스트하고 적어도 하루에 한번 모든 테스트를 실행시켜라 - 마틴파울러

테스트 가능하게 설계하는 것은 매우 중요하다. 테스트 하기 쉽게 설계된것이 좋은 코드 하지만 이렇게 설계하는 것은 매우 어렵다.

잘 설계된 객체는 내부를 감추고 외부에서는 인터페이스로만 접근할 수 있도록 구현 (디미터의 법칙, 묻지말고 시켜라 ) 내부 상태에 직접 접근하도록 허용하면 안된다.

테스트 역시 변경하는 메시지와 값을 조회하는 메시지를 통해 상태 기반 테스트또는 상호 작용 기반 테스트를 실행한다.

테스트에서 가장 중요한것은 객체의 입력과 출력을 얼마나 쉽게 제어할 수 있느냐 제어하기 어렵다면 테스트를 작성하기 어렵거나 이해하기 어렵게 작성해야 한다.

## Game 예제
Game 객체를 테스트 하고자 하지만 키보드를 통해서 게임이 실행하는 구조, 스캐너역시 해당 객체 안에서 생성하고 있고 출력역시 해당 객체 안에서 실행하고 있기 때문에 테스트하기 어려운 구조(현재 코드는 키보드와 실시간으로 상호작용이 필요)

키보드 입력을 설정하고 콘솔 출력 결과를 확인하기위해 System 클래스 내부 상태 변경
```java
OutputStream output = new ByteArrayOutputStream();
System.setOut(new PrintStream(output)); // 화면 출력 결과를 output에 누적
System.setIn(new ByteArrayInputStream("go north\nquit\n".getBytes())); // 키보드를 통해 go north와 quit를 입력하는 것을 코드로 구현


@Test
public void move_north_passed(){
    OutputStream output = new ByteArrayOutputStream();
    System.setOut(new PrintStream(output)); 
    System.setIn(new ByteArrayInputStream("go north\nquit\n".getBytes()));

    Game game = new Game();
    game.run();

    assertThat(output.toString().split("\n")).containsSequence(
        "> 당신은 [다리]에 있습니다."
        .....
        "게임을 종료합니다. "
    );
}
```

테스트는 가능하게 되었지만 여젼히 테스트 자체가 이해하기 어렵고 관계를 파악하기 어렵다. 뿐만 아니라 변경된 상태가 유지되기 때문에 다른 테스트 케이스에도 영향을 받는다.

이와 같이 테스트는 리팩토링을 검증하는 역할 뿐 아니라 리팩토링을 해야하는 것들도 알려주는 척도가 된다. 클래스를 얼마나 쉽게 테스트할 수 있는지가 설계의 품질을 측정하는 중요한 척도가 된다.

테스트하기 어려운 코드를 만났다면 개선하라는 시그널이 된다.
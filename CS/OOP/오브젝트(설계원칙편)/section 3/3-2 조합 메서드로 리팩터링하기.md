# 조합 메서드로 리팩터링하기

## SLAP 단일 추상화 수준 원칙
```java
public void run(){
    welcome();
    play();
    farewell();
}
```

`메서드 내의 모든 코드는 동일한 추상화 수준에 위치해야 합니다.` 즉 메서드의 일부가 저수준의 데이터베이스 연결을 처리하고, 다른 부분은 고수준의 비즈니스 코드를 처리하며, 또 다른 부분은 웹 서비스 관련 코드를 처리하는 일이 없어야 합니다. 물론 이런 메서드는 켄트 백의 조합 메서드 규칙도 위반하게 됩니다.

## 추상화 수준에 다른 run 메서드 리팩토링
```java
 public void run() {
        System.out.println("환영합니다!");
        System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
        System.out.println(rooms[x + y * width].description());
        System.out.println("다음 명령어를 사용할 수 있습니다.");
        System.out.println("go {north|east|south|west} - 이동, quit - 게임 종료");

        Scanner scanner = new Scanner(System.in);

        running = true;
        while (running) {
            System.out.print("> ");
            String[] commands = scanner.nextLine().toLowerCase().trim().split("\\s+");
            switch (commands[0]) {
                case "go" -> {
                    switch (commands[1]) {
                        case "north" -> {
                            if (y - 1 < 0 || rooms[x + (y - 1) * width] == null) {
                                System.out.println("이동할 수 없습니다.");
                            } else {
                                y -= 1;
                                System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
                                System.out.println(rooms[x + y * width].description());
                            }
                        }
                        case "south" -> {
                            if (y + 1 >= height || rooms[x + (y + 1) * width] == null) {
                                System.out.println("이동할 수 없습니다.");
                            } else {
                                y += 1;
                                System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
                                System.out.println(rooms[x + y * width].description());
                            }
                        }
                        case "east" -> {
                            if (x + 1 >= width || rooms[(x + 1 ) + y * width] == null) {
                                System.out.println("이동할 수 없습니다.");
                            } else {
                                x += 1;
                                System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
                                System.out.println(rooms[x + y * width].description());
                            }
                        }
                        case "west" -> {
                            if (x - 1 < 0 || rooms[(x - 1) + y * width] == null) {
                                System.out.println("이동할 수 없습니다.");
                            } else {
                                x -= 1;
                                System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
                                System.out.println(rooms[x + y * width].description());
                            }
                        }
                        default -> System.out.println("이해할 수 없는 명령어입니다.");
                    }
                }

                case "quit" -> running = false;
                default -> System.out.println("이해할 수 없는 명령어입니다.");
            }
        }

        System.out.println("\n게임을 종료합니다.");
    }
```

## 동일한 추상화 수준으로 나누기
### 1. 비슷한 목적을 가진 코드들을 함께 묶고 그위에 주석을 달기
```java
 public void run() {
        // 환영 문구 출력
        System.out.println("환영합니다!");
        System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
        System.out.println(rooms[x + y * width].description());
        System.out.println("다음 명령어를 사용할 수 있습니다.");
        System.out.println("go {north|east|south|west} - 이동, quit - 게임 종료");

        // 게임 플레이
        Scanner scanner = new Scanner(System.in);
        running = true;
        while (running) {
            System.out.print("> ");
            String[] commands = scanner.nextLine().toLowerCase().trim().split("\\s+");
            switch (commands[0]) {
                case "go" -> {
                    switch (commands[1]) {
                        case "north" -> {
                            if (y - 1 < 0 || rooms[x + (y - 1) * width] == null) {
                                System.out.println("이동할 수 없습니다.");
                            } else {
                                y -= 1;
                                System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
                                System.out.println(rooms[x + y * width].description());
                            }
                        }
                        case "south" -> {
                            if (y + 1 >= height || rooms[x + (y + 1) * width] == null) {
                                System.out.println("이동할 수 없습니다.");
                            } else {
                                y += 1;
                                System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
                                System.out.println(rooms[x + y * width].description());
                            }
                        }
                        case "east" -> {
                            if (x + 1 >= width || rooms[(x + 1 ) + y * width] == null) {
                                System.out.println("이동할 수 없습니다.");
                            } else {
                                x += 1;
                                System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
                                System.out.println(rooms[x + y * width].description());
                            }
                        }
                        case "west" -> {
                            if (x - 1 < 0 || rooms[(x - 1) + y * width] == null) {
                                System.out.println("이동할 수 없습니다.");
                            } else {
                                x -= 1;
                                System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
                                System.out.println(rooms[x + y * width].description());
                            }
                        }
                        default -> System.out.println("이해할 수 없는 명령어입니다.");
                    }
                }

                case "quit" -> running = false;
                default -> System.out.println("이해할 수 없는 명령어입니다.");
            }
        }
        // 작별 문구 출력
        System.out.println("\n게임을 종료합니다.");
    }
```

이제 주석들만 따로 보면 어떠한 역할을 하는지 알 수 있게 됨 이 주석들은 동일한 추상화 수준에서 진행됨
### 2. 주석으로 묶인 코드들을 메서드로 추출 (의도가 드러나는 이름 짓기)
가장 중요한것은 좋은 이름을 찾는것(클라이언트들의 의도를 드러내는이름)

```java
public void run() {
        welcome();
        play();
        farewell();
}

public void welcome(){
    System.out.println("환영합니다!");
    System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
    System.out.println(rooms[x + y * width].description());
    System.out.println("다음 명령어를 사용할 수 있습니다.");
    System.out.println("go {north|east|south|west} - 이동, quit - 게임 종료");
}

public void play(){
    Scanner scanner = new Scanner(System.in);
    running = true;
    while (running) {
        System.out.print("> ");
        String[] commands = scanner.nextLine().toLowerCase().trim().split("\\s+");
        switch (commands[0]) {
            case "go" -> {
                switch (commands[1]) {
                    case "north" -> {
                        if (y - 1 < 0 || rooms[x + (y - 1) * width] == null) {
                            System.out.println("이동할 수 없습니다.");
                        } else {
                            y -= 1;
                            System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
                            System.out.println(rooms[x + y * width].description());
                        }
                    }
                    case "south" -> {
                        if (y + 1 >= height || rooms[x + (y + 1) * width] == null) {
                            System.out.println("이동할 수 없습니다.");
                        } else {
                            y += 1;
                            System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
                            System.out.println(rooms[x + y * width].description());
                        }
                    }
                    case "east" -> {
                        if (x + 1 >= width || rooms[(x + 1 ) + y * width] == null) {
                            System.out.println("이동할 수 없습니다.");
                        } else {
                            x += 1;
                            System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
                            System.out.println(rooms[x + y * width].description());
                        }
                    }
                    case "west" -> {
                        if (x - 1 < 0 || rooms[(x - 1) + y * width] == null) {
                            System.out.println("이동할 수 없습니다.");
                        } else {
                            x -= 1;
                            System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
                            System.out.println(rooms[x + y * width].description());
                        }
                    }
                    default -> System.out.println("이해할 수 없는 명령어입니다.");
                }
            }
            case "quit" -> running = false;
            default -> System.out.println("이해할 수 없는 명령어입니다.");
        }
    }
}
public void farewell(){
        System.out.println("\n게임을 종료합니다.");
}
```

결과로 run 메서드는 추상화 수준이 동일한 조합메서드가 된다.

#### welcome() 메서드 나누기
```java
public void welcome(){
    // 인사말 출력
    System.out.println("환영합니다!");
    // 현재 방 출력
    System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
    System.out.println(rooms[x + y * width].description());
    // 도움말 출력
    System.out.println("다음 명령어를 사용할 수 있습니다.");
    System.out.println("go {north|east|south|west} - 이동, quit - 게임 종료");
}
```
다시 나누기
```java
private void welcome(){
    showGreetings();
    showRoom();
    showHelp();
}

private void showGreetings(){
    System.out.println("환영합니다!");
}

private void showRoom(){
    System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
    System.out.println(rooms[x + y * width].description());
}

private void showHelp(){
    System.out.println("다음 명령어를 사용할 수 있습니다.");
    System.out.println("go {north|east|south|west} - 이동, quit - 게임 종료");
}
```
이제 welcome 메서드도 조합메서드로 변경됨 이게 게임실행에 대한 과정을 쉽게 이해할 수 있고 더 자세한 정보를 알고싶다면 세부 메서드로 이동해서 확인하면 된다.

한 가지 작업(한가지 이유)만 할때까지 메서드를 추출하면 된다.


이런식으로 메서드를 나눈다면 재사용성이 올라가고 새로운 요구사항 반영도 수월하게 가능해진다.

#### play() 메서드 나누기
```java

public void play(){
    Scanner scanner = new Scanner(System.in);
    running = true;
    while (running) {
        System.out.print("> ");
        String[] commands = scanner.nextLine().toLowerCase().trim().split("\\s+");
        switch (commands[0]) {
            case "go" -> {
                switch (commands[1]) {
                    case "north" -> moveNorth();
                    case "south" -> moveSouth();
                    case "east" -> moveEast();
                    case "west" -> moveWest();
                    default -> System.out.println("이해할 수 없는 명령어입니다.");
                }
            }
            case "quit" -> running = false;
            default -> System.out.println("이해할 수 없는 명령어입니다.");
        }
    }
}

private void moveNorth(){
    if (y - 1 < 0 || rooms[x + (y - 1) * width] == null) {
        System.out.println("이동할 수 없습니다.");
    } else {
        y -= 1;
        System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
        System.out.println(rooms[x + y * width].description());
    }                
}
private void moveSouth(){
    if (y + 1 >= height || rooms[x + (y + 1) * width] == null) {
        System.out.println("이동할 수 없습니다.");
    } else {
        y += 1;
        System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
        System.out.println(rooms[x + y * width].description());
    }
}
private void moveEast(){
    if (x + 1 >= width || rooms[(x + 1 ) + y * width] == null) {
        System.out.println("이동할 수 없습니다.");
    } else {
        x += 1;
        System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
        System.out.println(rooms[x + y * width].description());
    }
}
private void moveWest(){
    if (x - 1 < 0 || rooms[(x - 1) + y * width] == null) {
        System.out.println("이동할 수 없습니다.");
    } else {
        x -= 1;
        System.out.println("당신은 [" + rooms[x + y * width].name() + "]에 있습니다.");
        System.out.println(rooms[x + y * width].description());
    }
}
```

#### 중복 코드 제거등
#### 의존성 고립
#### 또한 이렇게 메서드를 추출하다보면 또 위에 해당하는 내용이 발견 반복

[이러한 반복의 결과](https://github.com/wjdrltjr5/object-principle/blob/main/object-principle-03-02/src/main/java/org/eternity/adventure/Game.java)


### 3. 적절한 기준에 따라 메서드를 클래스로 분배 (책임의 이동)
책임의 이동의 2가지 방법
- 값객체 사용
- 단일 책임 원칙
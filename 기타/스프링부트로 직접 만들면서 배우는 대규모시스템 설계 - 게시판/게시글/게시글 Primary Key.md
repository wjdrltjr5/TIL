# 게시글 Primary Key

## Primary Key 선택

-   오름차순 유니크 숫자를 애플리케이션에서 직접 생성

    -   AUTO_INCREMENT 또는 UUID를 사용하지 않는다.
    -   추후에 이유 적기
    -   분산 시스템과 인덱스의 구조에 대한 이해가 필요 (Primary Key 생성 전략)

-   오름차순 유니크 숫자 알고리름
    -   Snowflake
    -   TSID
    -   ...

### Primary key 생성 전략

-   DB AUTO_INCREMENT
    -   분산 DB환경에서 PK중복될 수 있음
    -   두개의 샤드 or 파티션이 있을경우 id중복
    -   client에 정보 유출 가능성
    -   사용 예시
        -   보안적인 문제를 크게 고려하지 않는 상황
        -   단일 DB를 사용하거나 애플리케이션에서 PK의 중복을 직접 구분하는 상황
-   유니크 문자열 또는 숫자

    -   UUID or 난수 생성
        -   키생성 간단
    -   랜덤 데이터로 인해 성능 저하 발생

        -   Clustered Index는 정렬된 상태를 유지
        -   데이터 삽입시 인덱스 페이지가 가득 찼다면, B+ tree 재구성 및 페이지 분할로 디스크 I/O 증가
        -   PK를 이용한 범위 조회가 필요하다면 랜덤 I/O가 발생하기 때문에, 순차 I/O보다 성능 저하

-   유니크 정렬 문자열

    -   분산 환경 PK 중복 해결
    -   보안 문제 해결
    -   랜덤 데이터에 의한 성능 문제 해결
    -   UUID v7 , ULID 등 알고리즘 (128비트)
    -   데이터 크기에 따라 , 공간 및 성능 효율이 달라진다.
        -   Clustered Index는 PK를 기준으로 만들어진다.
        -   Secondary Index는 데이터에 접근할 수 있는 포인터를 가진다.(즉 PK를 가진다.)
        -   PK가 크면 클수록 공간 차지

-   유니크 정렬 숫자
    -   분산 환경에 대한 PK중복 문제 해결
    -   보안 문제 해결
    -   랜덤 데이터에 의한 성능 문제 해결
    -   Snowflake, TSID 등의 알고리즘 (64비트)
        -   정렬을 위해 타임스탬프를 나타내는 비트 수의 제한으로
            -   키생성을 위한 식나적인 한계가 있을 수 있다.
            -   문자열도 동일한 문제가 있지만 문자열은 비트수가 많다.
    -   적은 공간 차지

### Snowflake

-   X에서 개발
-   분산시스템에서 고유한 64비트 ID를 생성하는 알고리즘
    -   [1비트][41비트: 타임스탬프][10비트: 노드ID][12비트: 시퀀스 번호]
    -   분산 환경에서도 중복 없이 순차적 ID 생성하기 위한 규칙
        -   타임스탬프 : 순차성
        -   노드ID + 시퀀스 번호 : 고유성
-   유니크, 시간 기반 순차성, 분산환경에서의 높은 성능

-   [참고](https://f-lab.kr/insight/uuid-vs-snowflake-20241230)

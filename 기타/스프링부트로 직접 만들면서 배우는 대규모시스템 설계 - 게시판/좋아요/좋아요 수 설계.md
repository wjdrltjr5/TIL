# 좋아요 수 설계 (사실상 전체 게시글 수, 댓글 수도 마찬가지)

-   대규모 데이터에서 count 쿼리의 성능 이슈
    -   게시글과 달리 일부 카운트만 보여줄 수 없다.
-   전체 좋아요 개수를 실시간으로 빠르게 보여줘야 한다.
-   쓰기 트래픽이 비교적 크지 않다.
    -   사용자는 게시글을 조회하고, 마음에 드는 게시글을 찾는다.
    -   사용자는 좋아요 액션을 직접 수행한다.
-   데이터의 일관성이 비교적 중요하다.
    -   15명 좋아요 10명 표시 금지
    -   특히나 목록이 나온다면
-   쓰기 트래픽이 비교적 크지 않고 일관성이 중요하다면

    -   관계형 DB의 트랜잭션 활용
        -   좋아요 테이블의 생성/삭제와 좋아요 수 갱신을 하나의 트랜잭션으로 묶는것
        -   데이터베이스는 좋아요 테이블과 동일한 mysql을 사용한다.
    -   게시글 테이블의 컬럼으로 집계 컬럼 만들기

        -   제약  
            -Record Lock 행데이터에 락 발생
            -   쓰기작업에 의한 Lock (X, Exclusive Lock배타락 비관적)
            -   락 오래 점유시 리소스 고갈등 치명적
            -   게시글과 좋아요의 라이프 사이클이 다른데 서로 다른 주체에 대해서 동일한 레코드에 락이 잡힌다.
                -   좋아요 때문에 게시글 수정을 못한다던가..
            -   결론 : `집계 컬럼이 아닌 집계 테이블을 만든다.`

    -   결론에 따라 어디에 테이블을 만드는가
        -   MSA 지향환경에서 각 서비스 별로 독립적인 DB + 샤딩이 고려된 분산 데이터베이스 -> 분산 시스템
        -   좋아요 + 좋아요 수 데이터의 일관성 트랜잭션
            -   분산된 시스템에서 트랜잭션
                -   느리고 복잡
        -   좋아요서비스에 테이블 생성

## Record Lock 참고

-   MySQL의 InnoDB는 테이블의 레코드가 아닌 인덱스의 레코드를 잠근다는 것이 특징이다.

-   만약 사용자가 직접 추가한 where조건에 해당하는 인덱스가 없고 where조건이 기본키가 아닐때 모든 레코드의 락걸림

## 좋아요 수 동시성 문제

-   Record Lock 사용시 결국 계속 리소스 점유
-   동시성 처리 방법
    -   비관적 락(Pessimistic Lock)
    -   낙관적 락(Optimistic Lock)
    -   비동기 순차 처리

### 비관적 락(Pessimistic Lock)

-   비관적 관점 항상 충돌날 것이라고 가정 ex. Record Lock

```sql

-- 방법 1 (update시점에만 락 점유 상대적으로 짧다) sql문 직접 작성
update like_count set like_count = like_count + 1 where board_id = 1;

-- 방법 2 jpa사용시 엔티티객체로 조회  (조회시점 락 점유 상대적으로 길다)
select * from like_count where board_id = 1 for update;

update like_count set like_count = 3 where board_id = 1;
```

### 낙관적 락(Optimistic Lock)

-   낙관적 관점 변경여부를 확인후 충돌 처리
    -   롤백이나 재처리 (구현해야함)
    -   버전 사용

### 비동기 순차 처리

-   모든 상황을 실시간으로 처리하고 즉시 응답해줄 필요는 없다는 관점

    -   요청 대기열 저장 이후 비동기 순차적 처리
    -   게시글마다 1개의 스레드에서 순차적으로 처리하면 동시성문제 해결
    -   락으로 인한 지연이나 실패 케이스가 최소화된다.
    -   사용자 입장에서는 지연될 수 있다.

-   비용이 크다
    -   시스템 구축 비용
    -   실시간 응답 안되기 떄문에 클라이언트 측 추가 처리 필요
        -   이미 처리된것처럼 보이고 실패시 알람을 준다던지
    -   서비스 정책으로 납득이 되어야 한다.
    -   데이터의 일관성 관리를 위한 비용
        -   대기열에서 중복/누락 없이 반드시 1회 실행 보장 위한 시스템 구축 필요

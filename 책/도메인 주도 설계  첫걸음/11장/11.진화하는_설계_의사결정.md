# 진화하는 설계 의사결정

변경사항을 제대로 관리하지 않으면 아무리 정교하게 잘 설계했어도 결국에는 유지보수하고 개선하는 일이 악몽이 될 것이다. 소프트웨어 프로젝트 환경의 변화가 소프트웨어 설계 의사결정에 어떻게 영향을 미칠 수 있는지와 그에 따라 설계를 발전시키는 방법에 대해 설명할 것이다.

## 도메인 변경

-   핵심

    -   기업이 경쟁 우위를 확보하기 위해 경쟁자와 다르게 수행하는 활동

-   지원

    -   회사가 경쟁자와 다르게 하고 있지만 경쟁 우위를 제공하지 않는 활동

-   일반
    -   모든 회사가 같은 방식으로 하는 일

이전 장에서 실행 중인 하위 도메인 유형이 전략적 및 전술적 설계 의사결정에 영향을 미치는 것을 봤다.

-   바운디드 컨텍스트의 경계를 설계하는 방법
-   컨텍스트 간의 연동을 조율하는 방법
-   복잡한 비즈니스 로직을 다루기 위해 사용할 디자인 패턴

비즈니스 도메인의 요구사항에 따라 구동되는 소프트웨어를 설계하려면 비즈니스 하위 도메인과 해당 유형을 식별하는 것이 중요하다. 그러나 그것이 전부가 아니며, 하위 도메인의 진화에 주의를 기울이는 것도 마찬가지로 중요하다. 조직이 성장하고 발전함에 따라 일부 하위 도메인이 한 유형에서 다른 유형으로 변하는 것은 흔한 일이다.

### 핵심에서 일반으로

BuyIT이라는 온라인 소매 회사가 자체 주문 배송 솔루션을 구현했다고 상상해보자. 택배사의 배송 경로를 최적화하는 혁신적인 알고리즘을 개발하여 경쟁사보다 낮은 배송료를 청구할 수 있다.

어느 날 또 다른 회사인 DeliverIT이 배송 업계를 혼란에 빠뜨린다. '외판원 문제'를 해결했으며 경로 최적화 서비스를 제공한다고 주장한다. DeliverIT은 BuyIT보다 진보된 최적화 서비스를 구현했으며, 훨씬 더 저렴하게 같은 작업을 처리할 수 있는 서비스를 제공한다.

BuyIT관점에서 DeliverIT의 솔루션이 상용 제품으로 제공되면 핵심 하위 도메인이 일반 하위 도메인으로 바뀐다. 그 결과 BuyIT의 모든 경쟁업체가 최적의 솔루션을 사용할 수 있게 된다. 연구 개발에 막대한 투자 없이 BuyIT은 더 이상 경로 최적화와 하위 도메인에서 경쟁 우위를 확보할 수 없다.

이전에는 경쟁 우위로 간주했던 것이 모든 경쟁업체가 사용할 수 있는 상품이 된 것이다.

### 일반에서 핵심으로

BuyIT은 창립 이래 재고를 관리하기 위해 상용 솔루션을 사용해 왔다. 그러나 비즈니스 인텔리전스 보고서에 고객 수요에 대한 잘못된 예측이 계속해서 보이고 있다.

결과적으로 BuyIT은 가장 인기 있는 제품의 재고를 보충하지 못하고 인기 없는 제품에 창고 공간을 낭비하고 있다. 몇가지 대체 재고관리 솔루션을 평가한 후 경영진은 사내 시스템 설계 및 구축에 투자하기로 전략적 결정을 내린다. 이 사내 솔루션은 제품의 복잡성을 고려해 고객의 수요를 더 잘 예측한다.

상용 솔루션을 자체 구현으로 교체하기로한 BuyIT의 결정은 재고관리를 일반 하위 도메인에서 핵심 하위 도메인으로 바꿧다. 기능을 성공적으로 구현하면 BuyIT이 경쟁업체보다 추가로 경쟁 우위를 확보할 수 있다. 경쟁업체는 일반 솔루션에 머물러 있어서 BuyIT에서 개발한 고급 수요예측 알고리즘을 사용할 수 없게 된다.

일반 하위 도메인을 핵심 하위 도메인으로 전환한 기업의 좋은 예제는 아마존이다. 모든 서비스 제공업체와 마찬가지로 아마존은 서비스를 실행할 인프라가 필요했는데 회사는 물리적 인프라를 관리하는 방식을 재창조할 수 있었고 후에 AWS가 된다.

### 지원에서 일반으로

BuyIT의 마케팅 부서는 협력하는 공급업체와 계약을 관리하기 위한 시스템을 구현한다. 이 시스템에서 특별하거나 복잡한 내용은 없으며, 데이터를 입력하기 위한 일부 CRUD 사용자 인터페이스만 필요하다. 전형적인 지원 하위 도메인이다.

그러나 BuyIT이 사내 솔루션을 구현하기 시작한 몇 년 후 계약 관리 솔루션이 오픈소스로 나왔다. 이 오픈소스는 기존 솔루션과 같은 기능을 포함하며, OCR과 전문 검색과 같은 고급 기능을 제공한다. 이러한 추가 기능은 오랫동안 BuyIT의 백로그에 있 었지만 비즈니스에 미치는 영향이 적어서 우선순위로 지정되지 않았다. 따라서 회사는 사내 솔루션을 버리고 오픈소스 솔루션과 연동하기로 결정한다.

이렇게 하면 문서 관리 솔루션의 하위 도메인이 지원에서 일반 하위 도메인으로 바뀐다.

### 지원에서 핵심으로

지원 하위 도메인도 핵심 하위 도메인으로 전환될 수 있다. 회사에서 비용을 줄이거나 추가 수익을 창출하는 방식으로 지원로직을 최적화 하는 방법을 찾는 것이다.

이러한 전환의 일반적인 전조 현상은 하위 도메인의 비즈니스 로직이 점점 더 복잡해지는 것이다. 정의에 따르면 지원 하위 도메인은 단순하며 주로 CRUD 인터페이스 또는 ETL 프로세스와 유사하다. 그러나 시간이 지남에 따라 비즈니스 로직이 더 복잡해진다면 복잡성이 증가한 이유가 있을 것이다. 회사의 이익에 영향을 미치지 않는다면 왜 더 복잡해질까? 이런 경우가 우발적 비즈니스 복잡성이다. 반면 회사의 수익성이 개선된다면 지원 하위 도메인이 핵심 하위 도메인이 될 징조다.

### 핵심에서 지원으로

핵심 하위 도메인은 시간에 지남에 따라 지원 하위 도메인으로 전환될 수 있다. 이는 하위 도메인의 복잡성이 정당화 되지 않을때 발생할 수 있다. 다시 말해, 복잡성에 비해 수익성이 없는 경우다. 이러한 경우 조직은 다른 하위 도메인의 개발을 지원하는 데 필요한 최소한의 로직만 남겨두고 불필요한 복잡성을 줄이기로 결정할 수 있다.

### 일반에서 지원으로

마지막으로, 핵심 하위 도메인인과 같은 경우로 일반 하위 도메인이 지원 하위 도메인으로 바뀔 수 있다. BuyIT의 문서 관리 시스템 사레로 돌아가서, 회사가 오픈소스 솔루션과 통합 과정에서 복잡성 대비 얻는 이점을 정당화할 수 없다고 결정을 내려 다시 사내 개발시스템에 의존했다고 가정해보자. 그결과 일반 하위 도메인이 지원 하위 도메인으로 전환됐다.

## 전략적 설계 문제

하위 도메인 유형의 변경은 바운디드 컨텍스트에 직접적인 영향을 미치고 결과적으로 전략적 설계 의사결정에도 영향을 준다. 4장에서 배웠듯이 다양한 바운디드 컨텍스트 연동 패턴은 다양한 하위 도메인 유형을 수용한다. 예를 들어, 핵심 하위 도메인은 충돌 방지 계층을 사용해서 모델을 보호하고, 오픈 호스트 서비스를 사용하여 구현 모델의 빈번한 변경으로부터 사용자를 보호해야 한다.

이러한 변경의 영향을 받는 또 다른 통합 패턴은 분리형 노선이다. 앞서 봤듯이 지원 하위 도메인과 일반 하위 도메인에 이 패턴을 사용할 수 있다. 하위 도메인이 핵심 하위 도메인으로 변형되는 경우 여러 팀에서 해당 기능을 복제하는 것은 더이상 허용되지 않는다. 따라서 해당 팀들은 그들의 솔루션을 이 핵심 하위 도메인과 연동할 수 밖에 없다. 핵심 하위 도메인은 한 팀에서만 구현되기 때문에 이 경우 사용자-제공자 관계가 적합하다.

구현 전략의 관점에서 핵심 하위 도메인과 지원 하위 도메인은 구현 방법이 다르다. 지원 하위 도메인은 외부에 위탁하거나 신규 입사자를 위한 훈련용 도구로 사용할 수 있다. 핵심 하위 도메인은 가능하면 도메인 지식의 원천에 최대한 가깝게 하기 위해 사내에서 구현해야 한다. 따라서 지원 하위 도메인을 핵심 하위 도메인으로 전환하면, 해당 솔루션은 사내에서 개발돼야 한다. 같은 논리가 반대로도 작동한다. 핵심 하위 도메인을 지원 하위 도메인으로 전환하면 사내 R&D팀이 핵심 하위 도메인에 집중할 수 있도록 해당 솔루션 개발을 외부에 위탁할 수 있다.

## 전술적 설계 문제

하위 도메인의 유형 변경을 나타내는 주요 지표는 기존의 기술적 설계가 현재 비즈니스 요구를 지원할 수 없는 경우다.

지원 하위 도메인이 핵심 하위 도메인이 되는 예로 돌아가 보자. 지원 하위 도메인은 비즈니스 로직을 모델링하기 위해 비교적 단순한 디자인 패턴, 즉 트랜잭션 스크립트 또는 액티브 리코트 패턴으로 구현한다. 5장에서 봤듯이 이러한 패턴은 복잡한 규칙과 불변성을 가진 비즈니스 로직에는 적합하지 않다.

시간이 지남에 따라 복합한 규칙과 불변성이 비즈니스 로직에 추가되면 코드베이스도 점점 더 복잡해질 것이다. 기존 설계가 이렇게 복잡한 로직을 지원하지 않아서 새로운 기능을 추가하는 것은 고통스러운 일이 된다. 이 '고통'은 중요한 신호다. 비즈니스 도메인과 설계 의사결정을 재평가하기 위한 신호가 된다.

구현 전략에 변화가 필요하다는 것은 두려운 것이 아니다. 이러한 변화는 자연스러운 일이다. 우리는 비즈니스가 앞으로 어떻게 발전할지 예층할 수 없다. 또한 모든 유형의 하위 도메인에 가장 정교한 디자인 패턴을 적용할 수도 없다. 그것은 낭비고 비효율적이다. 현 상황에서 가장 적합한 설계 방식을 선택하고 필요할 때 개선해야 한다.

비즈니스 로직을 모델링하는 방법을 의도적으로 결정하고, 가능한 모든 설계 옵션이 무엇인지 알고, 이들 사이의 차이점도 알고 있다면 현재 디자인 패턴에서 다른 디자인 패턴으로 마이그레이션하는 것도 어려운 일이 아니다.

### 트랜잭션 스크립트에서 액티브 레코드로

기본적으로 트랜잭션 스크립트와 액티브 레코드 패턴은 모두 절차지향 스크립트를 사용하여 비즈니스 로직을 구현한다. 그러나 이들은 자료구조를 모델링하는 방식에 차이가 있다. 액티브 레코드 패턴은 저장 장치에 매핑하면서 발생하는 복잡성을 자료구조로 사용하여 캡슐화 한다.

결과적으로 트랜잭션 스크립트에서 데이터 작업이 어려워지면 그것을 액티브 레코드 패턴으로 리팩터링하자. 복잡한 자료구조를 찾아 액티브 레코드 객체에 캡슐화한다. 데이터 베이스에 직접 접근하는 대신 액티브 레코드를 사용하여 모델과 구조를 추상화 한다.

### 액티브 레코드에서 도메인 모델로

액티브 레코드를 조작하는 비즈니스 로직이 점점 더 복잡해지고 불일치 및 중복 사레가 많아진다면 모데인 모델 패턴으로 리팩터링 하자.

VO를 식별하는 것으로 시작하라. 불변 객체로 모델링할 수 있는 자료구조는 무엇일까? 관련된 비즈니스 로직을 찾아 밸류 오브젝트의 일부로 만들어라.

다음으로 자료구조를 분석하고 트랜잭션 경계를 찾아라. 모든 상태 수정 로직이 명시적임을 확인하려면 액티브 레코드 내부에서만 수정할 수 있게 모든 액티브 레코드의 setter를 private로 만든다. 이러면 컴파일이 실패할 것이다. 하지만 컴파일 오류는 상태 수정 로직이 있는 위치를 명확하게 한다. 액티브 레코드의 경계로 리팩토링한다. 예를 들면 다음 코드와 같다.

```C#
public class Player
{
    public Guid Id { get; set; }
    public int Points { get; set; }
}

public class ApplyBonus
{
    // ...

    public void Execute(Guid playerId, byte percentage)
    {
        var player = _repository.Load(playerId);
        player.Points *= 1 + percentage/100.0;
        _repository.Save(player);
    }
}
```

다음 코드에서 변환하기 위한 첫 번째 단계의 코드를 볼 수 있다. 코드는 아직 컴파일 되지 않았지만 오류가 발생하면 외부 컴포넌트가 객체 상태를 제어하는 위치를 명시적으로 보여준다.

```C#
public class Player
{
    public Guid Id { get; private set; }
    public int Points { get; private set; }
}

public class ApplyBonus
{
    // ...

    public void Execute(Guid playerId, byte percentage)
    {
        var player = _repository.Load(playerId);
        player.Points *= 1 + percentage/100.0;
        _repository.Save(player);
    }
}
```

다음 리팩터링 이터레이션에서는 액티브 레코드의 경계 내부로 해당 로직을 이동할 수 있다.

```C#
public class Player
{
  public Guid Id {get; private set;}
  public int Points {get; private set;}

  public void ApplyBonus(int percentage){
    this.Points *= 1 + percentage/100.0;
  }
}
```

모든 상태 수정 비즈니스 로직이 그에 상응하는 객체의 경계 내부로 이동할 떄 비즈니스 규칙과 불변성을 지속적으로 확인하기 위해서 어떤 계층이 필요한지 검토하라. 그것은 애그리게이트의 좋은 후보다.

6장에서 논의한 애그리게이트 설계 원칙을 염두에 두고 가장 작은 트랜잭션 경게, 즉 강한 일관성을 유지하는 데 필요한 최소 데이터를 찾아라. 해당 경계를 따라 계층을 분해하고, 외부 애그리게이트가 해당 ID로만 참조되게 한다.

마지막으로 각 애그리게이트에 대해 루트 또는 퍼블릭 인터페이스의 앤드포인트를 식별한다. 애그리게이트에 있는 다른 모든 내부 객체의 메서드를 private로 만들어서 애그리게이트 내에서만 호출 가능하게 한다.

### 도메인 모델에서 이벤트 소싱 도메인 모델로

애그리게이트 경계가 적절하게 설계된 도메인 모델이 있으면 이벤트 소싱 모델로 전환할 수 있다. 애그리게이트의 데이터를 직접 수정하는 대신 애그리게이트의 수명주기를 나타내는 데 필요한 도메인 이벤트를 모델링한다.

도메인 모델을 이벤트 소싱 도메인 모델로 리팩터링할 때 가장 어려운 점은 기존 애그리게이트의이력이다.

즉, '이력이 없는' 상태를 이벤트 기반 모델로 마이그레이션 하는 것이다. 모든 과거상태 변경을 나타내는 세분화된 데이터가 없기 때문에 최선의 방법으로 과거 이벤트를 생성하거나 마이그레이션 이벤트를 모델링 해야 한다.

### 전환에 필요한 과거 이력 생성

이 방법은 각 애그리게이트를 위한 대략적인 이벤트 스트림을 생성해서, 변환된 모델이 생성된 이벤트 스트림을 프로젝션해서 원래 구현과 동일한 상태를 나타내게 한다.

비즈니스 로직 관점에서 다음과 같이 애그리게이트의 인스턴스가 초기화 되었다고 가정해보자. 그런 다음, 그 사람에게 연락이 와서 주문이 완료되었으며 마지막 상태가 'converted'이므로 주문에 대한 결제가 확인됐다. 다음의 이벤트 집합은 이러한 모든 과정을 나타낸다.

```json
[
	{
		"lead-id": 12,
		"event-id": 0,
		"event-type": "lead-initialized",
		"first-name": "Shauna",
		"last-name": "Mercia",
		"phone-number": "555-4753"
	},
	{
		"lead-id": 12,
		"event-id": 1,
		"event-type": "contacted",
		"timestamp": "2020-05-27T12:02:12.51Z"
	},
	{
		"lead-id": 12,
		"event-id": 2,
		"event-type": "order-submitted",
		"payment-deadline": "2020-05-30T12:02:12.51Z",
		"timestamp": "2020-05-27T12:02:12.51Z"
	},
	{
		"lead-id": 12,
		"event-id": 3,
		"event-type": "payment-confirmed",
		"status": "converted",
		"timestamp": "2020-05-27T12:38:44.12Z"
	}
]
```

이러한 이벤트를 하나씩 적용하면 원래 시스템에서와 같이 정확한 상태 표현 방식으로 프로젝션 할 수 있다. 'recovered'이벤트는 상태를 반영하고 원본 데이터와 비교하여 쉽게 테스트할 수 있다.

그러나 이 접근 방식의 단점도 염두에 두는 것이 중요하다. 이벤트 소싱을 사용하는 목표는 애그리게이트의 도메인 이벤트에 대해 안정적이고 강한 일관성을 가진 이력을 보유하는 것이다. 그런데 이같은 접근 방식을 사용하면 상태 전환의 전체 히스토리를 복구하는 것은 불가능하다. 앞의 예제에서 영업 담당자가 그 사람에게 연락한 횟수를 알지 못하므로 우리가 놓친 'contacted' 이벤트가 몇 개인지도 알 수 없다.

### 마이그레이션 이벤트 모델링

대안으로는 과거 이벤트에 대한 지식 부족을 인정하고, 명시적으로 이벤트를 모델링하는 방법이다. 현재 상태로 이어질 수 있는 모든 이벤트를 복구하는 대신 마이그레이션 이벤트를 정의하고 기존 애그리게이트 인스턴스의 이벤트 스트림을 초기화 한다.

```
{
    "lead-id": 12,
    "event-id": 0,
    "event-type": "migrated-from-legacy",
    "first-name": "Shauna",
    "last-name": "Mercia",
    "phone-number": "555-4753",
    "status": "converted",
    "last-contacted-on": "2020-05-27T12:02:12.51Z",
    "order-placed-on": "2020-05-27T12:02:12.51Z",
    "converted-on": "2020-05-27T12:38:44.12Z",
    "followup-on": null
}
```

이 방식의 장점은 과거 데이터의 부족함을 명확히 한다는 것이다. 즉, 어떤 단게에서 그 누구도 이벤트 스트림이 애그리게이트 인스턴스의 수명주기 동안 발생한 모든 도메인 이벤트를 포착한다는 잘못된 추측을 할 수 없다. 단점은 레거시 시스템의 흔적이 이벤트 스토어에 영원히 남는다는 것이다. 예로 CQRS 패턴을 사용하는 경우(그리고 이벤트 소싱 도메인 모델을 사용하는 경우) 항상 마이그레이션 이벤트를 고려해서 프로젝션 해야 한다.

## 조직변화

시스템 설계에 영향을 줄 수 있는 또 다른 변화의 유형은 조직 자체의 변화다. 4장에서 파트너십, 공유 커널, 순응주의자, 충돌 방지 계층, 오픈 호스트 서비스, 분리형 노선과 같은 바운디드 컨텍스트 연동의 다양한 패턴을 살펴봤다. 조직 구조의 변화는 팀 의사소통 및 협업 수준에 영향을 미치고 결과적으로 바운디드 컨텍스트를 통합하는 방식에 영향을 준다.

### 파트너십에서 사용자-제공자로

파트너십 패턴은 팀 간의 강력한 의사소통과 협업을 전제로 한다. 시간의 지남에 따라 이런 전제가 없어질 수 있다.

### 사용자-제공자에서 분리형 노선으로

지리적 거리나 내부 정치로 의사소통 문제가 발생한다면 계속해서 서로의 꼬리를 쫒는 대신 기능을 복제하는 것이 더 비용 효과적일 수 있다.

## 도메인 지식

도메인 주도 설계의 핵심 신조는 성공적인 소프트웨어 시스템을 설계하는 데 도메인 지식이 반드시 필요하다는 것이다. 소프트웨어 엔지니어링에서 도메인 지식을 습득하는 것은 특히 핵심 하위 도메인의 경우 가장 어려운 측면 중 하나다. 핵심 하위 도메인은 로직이 복잡할 뿐만 아니라 자주 변경될 것으로 예상된다.

또한 모델링은 지속적인 과정이다. 비즈니스 도메인에 대한 더 많은 지식을 습득함에 따라 모델을 개선해야 한다.

비즈니스 도메인의 복잡성은 잘 드러나지 않을 때가 많다. 처음에는 모든 것이 간단하고 쉬워보인다.

전략적 설계 관점에서 볼 때 도메인 지식 수준에 따라 바운디드 컨텍스트의 경계를 설계하는 것은 유용한 휴리스틱이다.

시스템을 잘못된 바운디드 컨텍스트로 분해하면 시간이 지날수록 유지보수 비용이 증가한다. 따라서 도메인 로직이 불명확하고 자주 변경되는 경우 바운디드 컨테스트를 더 넓은 경게로 설계하는 것이 합리적이다.

시간에 지남에 따라 도메인 지식이 발견되고 비즈니스 로직의 변경사항이 안정화됨에 따라 이러한 넓은 바운디드 컨테스트는 더 좁은 바운디드 컨텍스트 또는 MSA로 분해될 수있다.

새로운 도메인 지식이 발견되면 이를 활용하여 설계를 발전시키고 회복성을 높여야 한다.

불행히도 도메인 지식의 변화가 항상 긍정적인 것은 아니다. 도메인 지식이 손실될 수 있기 때문이다. 시간이 지남에 따라 문서는 종종 부실해지고 원래 설계했던 사람들은 회사를 떠나고 등등 코드베이스는 의심스러운 상태의 레거시 시스템이 되어 버리고 만다. 이러한 도메인 지식의 퇴보를 사전에 방지하는 것은 중요하다. 도메인 지식을 복구하는 효과적인 도구는 이벤트 스토밍 워크숍이다.

## 성장

시스템의 발전에는 어두운 면이 따라온다. 소프트웨어 프로젝트가 성장함에 따라 해당 코드베이슨느 커다란 진흙 덩어리로 성장할 수 있다.

커다란 진흙 덩어리를 초래하는 규제 없는 성장은 설계의 의사결정을 재평가하지 않고 소프트웨어 시스템의 기능을 확장한 결과다. 성장은 구성요소의 경계를 허물고 점점 더 기능을 확장한다. 특히 많은 도메인 주도 설계 도구가 비즈니스 구성요소(하위도메인), 모델(바운디드 컨텍스트), 불변성(VO), 일관성(애그리게이트)와 같은 경계 설정에 관한 것이기 때문에 성장이 설계 의사결정에 미치는 영향을 조사하는 것은 중요하다.

성장에 따른 복잡성을 다루는 기본 원칙은 우발적 복잡성, 즉 오래된 설계의 결정으로 발생하는 복잡성을 식별하고 제거하는 것이다.

비즈니스 도메인의 본질적인 복잡성 또는 고유한 복잡성은 도메인 주도 설계 도구와 관행을 사용해여 관리해야 한다.

### 하위 도메인

하위 도메인의 경계는 식별하기 어려울 수 있으며, 결과적으로 완벽한 경계를 찾기 위해 노력하는 대신 유용한 경계를 찾기 위해 노력해야 한다.

하위 도메인을 통해 다양한 비즈니스 가치의 구성요소를 식별하고 적절한 도구를 사용해서 솔루션을 설계하고 구현할 수 있어야 한다.

비즈니스 도메인이 성장함에 따라 하위 도메인의 경계가 훨씬 더 흐려질 수 있기에 여러 개로 세분화된 하위 도메인에 걸쳐 있는 하위 도메인은 실별하기가 더 어려워 진다.

이미 식별된 하위 도메인을 다시 확인하고 응집된 유스케이스에서 휴리스틱을 활용하여 하위 도메인을 나누는 지점을 다시 식별하는 것이 중요하다.

다양한 유형의 세분화된 하위 도메인을 식별할 수 있다면 비즈니스 도메인의 본질적인 복잡성을 관리할 수 있는 중요한 통찰력을 보여줄 수 있다. 하위 도메인과 해당 유형에 대한 정보가 정확할수록 각 하위 도메인에 대한 기술 솔루션을 효과적으로 선택할 수 있다.

추출하고 명시적으로 만들 수 있는 내부 하위 도메인을 식별하는 것은 핵심 하위 도메인에 특히 중요하다. 비즈니스 전략 관점에서 가장 중요한 부분에 노력을 투자할 수 있도록 항상 모든 하위 도메인에서 핵심 하위 도메인을 최대한 추출하는 것을 목표로 삼아야 한다.

### 바운디드 컨텍스트

프로젝트가 발전하고 성장함에 따라 바운디드 컨텍스트가 초점을 읽고 다양한 문제와 관련된 로직이 늘어나는 것은 흔한 일이다. 그것은 우발적 복잡성이다.

하위도메인과 마찬가지로 바운디드 컨텍스트로 경계를 때때로 다시 살펴보는 것은 중요하다. 특정 문제를 해결하는 데 초점을 맞춘 바운디드 컨텍스트를 추출하여 모델을 단순화할 수 있는 기회를 항상 찾아라.

다른 바운디드 컨텍스트를 호출하지 않고는 작업을 완료할 수 없게 되었을때 이는 비효율적인 모델의 강력한 신호일 수 있으며, 바운디드 컨텍스트의 경계를 재설계하여 바운디드 컨텍스트 각각의 자율성을 높여야 한다.

### 애그리게이트

**경험상 애그리게이트는 가능한 작게 유지하고, 비즈니스 도메인에서 강력하게 일관적인 상태를 유지해야 하는 객체만 포함한다.**

비즈니스 요구사항이 증가함에 따라 애그리게이트를 작게 유지한다는 원칙을 떠올리지 않고 이미 있는 애그리게이트에 새로운 기능을 배포하는 것이 편할 수 있다. 비즈니스 로직에 따라 강력하게 일관성을 유지할 필요가 없는 데이터까지 포함되면서 애그리게이트가 커진다면 이는 제거해야 하는 우발적 복잡성으로 봐야 한다.

비즈니스 기능을 전담 애그리게이트로 추출하면 원래 애그리게이트가 단순해질 뿐 아니라 잠재적으로 애그리게이트가 속한 바운디드 컨텍스트도 단순해 진다.

## 결론

비즈니스 도메인이 발전함에 따라 하위 도메인에 대한 변경사항을 식별하고 시스템 설계에서 조치를 취해야 한다. 과거의 설계 의사결정이 비즈니스 모데인과 하위 도메인의 현재 상태에 부합하는지 확인하라. 필요한 경우 현재 비즈니스 전략과 요구상에 더 잘맞게 설계를 발전시켜라.

상황에 따라 협력, 통합 방식에 영향을 줄 수 있다.

-   하위 도메인의 기능이 확장되면 더 나은 설계 의사결정을 내릴 수 있도록 더 세분화된 하위 도메인 경계를 식별하려고 노력하라.

-   여러 방면에 다재다능한 바운디드 컨텍스트가 되는 것을 허용하지 마라. 바운디드 컨텍스트에 포함된 모델이 특정 문제를 해결하는 데 중점을 두고 있는지 확인하라.

-   애그리게이트의 경계가 가능한 한 작은지 확인하라. 확실하게 일관된 데이터의 휴리스틱을 사용하여 비즈니스 로직을 새 애그리게이트로 추출할 가능성을 탐지하라.

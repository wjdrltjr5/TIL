# 자바 기술 시스템 소개

## 1.1 들어가며

자바에는 엄격한 구조를 갖춘 객체지향 프로그래밍 언어란 점 외에도 무시할 수 없는 장점이 많다.

대표적인 특징으로는

-   하드웨어 플랫폼이라는 족쇄를 제거하여 `한번 작성하면 어디서든 실행된다`라는 이상을 실현한다.

-   상당히 안전한 메모리 관리 시스템을 갖춘 덕에 메모리 누수 문제와 엉뚱한 메모리를
    가리키는 문제 대부분을 피할 수 있다.

-   런타임에 핫코드(빈번하게 실행되어 전체 성능에 영향을 크게 주는 코드)를 감지, 컴파일하고 최적화하여 자바 애플리케이션이 최상의 성능을 내도록 도와준다.

-   표준 API 자체가 풍부할 뿐 아니라 수많은 기업과 오픈 소스 커뮤니티에서 제공하는 다양한 기능의 서드 파티 라이브러리를 활용할 수 있다.

## 1.2 자바 기술 시스템

일반적으로 JVM 코틀린, 클로저(Clojure), JRuby, 그루비등 프로그밍 언어와 그외 관련 프로그램들도 자바 기술 시스템에 속하는 것으로 본다. 다음 요소들을 포괄한다.

-   자바 프로그래밍 언어
-   (다양한 하드웨어 플랫폼용) 자바 가상 머신 구현
-   클래스 파일 포맷
-   자바 클래스 라이브러리 API(표준 API)
-   다른 기업과 오픈 소스 커뮤니티에서 제공하는 서드 파티 클래스 라이브러리

이중 프로그래밍 언어, JVM, 자바 클래스 라이브러리를 묶어서 JDK라고한다.

자바 SE API, JVM, 배포 기술을 묶어 JRE라고 한다.
![alt text](1-1%20자바%20기술%20시스템의%20구성요소.png)

### 자바 기술시스템의 네 가지의 주요 제품군으로 구분할 수 있다.

활용 분야 또는 기술이 집중하는 핵심 비즈니스 관점의 분류

-   자바 카드 : 스마트 카드와 같은 소형기기 및 변조 방지 보안 칩 등에서 실행되는 자바 플랫폼

-   자바 ME : 휴대 전화, PDA 같은 모바일 기기에서 실행되는 자바 프로그램용 플랫폼. 자바 API를 간소화하고 모바일용 API를 추가했다. JDK 5까지는 J2ME라는 이름 (안드로이드와는 관련 없음)

-   자바 SE : 데스크톱 애플리케이션용 자바 플랫폼, 완전한 형태의 자바 핵심 API를 제공 JDK 5 까지는 J2SE라는 이름이었다.

-   자바 EE : 전사적 자원 관리(ERP), 경영 정보 시스템(MIS), 고객 관계 관리(CRM) 애플리케이션과 같은 다중 계층 구조로 이루어진 기업 규모 애플리케이션용 자바 플랫폼, 자바 SE API를 확장하고 배포 관련 기술도 제공한다. JDK 5까지는 J2EE 10부터는 자카르타EE로 개명

현재는 SE를 제외하고는 힘을 읽어 가고 있음

## 1.3 자바의 과거와 현재

## 1.4 자바 가상 머신 제품군

### 1.4.1 가상 머신의 조상 : 썬 클래식VM 와 이그잭트VM

썬 클래식 VM은 원시적이며 역할도 오래전에 끝이 났지만 `세계 최초의 상용 자바 가상 머신` 타이틀을 가지고 있다.

클래스 VM은 자바 코드를 인터프리터 방식으로 실행했다. JIT 컴파일러를 사용하려면 플러그인을 추가하면 됐는데 추가하는 순간. 가상머신의 실행 시스템 전체가 JIT 컴파일러에 넘어가는 구조 (즉 인터프리터는 더 이상 동작 x)

컴파일러를 사용하기 시작하면 코드 전체를 컴파일 해야 했기에 자칫하면 프로그램 응답속도가 너무 느려져 오래 걸리는 최적화 기법 사용이 불가능 했다. JIT컴파일러로 네이티브 코드를 만들어 냈음에도 C진영 보다 속도가 느려 '자바 언어는 느리다` 라는 인상에 자리 잡혔다.

이그젝트 VM은 클래식 VM의 효율성 문제를 해결한 가상머신이다. 핫스팟 검출, 2단계 JTI컴파일러, 컴파일러와 인터프리터 혼합모드를 갖추고 있어 현대적인 고성능 가상 머신의 프로토타입이라 할 수 있다.

이그젝트 VM 이름은 정확한 메모리 관리 기술에서 따왔다. `정확한 메모리 관리`란 가상머신이 메모리의 특정 위치에 있는 데이터의 구체적인 자료형을 알 수 있다는 뜻이다.

이정보는 GC시 Heap에 존재하는 데이터가 사용중인지 판단하는 전제 조건 이 덕분에 클래식 VM의 객체검색 방식에서 벗어나 핸들을 거쳐야 하는 간접 검색 부하가 줄어 실행 성능이 개선되었다.

하지만 핫스팟 VM이 나와 단명함

### 1.4.2 일인자: 핫스팟 VM

롱뷰 테크놀러지스라는 곳에서 개발되어 JDK의 기본 가상 머신이자 가장 널리 사용되는 자바 가상 머신 시작은 자바 언어용이 아니였음

핫스팟은 썬의 기존 상용 가상 머신의 장점(정확한 메모리 관리 등)을 계승하면서 새로운 기술적 진보를 많이 이루어 내었음

대표적인 기술로는 핫 코드 감지 컴파일 했을때 가장 효과를 크게 볼 수 있는 코드 영역을 런타임에 알아내어 JIT 컴파일러에 알려준다.

그러면 JIT컴파일러는 해당 코드를 메서드 단위로 컴파일 메서드가 자주 호출되거나 시간을 많이 잡아먹는 순환문이 있다면 JIT컴파일을 수행해 스택을 치환하는 것

런타임에 스택을 치환하는 기술을 온스택 치환(OSR)이라고 한다. 이런 방식으로 컴파일러와 인터프리터가 조화롭게 협력해 응답속도와 실행 성능 사이의 균형을 잡아준다.

컴파일 없이 즉시 실행한 다음 일부 코드만 백그라운드에서 컴파일하여 치환하는 방식

JIT 컴파일을 빨리 끝내야 한다는 압박이 줄어 더 복잡한 최적화 기법을 도입하여 고품질의 네이티브 코드를 만들어 낼 수 있게되었다.

### 1.4.3 가난한 집의 고운 딸: 모바일, 임베디드 VM

모바일과 임베디드 특화 JVM 자바 SE만큼 성공하지 못해 ME 제품군에 포함된 VM들은 핫스팟만큼 주목받지 못하였음

자바 ME의 큰시장은 안드로이드와 IOS가 양분해 버려 현재 죽어있음

임베디드 기기 시장에서 ME는 SE 임베디드와도 경쟁에서 밀렸다. 그래서 오라클은 임베디드 역할을 SE 임베디드로 편입하였음

### 1.4.4 이인자: BEA JRockit과 IBM J9 VM

한때 핫스팟과 함께 '세계 3대 상용 자바 가상 머신` 이라 불렸던 JVM들(썬과 오라클 개발 x)

#### JRockit

BEA JRockit은 서버애플리케이션에만 신경 써 프로그램 구동 시간은 우선순위에서 밀렸다

같은 이유로 인터프리터를 완전히 제거하고 모든 코드를 JIT컴파일러로 컴파일 하게 함

GC와 JMC 실패 처리 스위트 구현은 JVM중 최고 수준이었으나 오라클이 BEA를 인수하여 추가 개발은 자연스럽게 중단됨

#### J9

IBM J9은 오타와 연구소에서 진행한 스몰토크 가상 머신 프로젝트에서 확장되어 나왔다.

JRockit이 서버애플리케이션에만 신경 쓴 데 반해 J9은 핫스팟과 비슷한 목표를 두고 서버와 데스크톱을 모두 고려해 설계한 다용도 가상 머신

J9은 여전히 현역이며 핫스팟보다 역할별 모듈화가 잘 이루어져 있다. GC, JIT 컴파일러, 진단 모니터 등의 핵심 구성 요소들이 잘 추상화, 캡슐화 되어 있어서 다른 언어 플랫폼에서 사용할 수 있을 정도

공통요소들을 OMR이라는 독립 프로젝트로 만들어 루비나 파이썬용으로 빠르게 조립해 활용할 수 있도록 하고 오픈소스로 전환 후 이클립스 재단에 기부하여 현재는 이클립스 OMR, OpenJ9으로 관리됨

### 1.4.5 하드웨어와의 통합: BEA 리퀴드 VM 어줄 VM

특정 하드웨어 플랫폼에서만 구동되는 소프트웨어와 하드웨어가 통합된 VM

#### 리퀴드VM

리퀴드VM은 독자적인 하이퍼바이저 시스템 위에서 직접 실행된다. 다시말해 운영체제가 필요 없다. 스레드 스케줄링, 파일 시스템, 네트워크 통신등, 필요한 기능을 제공하는 전용 운영체제가 포함되어 있다.

스레드 스케줄링시 커널모드와 사용자 모드 전환이 필요없어 하드웨어 성능을 끌어 써서 자바 프로그램의 성능을 높인다. 역시 인수로 인해 개발중단

#### 어줄VM

어줄 시스템스라는 회사에서 핫스팟에 기초해 개발한 JVM 베가라는 하드웨어 시스템에서 구동됨

시간이 지나면서 경쟁령 저하로 인해 어줄 시스템스는 베가를 버리고 범용플랫폼인 징과 줄루(Zulu)제품군에 모든 노력을 쏟아부었다.

징VM은 옛 버전 핫스팟의 코드를 기초로 재개발된 고성능 자바 가상 머신 짧은 지연 시간과 빠른 구동 시간이 필요한 시나리오에서는 핫스팟보다 뛰어났다.

### 1.4.6 도전자: 아파치 하모니와 안드로이드 아트VM

### 1.4.7 성공도 실패도 아닌: 마이크로소프트 JVM

### 1.4.8 수많은 아이디의 각축전

-   KVM : 안드로이드 IOS 등장전 널리 쓰인 모바일 플랫폼
-   JCVM : 자바 가상 머신의 매우 작은 부분집합
-   스퀵 VM : 상당 부분을 자바코드로 구현한 임베디드 가상 머신
-   자바 인 자바 : 연구 목적의 가상 머신 자바 언어 자체를 자바로 구현하려고 한 메타순환 가상머신
-   맥신 VM : 자바 인 자바와 매우 비슷한 가상 머신
-   자이크스 RVM : IBM이 자바 가상 머신 기술을 연구하기 위해 시작한 프로젝트 메타순환 가상 머신
-   IKVM.NET : MS의 닷넷 프레임워크 기반 자바 가상 머신
    기타등등

## 1.5 자바 기술의 미래

### 1.5.1 언어 독립

이따근 자바를 대체할 언어라는 주제의 이야기를 볼 수 있다. 주인공은 코틀린, 고, 자바스크립트, 파이썬 등이 자주 언급된다.

2018년 4월 오라클 연구소는 그랄VM이라는 새로운 기술을 발표 `어디서든 더 빠르게 실행된다`라는 구호를 내세웠다.

그랄 VM은 핫스팟 가상 머신위에 구축된 크로스 언어 풀 스택 가상 머신이다. 자바 기반 가상언어들은 물론 다른 언어도 지원한다.

![alt text](./1-4%20그랄VM아키텍처.png)

오라클 연구소와 여러 미국 대학에서 수행한 최신 JIT컴파일 연구가 모두 그랄VM으로 마이그레이션되는 등 발전 간능성이 매우 높다.

언젠가 자바 언어나 핫스팟 VM이 대체된다면 현재 유력한 후보다.

### 1.5.2 차세대 JIT컴파일러

서버용 제품처럼 장기간 운용되는 애플리케이션에서는 핫 코드를 탐지하여 네이티브 코드로 컴파일한다. 이런 애플리케이션에서는 JIT 컴파일러의 출력 품질이 실행 효율을 크게 좌우한다.

핫스팟 가상 머신은 기본적으로 JIT컴파일러를 두 개 내장하고 있다.

-   클라이언트 컴파일러(C1 컴파일러) : 컴파일 속도가 빠른 대신 최적화를 적게하는 컴파일러

-   서버 컴파일러(C2 컴파일러) : 컴파일 속도는 느리지만 더 많은 최적화를 적용하는 컴파일러

여기에 인터프리터까지 포함하여 총 3개의 실행 매커니즘이 협력한다.

JDK 10부터는 그랄 컴파일러가 추가되었다. 그랄VM 프로젝트의 일환으로 만들어진 기술 C2 컴파일러를 대체할 목적으로 도입되었다.

그랄 컴파일러는 컴파일된 코드의 출력 품질은 더 좋게 유지하면서 개발 효율과 확장성 측면에는 C2보다 훨씬 좋다.

JDK 16 부터는 개발과 관리 효율을 높이고자 그랄컴파일러를 JDK에서 독립 그랄 VM으로 옮겼다.

그랄 컴파일러가 OpenJDK로 복귀한다는 소식이 있다.

### 1.5.3 네이티브를 향한 발걸음

MSA에서는 분할된 서비스 각각이 수십에서 수백GB의 메모리를 쓸 일이 없다.

자바는 구동 시간이 길고 최고성능을 내기까지 예열이 필요하다 MSA의 특성과는 정 반대 서버리스 아키텍처의 경우 이러한 모순이 더욱 두드러진다.

서브스트레이트VM은 그랄VM의 한 요소로 사전 컴파일된 네이티브 코드를 핫스팟 가상 머신 없이 실행하는 기술로

독자적인 예외 처리, 스레드 관리, 메모리 관리, 자바 네이티브 인터페이스 접근 메서키즘 등을 갖춘 극히 작은 런타임 환경이다.

서브스트레이트 VM은 `어디서든 더 빠르게 실행한다`는 비전을 실현하기 위한 마지막 퍼즐로 그랄VM이 무거운 런타임이란 부담을 버리고 여러 언어를 지원할 수 있게 해준다.

### 1.5.4 유연한 뚱뚱이

연이은 리팩터링과 개방을 거쳐 핫스팟 가상 머신은 시간의 침식으로부터 점점 자유로워지고 있다. 코드 복잡도와 덩치는 계속 커지고 있지만 아키텍처가 낡지는 않았다.

개방성과 확장성이 점점 좋아지면서 바깥세상과 연동하기 쉬운 플랫폼이 되었다.

### 1.5.5 언어 문법의 지속적인 개선

자바는 지속적으로 구문을 개선하고 있다.
ex. var, Switch Expressions, Text Blocks, Pattern Matching for instanceof, Records 등등

## 1.6 실전: 내손으로 빌드하는 JDK

자바 가상 머신의 내부 구현 원리를 엿볼 수 있는 가장 직접적인 길은 바로 JDK를 직접 컴파일하고 소스코드를 읽고 분석하고 디버깅해가며 동작을 보는것

### 1.6.1 소스 코드 하기

[OpenJDK에서 zip 파일 다운](https://jdk.java.net/java-se-ri/17)

### 1.6.2 시스템 요구 사항

빌드는 되도록 리눅스나 맥OS에서 진행하길 권한다. 툴체인과 필요한 라이브러리를 준비하기가 윈도우보다 훨씬 쉽기 때문

### 1.6.3 컴파일 환경 구축하기

### 1.6.4 컴파일하기

### 1.6.5 통합 개발 환경에서 소스 코드 디버깅하기

## 1.7 마치며

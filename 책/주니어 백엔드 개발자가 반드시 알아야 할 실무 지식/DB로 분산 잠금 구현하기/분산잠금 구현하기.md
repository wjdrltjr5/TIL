# 분산 잠금 구현하기
동시에 두 개 이상의 프로세스가 실행되더라도 그 중 하나의 프로세스, 하나의 스레드만 작업을 실행해야 하는 요구사항이 있다면 분산 잠금이 필요하다.

## 잠금 정보 저장 테이블
분산 잠금을 구현하기 위해 필요한 테이블 스키마는 다음과 같다. (레디스나 주키퍼 같은 기술을 사용할 수도 있지만 구조를 단순하게 유지하기 위해 RDB사용)

```sql
create table dist_lock(
    name varchar(100) primary key,
    owner varchar(100),
    expiry timestamp
) 
```
각 컬럼의 역할은 다음과 같다.
- name : 개별 잠금을 구분하기 위한 값으로 주요 키이다.
- owner : 잠금 소유자를 구분하기 위한 값으로 여러 스레드가 같은 이름으로 잠금을 시도할 때 충돌을 처리한다.
- expiry : 잠금 소유 만료 시간으로, 한 소유자가 오랜 시간 잠금을 소유하지 못하도록 한다.

## 분산 잠금 동작
분산 잠금이 필요한 스레드는 다음 절차에 따라 잠금을 획득한다.
- 트랜잭션을 시작한다.
- 선점 잠금 쿼리(for update)를 이용해 해당 행을 점유한다.
- 행이 없으면 잠금 테이블에 새로운 데이터를 추가한다.
- owner가 다른데 아직 expiry가 지나지 않았다면 잠금 획득에 실패한다.
- owner가 다른데 expiry가 지났다면 owner와 expire값을 변경한 후 잠금을 획득한다.
- owner가 같다면 expiry만 갱신한 후 잠금을 획득하낟.
- 트랜잭션을 커밋하고 소유 결과를 리턴한다.
- 트랜잭션 커밋에 실패하면 잠금 획득도 실패한다.

이 절차에 따라 잠금 소유에 성공했다면 원하는 기능을 실행하고 실패했다면 기능을 실행하지 않도록 구현하낟.

## DB 잠금 구현

잠금 소유자를 표현하는 LockOwner 타입
```Java
import java.time.LocalDateTime;

public record LockOwner(String owner, LocalDateTime expiry){
    public boolean isOwnedBy(String owner){
        return this.owner.equals(owner);
    }

    public boolean isExpired(){
        return expiry.isBefore(LocalDateTime.now());
    }
}
```

LockOwner 클래스는 현재 소유자가 누구인지 비교하기 위한 isOwnerBy() 메서드와 잠금이 만료됐는지 여부를 확인하는 isExpired() 메서드를 제공한다.

실제 잠금 로직은 DistLock 클래스에서 구현한다. 이 클래스를 사용해서 분산 잠금을 시도하는 코드는 다음과 같은 구조를 갖는다.

```java
DistLock lock = new DistLock(ds);
String owner = "owner1";
if(lock.tryLock("lockName", owner, Duration.ofMinutes(1))){
    // 잠금에 성공
    ... 코드 실행
}else{
    // 잠금에 실패
}
```


```java
import java.sql.DataSource;
import java.sql.*;
import java.time.Duration;
import java.time.LocalDateTime;

public class DistLock{
    private final DataSource dataSource;

    public DistLock(DataSource dataSource){
        this.dataSource = dataSource;
    }

    public boolean tryLock(String name, String owner, Duration duration){
        Connection conn = null;
        boolean owned;

        try{
            conn = dataSource.getConnection();
            conn.setAutoCommit(false);
            LockOwner lockOwner = getLockOwner(conn, name);
            if(lockOwner == null || lockOwner.owner() == null){
                // 아직 소유자가 없음 - 잠금 소유 시도
                insertLock(conn, name, owner, duration);
                owned = true;
            }else if(lockOwner.isOwnedBy(owner)){
                // 소유자가 같음 - 만료 시간 연장
                updateLockOwner(conn, name, owner, duration);
                owned = true;
            }else if(lockOwner.isExpired()){
                // 소유자가 다름 && 만료 시간 지남 - 잠금 소유 시도
                updateLockOwner(conn, name, owner, duration);
                owned = true;
            }else{
                // 소유자가 다름 && 만료 시간 안지남 = 잠금 소유 실패
                owned = false;
            }
            conn.commit();
        }catch(Exception e){
            owned = false;
            rollback(conn);
        }finally {
            close(conn);
        }
        return owned;
    }

    private LockOwner getLockOwner(Connection conn, String name) throws SQLException {
        try (PrepareStatement pstmt = conn.prepareStatement(
            "select * from dist_lock where name = ? for update"
        )){
            try(ResultSet rs = pstmt.executeQuery()){
                if(rs.next()){
                    return new LockOwner(
                        rs.getString("owner"),
                        rs.getTimestamp("expiry").toLocalDateTime());
                }
            }
        }
    
        return null;
    }

    private void insertLockOwner(
        connection conn, String name, String ownerId, Duration duration
    ) throws SQLException {
        try(PrepareStatement pstmt = conn.prepareStatement(
            "insert into dist_lock values (?, ?, ?)")){
                pstmt.setString(1, name);
                pstmt.setString(2, ownerId);
                pstmt.setTimestamp(3. getExpiry(duration));
                pstmt.executeUpdate();
            }
    }

    private static Timestamp getExpiry(Duration duration){
        return Timestamp.valueOf(
            LocalDateTime.now().plusSeconds(duration.getSeconds())
        );
    }

    private void updateLockOwner(
        Connection conn, String name, String owner, Duration duration) throws SQLException {
            try(PreparedStatement pstmt = conn.prepareStatement(
                "update dist_lock set owner = ?, expiry = ? where name = ?"
            )){
                pstmt.setString(1, owner);
                pstmt.setTimestamp(2, getExpiry(duration));
                pstmt.setString(3, name);
                pstmt.executeUpdate();
            }
        }

    private void unlock(String name, String owner){
        Connection conn = null;
        try{
            conn = dataSource.getConnection();
            conn.setAutoCommit(false);
            LockOwner lockOwner = getLockOwner(conn, name);
            if(lockOwner == null || !lockOwner.isOwnedBy(owner)){
                throw new IllegalStateException("no lock owner");
            }
            if(lockOwner.isExpired()){
                throw new IllegalStateException("lock is expired");
            }
            clearOwner(conn, name);
            conn.commit();
        }catch(SQLException e){
            rollback(conn);
            throw new RuntimeException("fail to unlock: " + e.getMessage());
        }finally{
            close(conn);
        }
    }

    private void clearOwner(Connection conn, String name) throws SQLException{
        try(PreparedStatement pstmt = conn.prepareStatement(
            "update dist_lock set owner = null, expire = null where name = ? "
        )){
            pstmt.setString(1,name);
            pstmt.executeUpdate();
        }
    }

    private void rollback(Connection conn){
        if(conn != null){
            try{
                conn.rollback();
            }catch(SQLException e){}
        }
    }

    private void close(Connection conn){
        if(conn != null){
            try{
                conn.setAutoCommit(false);
            }catch(SQLException ex){}

            try{
                conn.close();
            }catch(SQLException e){}
        }
    }
}
```


# 메시징
서로 다른 시스템 간에 비동기로 연동할 때 주로 사용하는 방식은 메시징 시스템을 사용하는 것이다.

시스템 A가 시스템 B에 데이터를 전달하고 싶을 때 시스템A는 전달할 데이터를 가진 메시지를 생성해서 메시징 시스템에 전송한다.

메시징 시스템은 메시지를 다시 시스템 B에 전달하고 시스템B는 전달받은 데이터를 이용해서 필요한 작업을 처리한다.

시스템A에서 시스템B를 직접 호출하는 것과 비교하면 구조가 더 복잡해졌지단 다른 이점을 얻을 수 있다.

- 두 시스템이 영향을 주지 않는다. 한 시스템이 트래픽이 갑자기 증가하면서 전송량이 많아지더라도 메시징 시스템에 일단 저장을 하고 상황에 맞게 메시지를 전달한다.

- 확장이 용이하다. 시스템A가 시스템C에도 데이터를 전송해야 한다고 했을때 메시징 시스템에 C를 추가하기만 하면 된다.



메시징 시스템 용오도 많이 사용되는 기술은 카프카, 래빗MQ, 레디스 pub/sub등이 있다.

카프카의 주요 특징들 
- 높은 처리량을 자랑한다 초당 백 만 개 이상의 메시지를 처리할 수 있다.
- 수평 확장이 용이하다. 서버(브로커) 파티션, 소비자를 늘리면 된다.
- 카프카는 메시지를 파일에 보관해서 메시지가 유실되지 않는다.
- 1개의 토픽이 여러 파티션을 가질 수 있는데, 파티션 단위로 순서를 보정한다. 하지만 토픽 수준에서는 순서를 보장할 수 없다.
- 소비자는 메시지를 언제든지 재처리할 수 있다.
- 풀(Pull)모델을 사용한다. 소비자가 카프카 브로커에서 메시지를 읽어 가는 방식이다.

래빗MQ의 주요 특징들
- 클러스터를 통해 처리량을 높일 수 있다. 단, 카프카보다 더 많은 자원을 필요로 한다.
- 메모리에만 메시지를 보관하는 큐 설정을 사용하면 장애 상황 시 메시지가 유실될 수 있다.
- 메시지는 큐에 등록된 순서대로 소비자에 전송된다.
- 메시지가 소비자에 전달됐는지 확인하는 기능을 제공한다.
- 푸시 모델을 사용한다. 래빗MQ 브로커가 소비자에 메시지를 전송한다. 소비자의 성능이 느려지면 큐에 과부하가 걸려 전반적으로 성능 저하가 발생할 수 있다.
- 다재 다능하다. AMQP, STOMP등 여러 프로토콜을 지원하고, 게시/구독 패턴뿐만 아니라 요청/응답, 점대점 패턴을 지원한다. 또한 우선순위를 지정해서 처리 순서를 변경할 수도 있다.

레디스 pub/sub의 주요 특징은 다음과 같다.
- 메모리를 사용하므로 지연 시간이 짧고, 래빗MQ 대비 처리량이 높다.
- 구독자가 없으면 메시지가 유실된다.
- 기본적으로 영구 메시지를 지원하지 않는다.
- 모델이 단순해서 사용하기 쉽다.

메시지가 유실되어도 상관없다면 레디스 pub/sub을 고려하자 다른 2개에 비해 사용법이 간단하고 적은 장비로 높은 성능을 낼 수 있다.

트래픽이 대량(초당 수십만에서 수백만)으로 발생한다면 카프카를 고려하자 트래픽 규모가 크지 않고 메시지를 정확하게 순서대로 소비자에 전달해야 하거나 AMQP나 STOMP프로토콜로 연동해야 한다면 래빗 MQ를 고려한다.

이외에 NATS, 액티브MQ, 로켓MQ, 펄사 등을 메시지 시스템으로 사용할 수 있다. 클라우드가 제공하는 메시징 시스템도 좋은 선택이 될 수 있다.

## 메시지 생성 측 고려사항
메시지를 생성할 때 고려할 점은 메시지 유실에 대한 것이다. 메시지 전송 과정에서 타임아웃이 발생할 수 있다. 타임아웃 문제는 생산자와 메시징 시스템 간의 네트워크 연결이 불안정하면 언제든지 발생할 수 있다.

이때의 오류 처리 방법은 크게 3가지가 있다.
- 무시한다.
    - 가장 쉬운 방법 메시지 용도에 따라 유실이 일부 허용될 수 있다.
- 재시도한다.
    - 메시지 전송을 재시도하는 과정에서 중복된 메시지가 전송될 수 있다. 메시징 시스템이 중복 수신을 방지하는 기능을 제공하지 않으면 메시지 소비자가 중복 메시지를 알맞게 처리해야 한다.
    - 메시지마다 고유 식별자를 사용하면 메시지 소비자가 중복 메시지 여부를 판단하는 데 도움이 된다.
- 실패 로그를 남긴다.
    - 실패 로그를 남긴 후 나중에 후처리를 하는데 사용한다. 실패 로그는 DB에 저장할 수도 있고 파일에 남길 수도 있다.

## 메시지 소비 측 고려 사항
메시지 소비자는 다음 2가지 이유로 동일 메시지를 중복해서 처리할 수 있다.
- 메시지 생산가자 같은 데이터를 가진 메시지를 메시징 시스템에 두 번 전송
- 소비자가 메시지를 처리하는 과정에서 오류가 발생해서 메시지 재수신

수신자 입장에서 동일 데이터를 가진 중복 메시지를 처리하는 방법은 메시지에 고유한 ID를 부여해서 이미 처리했는지 여부를 추적하는 것이다.

이 방식을 사용하려면 메시지 생산자는 메시지마다 고유한 ID를 부여해야 한다. 그래야 같은 메시지를 중복해서 발송할 때 동일한 메시지ID를 유지할 수 있기 때문이다.

메시지를 처리헀는지 여부는 DB 테이블에 기록하거나 메모리에 집합으로 관리하며 ㄴ된다. 메모리로 관리할 때는 메모리 부족 에러가 발생하는 것을 막기 위해 일정 개수의 메시지 ID만 유지한다.

메시지 재수신에 따른 중복 처리를 대응하는 방법은 멱등성을 갖도록 API를 구현하는 것이다. 

중복 메시지 처리와 함께 메시지 소비자를 구현할 때 고려할 점은 메시지를 잘 소비하고 있는지 모니터링 하는 것이다.

메시지 소비자의 처리 속도가 갑자기 느려지면 큐에 메시지가 계속 쌓이게 된다. 메시징 시스템에 따라 큐가 가득 차면 생산자가 메시지를 큐에 넣지 못하게 막는 상황도 발생할 수 있다.

소비자의 성능 저하가 생산자까지 영향을 줄 수 있는 것이다. 

## 메시지 종류 : 이벤트와 커맨드
메시지에는 크게 2종류가 있다. 하나는 이벤트이고, 다른 하나는 커맨드이다.

- 이벤트 : 이벤트는 어떤 일이 발생했음을 알려주는 메시지다. 
    - 주문함
    - 로그인에 실패함
    - 상품 정보를 조회함
    - 배송을 완료함

- 커맨드 : 커맨드는 무언가를 요청하는 메시지다.
    - 포인트 지급하기
    - 로그인 차단하기 
    - 배송 완료 문자 발송하기

### 궁극적 일관성
궁극적 일관성이란 최종적 인관성이나 결과적 일관성이라고도 하며 주로 분산 시스템에서 데이터 복제를 다룰 때 사용된다.

이 모델은 두 데이터 자장소 간의 일관성을 보장하기는 하지만 즉시가 아닌 일정 시간이 지난 후에야 일관성이 맞춰진다는 특징을 가진다. (즉 일시적으로는 데이터 불일치가 발생할 수 있다.)

비동기 메시징 방식도 이 궁극적일관성과 유사한 특성을 갖는다. 배송 서비스에서 배송 상태를 완료로 변경하더라도 해당 변경 내용이 메시지를 통해 주문 서비스로 전달되기 전까지는 주문 서비스의 상태는 여전히 배송 중일 수 있다. (이처럼 배송완료 메시지가 전파되기 전까지는 두 시스템 간의 상태가 서로 불일치할 수 있다.)



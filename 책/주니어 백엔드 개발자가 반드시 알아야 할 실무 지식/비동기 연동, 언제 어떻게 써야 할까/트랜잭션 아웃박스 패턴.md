# 트랜잭션 아웃박스 패턴
메시지 데이터 자체가 유실되지 않도록 보장하는 방법은 먼저 해당 데이터를 DB에 안전하게 저장해두는 것이다.

그 뒤 저장된 메시지를 읽어 메시징 시스템에 전송하면 된다. 이처럼 메시지 데이터를 DB에 보관하는 방식이 바로 트랜잭션 아웃박스 패턴의 핵심이다.

트랜잭션 아웃박스 패턴은 하나의 DB트랜잭션 내에서 다음 2가지 작업을 수행한다.
- 실제 업무 로직에 필요한 DB 변경 작업을 수행한다.
- 메시지 데이터를 아웃박스 테이블에 추가한다.

아웃박스 테이블에 쌓인 메시지 데이터는 별도의 메시지 중계 프로세스가 주기적으로 읽어서 메시징 시스템에 전송한다.

DB 트랜잭션 범위에서 아웃박스 테이블에 메시지 데이터를 추가하므로 메시지 데이터가 유실되지 않는다.

트랜잭션을 롤백하면 메시지 데이터도 함께 롤백되므로 잘못된 메시지 데이터가 전송될 일도 없다.

코드는 다음과 같은 형태를 갖는다.

```java
// 이 메서드를 주기적으로 호출해서 메시지를 전송
public void processMessages(){
    // 아웃박스 테이블에서 대기 메시지 데이터를 순서대로 조회함.
    List<MessageData> waitingMessages = selectWaitingMessages();

    for(MessageData m : waitingMessages){
        try{
            sendMessage(m); // 메시지를 전송함
            markDone(m.getId()); // 발송 완료 포시함
        }catch(Exception ex){
            handleError(ex); // 메시지 발송에 실패한 경우 후속 처리함
            break; // 에러가 났을 때 멈춤. 이유는 순서대로 발송하기 위함
        }
    }
}
```

발송 완료를 표시하는 방법은 2가지가 있다. 하나는 아웃박스 테이블에 발송 상태 컬럼을 두는 것

이 컬럼은 3가지 상태(발송 대기, 발송 완료, 발송 실패)를 갖는다. 발송 대기 상태를 갖는 데이터를 조회하고 발송에 성공하면 발송 완료로 변경하는 식이다.

발송 완료를 표기하는 또 다른 방법은 메시지 중계 서비스가 성공적으로 전송한 마지막 메시지 ID를 별도로 기록하는 방식이다.

보통은 발송 상태 컬럼을 두는 방식을 선호하지만(모니터링이 쉬움) 2개 이상의 메시지 중계 서비스가 하나의 아웃 박스 테이블을 함께 사용하는 환경이라면 각 중계 서비스가 고유하게 마지막 메시지 ID를 관리해야 하므로, 이경우에는 마지막 메시지 ID를 기록하는 방식이 더 작합할 수 있다.

## 아웃박스 테이블 구조

- id(big int) : 단순 증가값(PK), 저장된 순서대로 증가하는 값을 사용한다.
- messageId(varchar) : 메시지 고유 ID(고유키)
- messageType(varchar) : 메시지 타입
- payload(clob) : 메시지 데이터
    - JSON, XML 같은 형식
- status(varchar) : 이벤트 처리 상태
- failCount(int) : 실패 횟수
- occuredAt(timestamp) : 메시지 발생 시간
- processedAt(timestamp) : 메시지 처리 시간
- failedAt(timestamp) : 마지막 실패 시간


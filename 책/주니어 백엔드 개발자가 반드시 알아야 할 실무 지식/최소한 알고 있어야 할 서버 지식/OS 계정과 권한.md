# OS계정과 권한
서버 프로그램의 프로세스를 중지시켰다가 다시 실행했는데 제대로 프로세스가 구동되지 않은 적이 있다. 원인은 프로세스가 생성한 파일에 있었다.

직전에 root계정으로 프로세스를 구동했고 그 프로세스가 파일을 생성했다. 이후 일반 사용자 계정으로 프로세스를 다시 구동했지만 권한이 없어서 프로세스 시작과정에서 파일 수정에 실패하면서 프로세스는 비정상 종료됐다.

서버OS로는 리눅스를 많이 사용하므로 리눅스의 기본적인 계정과 권한 관리를 이해할 필요가 있다. root 계정은 OS를 설치하면 기본 생성되는 계정으로 모든 권한을 가진 관리자 계정이다. (보통 root 계정에 접근할 수 있는 인원에 제한을 둔다.)

보통 인프라 담당자만 root 계정 접근 권한을 갖고 나머지 개발자는 별도로 생성한 사용자 계정을 이용해서 서버에연결한다.

```
rm -rf
초보 시절에 자주 겪는 실수 중 하나는 지우지 말아야 할 파일을 삭제하는 것이다. 특정 디렉토리에 있는 모든 파일을 삭제하기 위해 rm -rf  명령어를 사용했는데 알고 보니 다른 디렉토리에서 명령어를 실행한 경우다. 여기에 root 계정 권한까지 더해지면 더 많은 파일을 삭제할 수 있어 실수했을 때의 여파가 더 크다.

그래서 파일을 삭제하기 전에는 항상 현재 디렉토리와 삭제 대상 파일 목록을 확인하는 습관들 들여야 한다.
```

리눅스는 계정과 함께 그룹 개념도 사용한다. 여러 계정을 하나의 그룹으로 묶어 권한을 관리할 수 있다. 다만 한 서버에 개발자용 계정을 여러 개 생성해서 사용하는 경우는 드물기 때문에 실제로 그룹 수준에서 권한을 관리한 경우는 거의 없다.
```shell
$ ./run.sh
-bash: ./run.sh : 허가 거부 
```

특정 파일을 실행했는데 다음과 같이 접근이 거부된 메시지를 받는다면 실행에 필요한 권한이 없는 것이다. 파일을 실행할 때 이런 접근 거부가 발생하는 이유는 보통 읽기 권한이나 실행 권한이 없기 때문이다.

파일이나 디렉토리에 대한 권한은 ls 명령어로할 수 있다. ls -l 명령어를 사용하면 파일 권한을 포함한 여러 정보를 확인할 수 있다.

- r : 읽기(Read) 권한
- w : 쓰기(Write) 권한
- x : 실행(eXecute) 권한

```shell
  파일권한      소유자   소유그룹 파일크기 마지막 수정시간 파일명
-rwxr--r--, 1 vagrant vagrant 28 11월 10 08:24 run.sh
```

위 내용 파일권한 예시
- rwx -> 소유자 권한
- r-- -> 그룹 권한
- r-- -> 다른 계정 권한

권한은 숫자로도 표현한다. 
- r -> 4
- w -> 2
- x -> 1

chmod로 권한을 변경할 때는 숫자 합을 이용할 수 있다. 읽기와 쓰기 권한을 부여하고 싶다면 읽기 권한 숫자 4와 쓰기 권한 숫자 2를 합한 6을 사용한다. 전체 권한을 부여하고 싶다면 7을 사용한다

소유자, 그룹, 다른 계정에 대한 권한을 숫자 3개로 지정하면 된다. 에를 들어 다음명령어는 run.sh파일에 대해 소유자는 모든 권한을 갖고, 그룹은 읽기와 실행, 다른 계정에는 읽기 권한만 부여한다.
> chmod 754 run.sh

습관적으로 chmod 777을 사용하지 말자.

숫자 대신 개별 항목에 대해 권한을 지정할 수도 있다. 다음 명령어는 소유자(u)에게 실행 권한(x)을 추가(+)한다.
> chmod u+x run.sh
- u 소유자
- g 그룹
- o 다른 사용자 
- a 모두
- \+ 추가
- \- 제거
- = 지정
- r 읽기 
- w 쓰기
- x 실행


## sudo로 권한 주기
일반적인 운영체제의 root 권한은 일부 인프라 담당자만 갖고 개발자는 일반 계정에 대한 권한만 갖는다. 하지만 개발자도 root 권한이 필요할 때가 있다. (systemctl로 아파치 서비스를 재시작 해야 하는 경우)

root 권한이 필요할 떄마다 매번 인프라 담당자에게 작업을 요청하면 업무 효율이 떨어진다. 반대로 개발자에게 root 권한을 부여하면 보안 측면에서 위험할 수 있다.

이때 사용할 수 있는게 sudo 명령어다. sudo 명령어를 사용하면 다른 사용자의 권한으로 프로그램을 실행할 수 있다.

sudo 명령어로 실행할 수 있는 명령어는 별도 설정 파일로 관리한다. 일반적으로 sudo 명령어과 관련된 설정은 /etc/sudoers 파일이나 /etc/sudoers.d 디렉토리에 위치한 파일로 관리한다.

/etc/sudoers 파일을 보면 다음 설정을 볼 수 있다.
> root ALL=(ALL) ALL

이설정은 앞에서부터 차례대로 다음을 뜻한다.
- root -> root 계정은
- ALL -> 모든 호스트에 대해 (실질적으로는 로그인한 서버)
- (ALL) -> 모든 사용자로 실행할 수 있다.
- ALL -> 모든 명령어를 실행할 수 있다.

user1 계정의 sudo로 모든 명령어를 실행할 수 있는 권한을 부여하고 싶다면 다음 설정을 sudoers 파일에 추가하면 된다.

> user1 ALL=(ALL) ALL

참고로 sudoers 파일을 수정할 때는 visudo 명령어를 사용한다. sudoers 파일은 읽기 전용 파일이기 때문에 vi 명령어로 수정하려면 sudoers 파일의 권한을 수정 전/후에 변경해야 하는데 visudo 명령어를 사용하면 간편하게 sudoers 파일을 수정할 수 있다.

위 설정을 추가하면 user1 계정은 다음과 같이 sudo 명령어 이용해서 root 계정으로 모든 명령어를 실행할 수 있다.

```shell
[user1@myserver ~] $ sudo su
[sudo] user1의 암호 :
```
암호 입력없이 바로 실행할 수 있기를 원한다면 NOPASSWD : 설정을 추가하면 된다. (하지만 이 설정은 user1 사용자가 암호 없이 sudo로 모든 명령어를 실행할 수 있는 권한을 부여하므로 root 암호를 알려준것과 다름없다.)

개발이나 임시 테스트 목적의 서버가 아닌 이상 모든 명령어에 대해 root로 실행할 권한을 부여하는 것은 위험할 수 있다.  그래서 ALL 대신에 특정 명령어만 실행할 수 있는 권한을 부여한다.
> user1 ALL=(ALL) NOPASSWD: /usr/bin/systemctl

위 설정은 sudo 명령어로 systemctl 명령어를 실행할 수 있게 허용한다. 다음과 같이 명령어 뒤에 인자를 추가해서 해당 인자를 사용한 명령만 허용할 수도 있다.

> user1 ALL=(ALL) NOPASSWD: /usr/bin/systemctl start docker

> user1 ALL=(ALL) NOPASSWD: /usr/bin/systemctl stop docker


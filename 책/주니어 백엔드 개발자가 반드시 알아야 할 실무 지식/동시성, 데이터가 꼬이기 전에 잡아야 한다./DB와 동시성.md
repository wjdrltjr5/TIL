# DB와 동시성
대부분의 DB는 명시적인 잠금 기법을 제공한다.
- 비관적 락
- 낙관적 락

## 비관적 락
비관적 락은 데이터에 먼저 접근한 트랜잭션이 잠금을 획득하는 방식이다. 비관적 락을 획득하기 위한 쿼리는 다음 형식을 갖는다.

> select * from 테이블 where 조건 for update

이 쿼리는 조건에 해당하는 레코드를 조회하면서 동시에 잠금을 획득한다. 한 트랜잭션이 특정 레코드에 대한 잠금을 획득한 경우, 잠금을 해제할 때까지 다른 트랜잭션은 동일 레코드에 대한 잠금을 획득하지 못하고 대기해야 한다.

잠금은 커밋 또는 롤백시 반환된다.

간단한 분산 잠금이 필요한 경우 비관적락으로 처리하고 트래픽이 많다면 레디스를 이용해 분산 잠금을 구현하는 것을 고려한다.

## 낙관적 락
낙관적 락은 명시적으로 잠금을 사용하지 않는다. 데이터를 조회한 시점과 값을 수정하려는 시점의 값이 같은지 비교하는 방식으로 동시성 문제를 해결한다.

- > select .. , version from 테이블 where id = 아이디;

- 로직을 수행

- > update 테이블 set .. version = version + 1 where id = 아이디 and version = [1에서 조회한 version 값]
    - 해당 결과의 반환값이 0이면 누군가가 먼저 값을 변경 0보다 크다면 정상적으로 변경을 수행

## 외부 연동과 잠금
트랜잭션 범위 내에서 외부 시스템과 연동해야 한다면 낙관적 락 보다는 비관적 락을 고려하는 것이 좋다.

비관적 락을 사용하면 외부 시스템은 이미 수행됬는데 데이터 변경에 실패해서 트랜잭션이 롤백되는 문제가 발생할 수 있다.

낙관적 락을 사용하고 싶다면 트랜잭션 아웃박스 패턴을 적용해서 외부 연동을 처리하는 방법도 있다.

## 증분 쿼리
증분 쿼리의 경우 서버단에서 추가한 값을 삽입하는 것보다 쿼리르 통해 추가하자.

> update SUBJECT set joinCount = (증가한 값) where id = ?

아래 방식 사용
> update SUBJECT set joinCount = joinCount + 1 where id = ?
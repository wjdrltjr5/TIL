# 프로세스 수준에서의 동시 접근 제어

## 잠금(Lock)을 이용한 접근 제어
프로세스 수준에서 데이터를 동시에 수정하는 것을 막기 위한 일반적인 방법은 잠금을 사용하는 것이다.

잠금을 사용하면 공유 자원에 접근하는 스레드를 한 번에 하나로 제한할 수 있다. 잠금을 사용하는 일반적인 흐름은 다음과 같다.

- 잠금을 획득함
- 공유 자원에 접근(임계 영역)
- 잠금을 해제함

> 임계 영역 : 동시에 둘 이상의 스레드나 프로세스가 접근하면 안 되는 공유 자원에 접근하는 코드 영역을 말한다.

잠금은 한 번에 한 스레드만 획득할 수 있다. 여러 스레드가 동시에 잠금 획득을 시도하면 그중 하나만 획득하고 나머지 스레드는 잠금이 해제될 때까지 대기하게 된다.

다음은 잠금을 사용해 동시에 HashMap을 수정할 때 발생할 수 있는 문제를 방지하는 간단한 자바 코드이다.

```java
public class UserSessions {
    private Lock lock = new ReentrantLock();
    private Map<String, UserSession> sessions = new HashMap<>();

    public void addUserSession(UserSession session){
        lock.lock(); // 잠금 획득할 때까지 대기
        try{
            session.put(session.getSessionId(), session); //공유 자원 접근            
        }finally{
            lock.unlock();  // 잠금 해제
        }
    }

    public UserSession getUserSession(String sessionId){
        lock.lock();
        try{
            return session.get(sessionId);
        }finally{
            lock.unlock();
        }
    }
}
```

위 코드는 ReentrantLock을 사용해서 sessions 필드에 대한 동시 접근을 제한한다. HashMap은 다중 스레드 환경에서 안전하지 않다.

동시에 여러 스레드가 HashMap의 put() 메서드를 호출하면 데이터가 유실되거나 값이 잘못 저장되는 문제가 발생할 수 있다.

> synchronized 나 reentrantLock중 하나만 사용하자 혼합해서 사용 하지 말자.

실제로 잠금이 제대로 동작하는지 확인하기 위한 테스트
```java
class UserSessionsTest{
    @Test
    void concurrentTest(){
        ExecutorService executor = Executors.newFixedThreadPool(500);
        UserSessions userSessions = new UserSessions();

        List<Future<?>> futures = new ArrayList<>();

        int sessionCount = 1_000;
        for(int i = 0; i <= sessionCount; i++){
            String sessionId = "session-" + i;
            Future<?> future = executor.submit(() -> {
                UserSession userSession = new UserSession(sessionId);
                userSession.addUserSession(userSession);
            });

            futures.add(future);
        }
    
        futures.forEach(f -> {
            try{
                f.get();
            }catch(Exception e){
                log.error("error", e);
            }
        });

        executor.shutdown();

        for(int i = 0; i <= sessionCount; i++){
            String sessionId = "session-" + i;
            UserSession userSession = userSession.getUserSession(sessionId);
            assertThat(userSession)
                    .describedAs("session %s", sessionId)
                    .isNotNull();
        }
    }
}
```

> 뮤텍스 : 뮤텍스는 mutual exclusion의 줄임말인데 다른 말로 잠금이라고도 한다. 프로그래밍 언어에서 뮤텍스를 사용하기도 하고 잠금을 사용하기도 한다. 

## 동시 접근 제어를 위한 구성요소 
자바의 ReentrantLock은 한 번에 1개의 스레드만 잠금을 구할 수 있다.  즉 한번에 한 스레드만 공유 자원에 접근할 수 있다. 나머지 스레드는 잠금이 해제될 때까지 대기해야 한다.

### 세마포어
세마포어는 동시에 실행할 수 있는 스레드 수를 제한한다. 자원에 대한 접근을 일정 수준으로 제한하고 싶을 때 세마포어를 사용할 수 있다.

예로 외부 서비스에 대한 동시 요청을 최대 5개로 제한하고 싶을 때 세마포어를 사용할 수 있다.

세마포어는 허용 가능한 숫자를 이용해서 생성한다. 이 숫자를 자바 세마포어 구현체는 permit(퍼밋)이라고 표현하며, Go언어의 세마포어 구현체는 weight라고 표현한다.

> 세마포어에는 이진 세마포어와 개수 세마포어가 있다. 이진 세마포어는 뮤텍스와 다를 바 없고 개수 세마포어는 지정한 수만큼 동시 접근이 가능하다.

세마포어를 사용하는 전형적인 순서는 다음과 같다.
- 세마포어에서 퍼밋 획득( 허용 가능 숫자 1 감소 )
- 코드 실행
- 세마포어에 퍼밋 반환( 허용 가능 숫자 1 증가 )

각 스테드는 세마포어에서 퍼밋을 획득한 뒤에 코드를 실행할 수 있다. 퍼밋이 없다면 마찬가지로 대기해야 한다.

```java
//세마포어를 사용한 동시 실행 스레드 제한
import java.util.concurrent.Semaphore;

public class MyClient{
    private Semaphore semaphore = new Semaphore(5);

    public String getData(){
        try{
            semaphore.acquire(); // 퍼밋 획득 시도
        }catch(InterruptedException e){
            throw new RuntimeException(e);
        }

        try{
            String data = ... // 외부 연동 코드
            return data;
        }finally{
            semaphore.release(); // 퍼밋 반환
        }
    }
}
```

잠금을 사용하면 데이터를 변경하지 않더라도 동시에 읽기가 안된다. 한 번에 1개의 스레드만 가능하기 때문에 읽기 쓰기 잠금을 사용하면 이런 성능상 단점을 없애면서 잠금을 통해 데이터 동시 접근 문제를 없앨 수 있다.

읽기 쓰기 잠금은 다음 특징을 갖는다.
- 쓰기 잠금은 한 번에 한 스레드만 구할 수 있다.
- 읽기 잠금은 한 번에 여러 스레드가 구할 수 있다.
- 한 스레드가 쓰기 잠금을 획득했다면 쓰기 잠금이 해제될 때까지 읽기 잠금을 구할 수 없다.
- 읽기 잠금을 획득한 모든 스레드가 읽기 잠금을 해제할 때까지 쓰기 잠금을 구할 수 없다.

```java
// 읽기 쓰기 잠금을 이용한 동시 접근 제거
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class UserSessionsRW{
    private ReadWriteLock lock = new ReentrantReadWriteLock();
    private Lock writeLock = lock.writeLock();
    private Lock readLock = lock.readLock();
    private Map<String, UserSession> sessions = new HashMap<>();

    public void addUserSession(UserSession session){
        writeLock.lock();
        try{
            sessions.put(session.getSessionId(), session);
        }finally{
            writeLock.unlock();
        }
    }

    public UserSession getUserSession(String sessionId){
        readLock.lock();
        try{
            return sessions.get(sessionId);
        }finally {
            readLock.unlock();
        }
    }
}
```

### 원자적 타입
```java
// 동시성 문제가 발생하는 코드
public class Increaser{
    private int count = 0;

    public void inc(){
        count = count + 1;
    }
}

// 잠금을 사용하는 것보다 더 적은 자원으로 동시성 문제를 해결하는 코드 원자적 타입 사용
import java.util.concurrent.atomic.AtomicInteger;

public class Increaser{
    private AtomicInteger count = new AtomicInteger(0);

    public void inc(){
        count.incrementAndGet();
    }

    public int getCount(){
        return count.get();
    }
}

```

원자적 타입은 내부적으로 CAS연산을 사용한다 이를 통해 스레드를 멈추지 않고도 다중 스레드 환경에서 안전하게 값을 변경할 수 있다.

> CAS : Compare And Swap 의 약자로 비교후 교체하는 연산

원자적 타입의 내부 구현은 잠금을 사용하는 것보다 복잡하지만 사용하는 입장에서는 Lock보다 더 간단하게 동시성 문제를 해결할 수 있다.

### 동시성 지원 컬렉션

스레드에 안전하지 않은 컬렉션은 여러 스레드가 공유하면 동시성 문제가 발견할 수 있다. 이런 문제를 핵뎔하는 방법 중 하나는 동기화된 컬렉션을 사용하는 것이다.

자바의 Collections 클래스는 동기화된 컬렉션을 생성하는 메서드를 제공한다. 이 메서드를 사용하면 기존 컬렉션 객체를 쉽게 동기화된 컬렉션 객체로 변환할 수있다.

```java
Map<String, String> map = new HashMap<>();

// 동기화된 컬렉션 객체 생성
Map<String, String> syncMap = Collection.synchronizedMap(map);
syncMap.put("key1", "value1") // put 메서드는 내부적으로 synchronized로 처리
```

동기화된 컬렉션 객체는 변경이나 조회와 관련된 메서드가 모두 동기화된 블록에서 실행되어 동시성 문제를 해결한다.

> 자바23 또는 이전 버전으로 가상스레드를 사용한다면 동기화 컬렉션 객체로 변환해주는 메서드를 사용하면 안된다. 23또는 이전 버전 기준으로는 가상 스레드는 아직 synchronized를 지원하지 않는다.

동시성 문제를 해결하는 또 다른 방법은 동시성 자체를 지원하는 컬렉션 타입을 사용하는 것이다.

> 예시 HashMap -> ConcurrentHashMap

```java
ConcurrentMap<String, String> map = new ConcurrentHashMap<>();
map.put("Key1", "Value1"); // 동시성 지원 컬렉션은 잠금 범위를 최소화한다.
```

ConcurrentHashMap 타입은 데이터를 변경할 때 잠금 범위를 최소화한다. 따라서 키의 해시 분포가 고르고 동시 수정이 많다면 동기화된 맵보다는 더 나은 성능을 제공한다.


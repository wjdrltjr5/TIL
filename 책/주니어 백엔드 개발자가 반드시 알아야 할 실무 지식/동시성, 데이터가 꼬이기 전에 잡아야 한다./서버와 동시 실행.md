# 서버와 동시실행
트래픽이 많지 않은 서비스라도 초당 100개 이상의 요청이 들어올 수 있다. 서버는 클라리언트의 요청을 처리하기 위해 DB에 쿼리를 보내고 그 결과를 받는다. 동시에 여러 클라이언트가 서버에 연결하는 만큼, 서버도 동시에 여러 쿼리를 DB에 보낸다.

동시에 여러 클라이언트가 요청을 보내기 때문에, 서버는 각 요청을 동시에 처리해야 한다. 만약 동시에 처리하지 못하고 각 요청을 순차적으로 처리한다면 서버의 전체적인 성능, 즉 처리량과 응답시간이 나빠진다.

서버가 동시에 여러 클라이언트의 요청을 처리하는 방식은 크게 다음 2가지가 있다.
- 클라이언트 요청마다 스레드를 할당해서 처리
- 비동기 IO(또는 논블로킹 IO)를 사용해서 처리

요청마다 스레드를 할당하는 방식은 여러 스레드가 동시에 코드를 실행한다. 클라이언트 요청이 동시에 10개 들어오면 10개 스레드가 실행하는 식

서버에 따라 클라이언트 요청을 처리할 때 사용할 스레드 개수에 제한을 두기도 하지만, 동시 요청 개수만큼 스레드가 동시에 실행된다.

비동기 IO/논블로킹 IO 방식을 사용할 떄에도 단일 스레드만 사용하는 경우는 드물다. IO요청을 처리하기 위해 여러 스레드를 사용하는 경우가 많다.

어떤 방식을 사용하든 서버는 동시 실행이 기본이다. 서로 다른 두 스레드가 동시에 같은 데이터를 조회하고 수정하는 일이 발생할 수 있다.

동시 실행을 고려하지 않고 코드를 만들면 찾기 어려운 버그가 발생할 수 있다.
```java
public class Increaser {
    private int count = 0;

    public void inc() {
        count += 1;
    }

    public int getCount(){
        return count;
    }
}
```

다음은 문제가 발생하는 예
```java
Increaser increaser = new Increaser();
Thread[] threads = new Thread[100];

for(int i = 0; i < 100; i++){
    Thread t = new Thread(() -> {
        for(int j = 0; j < 100; j++){
            increaser.inc();
        }
    });

    threads[i] = t;
    t.start();
}

for (Thread t : threads){
    t.join();
}

System.out.println(increaser.getCount());

// count가 5일때 2개의 스레드가 동시에 실행된다면 결과는 7이 아니라 6이 나온다.
```

동시성 문제는 미묘해서 재현이 잘 되지 않는 경우가 많다. 그래서 처음부터 동시성 문제를 염두에 두고 개발하는 것이 중요하다.



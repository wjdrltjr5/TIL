# 인증과 인가
서버 개발에서 가장 기본적인 보안은 인증과 인가이다. 인증은 사용자가 누구인지 확인하는 과정이고 인가는 사용자에게 자원에 접근할 수 있는 권한을 부여하는 것이다.

## 인증과 토큰
아이디와 암호를 입력하는 로그인은 인증의 한 형태이다 보안을 강화하기 위해 2단계 인증을 사용하기도 한다. 지문 같은 생체 정보를 이용하는 방식도 인증의 한 형태다.

사용자가 누구인지 확인하는 데 성공하면 서버는 클라이언트에 문자열로 된 토큰을 제공한다. 클라이언트는 이후 각 요청마다 이 토큰을 함께 보내 자신이 누구인지 증명한다.

서버는 사용자 인증이 필요한 기능에 대해 매번 아이디와 암호를 입력받지 않고 토큰을 사용해서 사용자를 식별한다.

토큰을 이용해서 사용자를 식별하려면 토큰과 사용자 간의 매핑 정보를 어딘가에저장해야 한다.
- 서버의 별도 저장소 : 별도 저장소에 토큰과 사용자 식별 정보를 저장한다.
- 토큰 : 토큰 자체에 사용자 식별자 정보를 저장한다.

### 별도 저장소에 토큰과 사용자 식별자 정보 저장하기
서버는 토큰과 사용자 식별 정보를 DB나 레디스와 같은 별도 저장소에 보관할 수 있다. 서버는 임의의 토큰을 만든 뒤 외부 저장소에 매핑 정보를 보관한다.

토큰 문자열을 생성할 때는 고유한 값을 생성해서 토큰 중복으로 인해 사용자 정보가 잘못 매칭되지 않도록 해야 한다.

외부 저장소에 보관되는 정보는 다음 데이터를 갖는다.
- 토큰
- 사용자 식별자
- 생성 시간
- 최근 사용 시간
- 그 외 유효시간, 클라이언트 버전 등 추가 데이터

```java
String token = ... // 클라이언트가 전송한 토큰을 구한다.
// 저장소에서 토큰 데이터를 구한다.
Optional<TokenData> tokenDataOpt = tokenStore.getTokenData(token);
// 토큰 저장소에 토큰이 없으면 에러를 발생시킨다.
TokenData tokenData = tokenDataOpe.orElseThrow(() -> new InvalidTokenException());
```

외부 저장소가 아닌 서버 메모리에 토큰 데이터를 저장할 수도 있다. 서블릿 세션이 이에 해당한다. 톰캣과 같은 서블릿 컨테이너는 메모리에 세션 객체를 저장한다. 서블릿 세션은 고유의 세션 ID를 생성하는데 이 세션 ID가 토큰에 해당한다.

```java
HttpSession session = request.getSession(false); // 세션을 구한다. 
if(session == null){
    throw new AuthenticationException();
}

UserSessionData data = (UserSessionData) session.getAttribute("userSessionData");
if(data == null){
    throw new AuthenticationException();
}
```

메모리에 토큰 데이터를 저장하는 방식을 사용할 때는 고정 세션이 필요하다. 서버마다 서로 다른 토큰 집합을 저장하고 있기 때문이다.

토큰 데이터를 메모리에 저장하는 방식에는 2가지 단점이 있다. 서버를 재시작하면 토큰 데이터가 사라진다는 것이도 또 하는 생성할 수 있는 세션 개수가 메모리 크기에 제한을 받는다는 것.

이런 단점을 해소하기 위해 세션 데이터를 별도 저장소에 보관하기도 한다. 예로 스프링 세션은 메모리 대신 DB나 레디스에 세션데이터를 저장해서 서버 재시작시에도 세션을 유지할 수 있게 해준다.

이 방법은 외부 저장소에 토큰을 저장하면서도 서블릿의 HttpSession을 그래도 사용할 수 있다는 장점이 있다.

### 토큰 자체에 사용자 식별자 정보 저장하기
토큰 자체에 사용자 식별 정보를 저장할 수도 있다. 대표적인 예가 JWT를 사용하는 것

```java
String token = Jwts.builder()
                .subject("userid") // 사용자 식별자
                .signWith(key)
                .compact();

    // 로그인 결과로 토큰 응답
    return LoginResponse.of(token);
```

서버는 클라이언트가 전송한 토큰으로부터 사용자 식별자를 구한다.

```java
try{
    // 토큰 문자열을 파싱한다.
    Jws<Claims> jwt = Jwts.parser().verifyWith(key).build().parseSignedClaims(jws);
    // 토큰에서 사용자 식별자를 구한다.
    String userId = jwt.getPayLoad().getSubject();
}catch(JwtException e){
    // 유효하지 않은 토큰이면 에러 처리
    throw new AuthenticationException(e);
}
```

이방식의 장점은 토큰만 있다면 사용자가 누구인지 확인할 수 있다는 점 단점은 네트워크 트래픽이 증가한다는 것, 토큰 데이터를 서버에서 제어할 수 없다는 것도 단점이다. 

### 토큰 송수신
클라이언트는 서버에 토큰을 전송할 떄 주로 다음 2가지 방식 중 하나를 사용한다.
- 쿠키 : 쿠키를 사용해서 토큰 전송 
- 헤더 : 특정 이름을 갖는 헤더를 사용해서 토큰 전송

웹사이트는 주로 쿠키 방싯ㄱ을 사용한다. 서버 세션도 쿠키를 사용해서 세션ID를 주고받는다. 서버는 사용자가 로그인에 성공하면 토큰 문자열을 값으로 갖는 쿠키를 웹 브라우저에 응답한다. 웹 브라우저는 서버가 전송한 쿠키를 모든 요청에 함께 전송하므로 토큰을 서버에 전송하기 위해 별도의 자바스크립트 코드를 작성할 필요가 없다.

헤더를 사용할 수도 있다. 쿠키도 헤더를 통해 전송되지만 여기서는 쿠키를 제외한 다른 헤더를 의미한다. 

많은 앱이 서버와 통신할 때 헤더를 통해 토큰을 전송한다. Oauth2.0 처럼 Authorization 헤더를 사용하기도 한다.  (클라이언트는 토큰을 로컬에 저장했다가 서버 API 요청을 호출할 때 헤더를 이용해서 토큰을 전송한다.)

### 토큰 보안
보안을 위해서 토큰을 사용하는 만큼 토큰 자체의 보안에도 신경 써야 한다. 토큰을 탈취한 클라이언트는 원래 토큰 소유자처럼 행세할 수 있다.

토큰 탈취에 따른 보안 문제를 완화하는 방법은 토큰 유효 시간에 제한을 두는 것. 토큰 유효 시간에는 2가지 방식이 존재한다. 
- 첫 번째는 토큰 생성 시점을 기준으로 제한시간을 두는 방식 
- 두 번째는 마지막 접근 시간을 기준으로 토큰 유효 시간을 정하는 방식(서블릿 세션이 해당 방식 사용)

토큰 유효 시간은 어플리케이션 성격에 따라 알맞게 정한다. 유효 시간과 함께 클라이언트 IP를 비교하면 토큰 보안이 향상된다. 토큰을 생성할 때 접근한 클라이언트 IP와 실제 토큰을 전송한 클라이언트 IP가 같은지 비교한다. IP가 다르면 비정상 접근으로 간주하고 요청 처리를 거부한다.

보안 사고 영향을 줄이고 싶다면 토큰을 무효화해서 강제로 로그아웃 시키는 기능도 필요하다. 토큰 데이터를 DB나 레디스와 같은 외부 저장소에 보관하면 토큰 데이터를 삭제하거나 유효 하지 않은 상태로 변경해서 토큰을 무효화할 수 있다.

## 인가와 접근 제어 모델
인가는 사용자가 요청한 기능을 실행할 권한이 있는지 확인하는 역할을 한다. 접근제어의 기본 원칙은 접근한 사용자를 토큰이나 세션으로 식별하는 것이다. API 요청 파라미터로 로그인한 사용자의 식별자를 받으면 안된다.

```java
@GetMapping("/myinfo")
public ResponseEntity<?> getMyInfo(@RequestHeader("token") String token){
    String userId = getUserIdByToken(token); // 토큰으로 사용자 식별값 구함
    MyInfoResponse info = myInfoService.getMyInfo(userId);
    return ResponseEntity.ok(info);
}
```

사용자가 접근할 수 있는 기능을 관리하기 위한 모델을 접근제어 모델이라고 한다. 대표적인 접근 제어 모델로는 역할 기반 접근 제어 모델이 있다.

역할을 두지 않고 사용자마다 개별적으로 권한을 부여할 수도 있다. 각 방식은 각각 장단점이 있기 때문에 단독으로 사용하기 보다는 함께 사용하는 경우가 많다.

사용자의 속성을 이용해서 접근을 제어하는 속성 기반 접근 제어 모델도 있다. 예로 사용자의 IP 주소에 따라 특정 기능의 접근을 허용하거나 제한할 수 있다.




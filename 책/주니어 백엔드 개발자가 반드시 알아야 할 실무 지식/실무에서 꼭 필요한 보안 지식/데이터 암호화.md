# 데이터 암호화
유출되면 가장 큰 피해로 이어질 수 있는 데이터 중 하나가 로그인 아이디와 비밀번호다. 로그인 비밀번호는 외부 유출뿐 아니라 내부에서도 문제가 될 수 있다. DB에 접근할 수 있는 엔지니어가 회원 테이블을 조회해서 비밀번호를 볼 수 있다면 그 자체로 보안 위험이 될 수 있다.

이런 위험을 줄이기 위해서는 로그인 비밀번호를 암호화해서 저장해야 한다. 암호화된 상태로 저장된 비밀번호는 설령 유출되더라도 원래 값을 알아내기 어렵고, 알아내더라도 상당한 시간이 소요된다.

이를 통해 실제 피해가 발생하기 전까지 비밀번호를 변경하는 등 사후 대응할 수 있는 시간을 벌 수 있다.

## 단방향 암호화
단방향 암호화는 암호화된 데이터를 복호화할 수 없는 암호화 방식이다. 단방향 암호화는 해시 함수를 사용해서 데이터를 해시 값으로 변경한다. 

해시 함수 알고리즘에는 SHA-256, MD5, BCrypt 등이 있다.

SHA-256과 같은 해시 함수 알고리즘은 원본 데이터를 유추하기 어렵게 하기 위해 원본 데이터가 조금만 달라도 완전히 다른 해시 값을 사용한다.

단방향 암호화는 로그인 비밀번호 같은 문자열을 암호화하는 데 주로 사용되지만 실제 암호화는 바이트 데이터를 기준으로 동작한다. 

```java
byte[] origin = input.getBytes("UTF-8");
MessageDigest digest = MessageDigest.getInstance("SHA-256");
byte[] hash = digest.digest(origin); // byte 배열을 암호화
```

입력 파라미터가 바이트 배열이므로 문자열을 암호화할 때는 바이트 배열로 변환해서 전달한다. 바이트 배열로 변환할 때는 문자열에 알맞은 캐릭터셋을 이용한다.

암호화한 결과를 DB와 같은 저장소에 읽을 수 있는 형태로 저장하려면 바이트 배열을 문자열로 표현해야 한다. 이를 위해 바이트 배열을 16진수 표기법이나 Base64 표기법을 사용해서 문자열로 표현한다.

```java
public static String encrypt(String input){
    StringBuilder hexString = new StringBuilder();
    try{
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] hash = digest.digest(input.getBytes("UTF-8"));
        for(byte b : hash){
            String hex = Integer.toHexString(0xff & b);
            if(hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
    }catch(Exception e){
        throw new RuntimeException(e);
    }
    return hexString.toString();
}
```

> 충돌 저항성 : 해시 함수는 원본 데이터에 상관없이 일정한 길이의 해시 값을 생성한다 길지가 제한되기 떄문에 서로 다른 데이터가 동일한 해시 값을 가질 수 있다. 서로 다른 데이터에 대해 최대한 다른 해시 값을 생성하는 해시 알고리즘이 좋다고 할 수 있다. 동일한 해시 값을 갖는 서로 다른 데이터를 찾기 어려울 때 해시 함수는 충동 저항성을 갖는다. 해시 함수의 생성 결과가 길수록 충돌 날 가능성이 줄어든다.

### 값의 비교
단방향 암호화는 해시 함수로 생성한 해시 값이 같다면 두 데이터가 같다고 간주한다. 로그인할 때 비밀번호가 일치하는지 여부도 해시 값을 이용해서 비교한다.

```java
// 사용자가 입력한 비밀번호를 암호화한 해시 값을 구함
String inputPwdHash = encodePassword(inputPwd);
// DB에 저장된 비밀번호 해시 값을 조회함
String dbPwdHash = selectDbPwd(userId);
if(inputPwdHash.equals(dbPwdHash)){
    // 두 값이 같으면 비밀번호를 올바르게 입력함
}
```

단방향 암호화는 복호화할 수 없기 때문이 비밀번호를 잊었을때는 초기화된 비밀번호를 받아 로그인하도록 한다.

### Salt로 보안 강화하기
같은 해시 알고리즘을 사용하면 동일한 원본 데이터에 대해 항상 동일한 해시 값이 생성된다. 이 특성은 해시 값이 유출됐을때 원본을 유추하기 쉽게 만든다.

이렇게 같은 원본 데이터에 대해 항상 동일한 해시 값을 생성하는 것은 보안에 취약하다. 해시 알고리즘은 이취약점을 보완하기 위해 솔트를 사용한다.

솔트는 임의의 값이며 암호화할때 솔트를 함께 사용하면 솔트 값에 따라 결과 해시 값이 달라진다.

```java
// 솔트를 사용한 암호화
public static String encryptWithSalt(String input, String salt){
    StringBuilder hexString = new StringBuilder();
    try{
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        digest.update(salt.getBytes()); // salt 추가
        byte[] hash = digest.digest(input.getBytes("UTF-8"));
        for(byte b : hash){
            String hex = Integer.toHexString(0xff & b);
            if(hex.length() == 1)hexString.append("0");
            hexString.append(hex);
        }
    }catch(Exception e){
        throw new RuntimeException(e);
    }
    return hexString.toString();
}
```

## 양방향 암호화
양방향 암호화는 암호화와 복호화가 모두 가능한 방식이다. 서버에 접속할 때 사용하는 SSH 프로토콜이나 API 호출 시 사용하는 HTTPS처럼 보안이 중요한 데이터 송수신 과정에서 주로 사용된다.

대표적인 양방향 암호화 알고리즘으로 AES, RSA가 있다.

양방향 암호화는 암호화와 복호화할때 키를 사용한다. 같은 알고리즘, 같은 원본 데이터라도 어떤 키를 사용하느냐에 따라 결과는 달라진다.

양방향 암호화는 대칭 키 방식와 비대칭 키 방식으로 나뉜다. 대칭 키 암호화는 암호화와 복호화할 때 동일한 키를 사용한다. 수행하는 쌍이 같은 키를 공유해야 한다. 이방식에서는 키가 유출되면 누구나 암호화된 데이터를 복호화할 수 있기때문에 키의 본안이 매우 중요하다.

비대칭 키 암호화는 암호화할 때와 복호화할 떄 서로 다른 키를 사용한다. 비대칭키 암호화에서는 공개 키와 개인 키를 생성한다.

공개 키는 암호화할때 사용되며, 개인 키는 암호화된 데이터를 복호화할 떄 사용된다. 키 소유자는 공개 키와 개인키 쌍을 생성한 뒤 데이터 송신자에게 공개키를 제공한다. 공개 키로 암호화한 데이터는 개인 키로만 복호화할 수 있기 떄문에, 공개 키가 유출되더라도 암호화한 데이터를 복호화할 수 없다.

개인 키로 암호화하고 공개키로 복호화할 수도 있다. 보통 이런 경우는 신원확인이나 서명과 같은 인증 목적으로 사용된다. 개인키를 사용해서 인증을 수행하는 예로 SSH를 들 수 있다.  SSH 서버는 개인 키를 이용한 인증 수단을 제공한다.

SSH 서버에 공개키를 등록하고 클라이언트는 서버에 접속할 때 개인 키를 이용해서 인증한다.

### AES 대칭 키 암호화 예
대표적인 대칭 키 암호화 알고리즘에는 AES가 있다. AES알고리즘을 사용할 때는 다음의 두 값을 생성해서 공유한다.
- 키
- IV(Initialization Vector, 초기화 벡터)

ASE는 키 값으로 128비트, 192비트, 256비트 중 하나를 사용한다. 바이트로는 각각 16바이트, 24 바이트, 32 바이트가 된다. 

키는 무작위로 생성해서 유추가 어려워야 한다. 예로 256비트 키를 생성할 떄는 무작위로 32바이트 배열을 생성하고 이를 보관한다.

```java
public static byte[] generateSecretKey() throws Exception{
    KeyGenerator keyGenerator = keyGenerator.getInstance("AES");
    keyGenerator.init(256); // 256비트 키 생성
    SecretKey secretKey = keyGenerator.generateKey(); 
    return secretKey.getEncoded(); // 길이 32 바이트의 배열 반환
}
```

생성한 키는 바이너리 파일이나 문자열 형식으로 변환해서 보관하고 공유한다. 보관된 키를 이용해 암호화를 하려면 해당 키 데이터로부터 SecretKey 객체를 만들어야 한다.

```java
SecretKey key = new SecretKeySpec(bytes, "AES");
```

같은 키를 사용해서 같은 데이터를 암호화하면 항상 같은 결과가 생성된다. 이처럼 반복되는 패턴은 공격자가 암호화된 데이터를 분석할 수 있는 단서를 줄 수 있다. 이런 패턴 노출을 막기 위해 IV를 사용한다.

IV는 임의의 바이트 배열로서, 암호화할때 함께 사용하면 같은 키를 쓰더라도 결과값이 매번 달라져 패턴이 드러나는 것을 방지할 수 있다.

복호활 떄는 키와함께 IV도 필요하기 떄문에 IV역시 안전하게 전달하거나 저장해야 한다.

ASE알고리즘은 길이가 16인 바이트배열을 IV로 사용한다.
```java
public static byte[] genIv(){
    byte[] iv = new byte[16];
    new SecureRandom().nextBytes(iv);
    return iv;
}
```

키와 IV를 이용해서 암호화하고 복호화하는 코드는 다음과 같다. 문자열을 암호화하고 복호화하는 예
```java
public static String encrypt(String plain, SecretKey key, byte[] iv) throws Exception{
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")// 알고리즘
    IvParameterSpec parameterSpec = new IvParameterSpec(iv);
    cipher.init(Cipher.ENCRYPT_MODE, key, parameterSpec);
    byte[] encrypted = cipher.doFinal(plain.getBytes("UTF-8")); // 암호화 실행
    return Base64.getEncoder().encodeToString(encrypted);
}

public static String decrypt(String encrypted, SecretKey key, byte[] iv) throws Exception{
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding"); // 알고리즘
    IvParameterSpec parameterSpec = new IvParameterSpec(iv);
    byte[] decoded = Base64.getDecoder().decode(encrypted); // 복호화 실행
    return new String(decrypted, "UTF-8");
}
```

단뱡항 암호화와 마찬가지로 암복호화도 바이트 데이터를 대상으로 한다. 그래서 문자열을 암호화할때는 바이트 배열로 변환한 뒤에 암호화를 한다.

위 코드는 암호화한 결과로 생성한 바이트 배열을 Base64를 이용해서 인코딩했다. 16진수 표기법을 사용해서 문자열로 표시해도 된다.

바이트 배열 자체를 송신해야 한다면 배열 자체를 리턴한다. 암복호화할때 "AES/CBC/PKCS5Padding" 을 사용해서 Cipher객체를 구했는데

이때 각 단어는 암호화알고리즘, 암호화 모드, 패딩 방식을 뜻한다. AES는 정해진 길이의 블록 단위로 암호화를 수행하기 때문에 마지막 블록을 길이가 맞지 않을 때가 많다. 길이가 부족한 마지막 블록을 규칙에 따라 값을 채우고 암호화를 진행하는데, 이때 값을 채우는 규칙이 패딩방식이다.

암호화 모드에 따라 패딩이 필요 없기도 하다. GCM 암호화 모드를 사용하면 패딩이 필요 없으므로 패딩 규칙으로 NoPadding을 사용한다.

### 비대칭 키 암호화 예
RSA 알고리즘을 위한 키 쌍을 생성하는 코드 예다.
```java
KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
keyGen.initialize(2048);
KeyPair keyPair = KeyGen.generateKeyPair();
PublicKey publicKey = keyPair.getPublic(); // 공개 키
PrivateKey privateKey = keyPair.getPrivate(); // 개인 키
byte[] publicKeyBytes = publicKey.getEncoded(); // 공개 키 바이트 배열
byte[] privateKeyBytes = privateKey.getEncoded(); // 개인 키 바이트 배열
```
공개 키는 바이트 배열을 Base64 형식으로 인코딩해서 문자열로 공유하거나, 바이트 배열 자체를 파일로 저장해서 공유한다.

개인 키도 유하사기 Base64로 인코딩한 문자열을 저장하거나 바이트 배열 자체를 바이너리 형식으로 저장한다.

문자열이나 바이너리 형태로 저장한 공개 키와 개인 키는 다시 코드에서 사용할 수 있는 형태로 변환해야 한다. 다음 코드는 바이트 배열을 PublicKey 타입과 PrivateKey 타입으로 변환하는 예제 코드

```java
public static KeyPair getKeyPairFromBytes(byte[] publicKeyBytes, byte[] privateKeyBytes) throws NoSuchAlgorithmException, InvalidKeySpecException{
    KeyFactory keyFactory = keyFactory.getInstance("RSA");
    PublicKey publicKey = keyFactory.generatePublic(new X509EncodedKeySpec(publicKeyBytes));

    PrivateKey privateKey = keyFactory.generatePrivate(new PKCS8EncodedKeySpec(privateKeyBytes));

    return new KeyPair(publicKey, privateKey);
}
```

다음은 공개 키와 개인 키로 암호화/복호화하는 예제 코드
```java
public static String encrypt(String plain, PublicKey publicKey){
    Cipher cipher = Cipher.getInstance("RSA");
    cipher.init(Cipher.ENCRYPT_MODE, publicKey);
    byte[] encryptedBytes = cipher.doFinal(plain.getBytes("UTF-8"));
    return Base64.getEncoder().encodeToString(encryptedBytes);
}

public static String decrypt(String encrypted, PrivateKey privateKey){
    Cipher cipher = Cipher.getInstance("RSA");
    cipher.init(Cipher.DECRYPT_MODE, privateKey);
    byte[] decodedBytes = Base64.getDecoder().decode(encrypted);
    byte[] decryptedBytes = cipher.doFinal(decodedBytes);
    return new String(decryptedBytes, "UTF-8");
}
```

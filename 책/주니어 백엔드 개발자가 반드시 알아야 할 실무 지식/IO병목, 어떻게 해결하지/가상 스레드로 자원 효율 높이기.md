# 가상 스레드로 자원 효율 높이기
코드를 블로킹 IO로 작성했는데, 입출력 동안 스레드가 대기하지 않고 다른 일을 할 수 있다면 CPU의 유휴 시간도 줄어들고 더 많은 작업을 처리할 수 있게 된다.

이렇게 특별한 노력없이 CPU의 효율을 높이는 방법이 자바의 가상 스레드나 Go언어의 고루틴을 사용하는 것

경량스레드는 OS가 관리하는 스레드가 아니라 JVM같은 언어의 런타임이 관리하는 스레드다. OS가 CPU로 실행할 스레드를 스케줄링하듯 언어 런타임이 OS 스레드로 실행할 경량 스레드를 스케줄링한다.

JVM은 플랫폼 스레드(OS 스레드에 1:1로 대응하는 매퍼)로 구성된 풀을 유지한다. CPU가 OS 스케줄러에 의해 여러 스레드를 번갈아 실행하는 것처럼 플랫폼 스레도도 JVM 스케줄러에 의해 여러 가상 스레드를 번갈아 실행한다.

JVM은 기본적으로 풀에 CPU 코어 개수 만큼 플랫폼 스레드를 생성하고 필요에 따라 플랫폼 스레드를 증가시킨다.

가상 스레드를 경량 스레드라고 부르는 이유는 플랫폼 스레드보다 더 적은 자원을 사용하기 때문이다.

가상 스레드는 플랫폼 스레드(OS스레드)보다 더 적은 메모리를 사용한다. 1 만개의 플랫폼 스레드를 생성한다고 가정했을때 스레드의 기본크기가 1MB라면 10000MB(9.8GB)의 메모리를 사용한다.

가상 스레드는 훨씬 적은 메모리를 사용한다. 가상 스레드 1개가 평균적으로 2KB메모리를 사용한다고 했을때 1만개의 가상 스레드가 사용하는 힙 메모리는 약 20MB정도이다.

여기에 플랫폼 스레드가 8개라고 한다면 추가로 8MB의 스택 메모리를 사용한다. 즉 1만개의 가상 스레드를 실행하기 위해 28MB의 메모리(힙 20, 스택 8)를 사용하는 것

스레드를 생성하는 시간도 차이가 난다.
```java
Thread[] threads = new THrad[100_000]; // 10만개
long start = System.currentTimeMillis();
for(int i = 0; i < threads.length; i++){
    // 가상스레드는 Thread.ofVirtual()로 생성
    Thread thread = Thread.ofPlatform().start(() -> {
        try{
            Thread.sleep(1000);
        }catch{
            e.printStackTrace();
        }
    });

    threads[i] = thread;
}

long end = System.currentTimeMillis();
```

- 플랫폼 스레드 : 21,467ms
- 가상 스레드 : 196ms

가상스레드는 플랫폼 스레드에 비해 훨씬 적은 비용(자원, 시간)이 들기 떄문에 한 장비에서 수십만에서 수백만에 이르는 가상 스레드를 생성할 수 있다.

이는 톰캣처럼 요청별 스레드를 생성하는 서버에서 가상 스레드를 사용하면 더 적은 메모리로 더 많은 요청을 처리할 수 있다는 것을 뜻한다.

> 캐리어 스레드 : 가상 스레드를 실행하는 플랫폼 스레드를 캐리어 스레드라고 표현 CPU가 여러 스레드를 실행하는 것처럼 캐리어 스레드도 여러 가상 스레드를 실행한다. 특정 가상 스레드가 특정 캐리어 스레드에 연결되는 것을 마운트 되었다고 표현한다.

## 네트워크 IO와 가상 스레드
가상 스레드는 실행하는 과정에서 블로킹되면 플랫폼 스레드와 언마운트되고 실행이 멈춘다. 이떄 언마운트된 플랫폼 스레드는 실행 대기 중인 다른 가상 스레드와 연결한 뒤 실행을 재개한다.

> 블로킹 연산에는 IO기능, ReentrantLock, Thread.sleep() 등이 포함된다. 단 자바 23 이전 버전에서 synchronized로 인해 블로킹 되면 가상 스레드는 플랫폼 스레드로부터 언마운트 되지 않는다. 이렇게 플랫폼 스레드와 같이 블로킹 되는 것을 가상 스레드가 플랫폼 스레드에 pinned됐다 라고 한다. 가상스레드가 고정되면 CPU효율을 높일 수 없다.

## 가상 스레드와 성능
우리가 작성하는 코드는 크게 IO중심 작업과 CPU 중심 작업으로 나눌 수 있다. 네트워크 프로그래밍 처럼 입출력이 주를 이루는 작업은 IO중심 작업에 해당한다.

반대로 정렬처럼 계산이 주를 이루는 작업은 CPU 중심 작업에 해당한다.

이 두 작업 중 가상 스레드는 IO 중심 작업일 때 효과가 있다. IO는 가상 스레드가 지원하는 블로킹 연산이므로 IO중심 작업일 때 플랫폼 스레드가 CPU 낭비 없이 효율적으로 여러 가상 스레드를 실행할 수 있다.

CPU 중심 작업에 가상 스레드를 사용하면 성능 개선 효과를 얻을 수 없다 오히려 성능이 나빠질 수도 있다. (딱히 블로킹 연산이 없으므로)

또한 IO 중심 작업이라고 해서 무조건 가상 스레드의 이점을 얻는 것은 아니다. 스케줄링에 사용되는 플랫폼 스레드 개수보다 가상 스레드의 개수가 많아야 효과를 기대할 수 있다.

가상 스레드의 이점을 얻으려면 CPU 코어 수를 줄이거나 트래픽이 더 많아져야 한다. 가상 스레드를 사용해서 높일 수 있는 것은 처리량이다. 가상 스레드를 사용한다고 해서 실행 속도가 플랫폼 스레드보다 더 빨라지지는 않는다.

> 가상 스레드는 플랫폼 스레드보다 생성 비용이 적기 떄문에 스레드 풀을 미리 구성할 필요가 없다 필요한 시점에 가상 스레드를 생성하고 필요 없으면 제거하면된다.

## 가상 스레드의 중요한 장점
가상 스레드의 중요한 장점은 기존 코드를 크게 수정할 필요가 없다는 것이다. 프레임워크와 라이브러리도 이미 가상 스레드를 지원하고 있다. 따라서 조금만 신경쓰면 기존 코드를 유지하면서도 서버의 성능을 높일 수 있다.



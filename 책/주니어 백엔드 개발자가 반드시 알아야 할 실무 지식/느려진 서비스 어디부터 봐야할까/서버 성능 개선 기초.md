# 서버 성능 개선 기초
서비스 초기에는 성능 문제가 잘 발생하지 않는다. 사용자 수, 트래픽, 데이터베이스 크기 등이 모두 작기 때문

성능 문제는 사용자가 늘면서 점차 나타난다. 트래픽이 늘고 데이터가 쌓이면서 간혈적으로 응답 시간이 느려지는 현상이 발생한다.

이런 증상을 방치하면 어느 순간 심각한 성능 문제가 터진다. 이때 나타나는 전형적인 증상은 다음과 같다.

- 순간적으로 모든 사용자 요청에 대한 응답 시간이 심각하게 느려진다. 10초 이상 걸리는 요청이 늘어나고 다수의 요청에서 연결 시간 초과와 같은 오류가 발생한다.
- 서버를 재시작하면 잠시 괜찮다가 다시 응답 시간이 느려지는 현상이 반복된다.
- 트래픽이 줄어들 때까지 심각한 상황이 계속된다.

트래픽이 증가하면서 성능 문제가 발생하는 주된 이유는 시스템에 수용할 수 있는 최대 TPS를 초과하는 트래픽이 유입되기 때문이다.

TPS를 높이려면 먼저 성능 문제가 발생하는 지점을 찾아야 한다. 문제 지점을 찾는 간단한 방법은 처리 시간이 오래 걸리는 작업을 식별하는 것

일반적인 서버는 DB나 다른 API와 연동한다. 성능 문제는 주로 DB나 외부 API를 연동하는 과정에서 발생한다.

## 수직 확장과 수평 확장
TPS를 높이기 위해 무턱대고 서버를 추가해서는 안 된다. 실제 병목 지점이 어디인지 파악하는 게 중요하다.

DB에서 성능 문제가 발생하고 있는데 서버를 추가로 투입하면 불에 기름을 붓는 격이다. DB에 문제가 있는 상황에서 DB를 사용하는 서버를 더 늘리면 DB에 가해지는 부하가 더 커지고 성능 문제는 더 악화된다.

외부 API의 성능이 문제인 경우도 마찬가지 외부 API성능이 개선되지 않는 한 서버를 추가한다고 해도 TPS는 향상되지 않는다.

## DB 커넥션 풀
DB를 사용하려면 다음과 같이 3단계를 거친다.
- DB에 연결한다.
- 쿼리를 실행한다.
- 사용이 끝나면 연결을 종료한다.

서버와 DB는 네트워크 통신을 통해 연결된다. 이때 네트워크 연결을 생성하고 종료하는 데 걸리는 시간은 0.5~ 1초 이상 소요되기도 한다.

네트워크에서 DB를 연결하고 종료하는 시간은 전체 응답 시간에 영향을 준다. 매 요청마다 DB를 연결하고 종료하면 트래픽이 증가할 때 급격하게 처리량이 떨어지기도 한다.

이런 문제를 피하기 위해 DB커넥션 풀을 사용한다. 커넥션 풀은 다양한 설정을 제공한다. 그중 중요한 설정은 다음과 같다.
- 커넥션 풀 크기(또는 최소, 최대 크기)
- 풀에 커넥션이 없을 떄 커넥션을 구할 때까지 대기할 시간
- 커넥션의 유지 시간(최대 유휴 시간, 최대 유지 시간)

## 커넥션 풀 크기
커넥션 풀 크기는 커넥션 풀에 미리 생성해둘 커넥션 개수를 지정하는 설정이다. 커넥션 풀 크기는 커넥션 풀 설정에서 가장 중요하다.

서버는 주로 DB와 통신하기 떄문에 DB 연결을 관리하는 DB 커넥션 풀 크기를 잘못 설정하면 성능에 큰 영향을 준다.

트래픽이 순간적으로 급증하는 패턴을 보인다면 커넥션 풀의 최소 크기를 최대 크기에 맞추는 것이 좋다. 트래픽이 점진적으로 증가할때는 DB연결 시간이 성능에 큰 영향을 주지 않지만 트래픽이 급증할 경우 DB 연결시간도 성능 저하의 주요 원인이 될 수 있기 때문

커넥션 풀 크기를 늘리면 처리량을 높일 수 있다. 그러나 커넥션 풀 크기를 무턱대고 늘리면 안된다 DB 서버의 CPU 사용률이 80%에 육박하는 상황에서 커넥션 풀 크기를 늘리면 DB에 가해지는 부하가 더 커져 쿼리 실행 시간이 급격히 증가할 수 있다.

## 커넥션 대기 시간
대부분의 커넥션 풀은 대기 시간을 설정할 수 있다. 대기 시간이란 풀에 사용할 수 있는 커넥션이 없을 때 커넥션을 얻기 위해 기다릴 수 있는 최대 시간을 의미한다. 지정된 대기 시간 안에 커넥션을 구하지 못하면 DB연결 실패 에러가 발생한다.

대기 시간을 짧게 설명하면 커넥션 들이 모두 사용 중일 때 빠르기 일시적 오류와 같은 에러응답을 사용자게 보여줄 수 있다.

에러를 응답하는 게 부정적으로 보일 수도 있다. 하지만 대기 시간 때문에 긴 시간 동안 무응답 상태로 유지되는 것보다는 빠르게 에러를 반환하는 것이 더 낫다.

`커넥션을 얻지 못했을때 빠르게 에러를 응답해야 서버의 부하가 증가하는 것도 방지할 수 있다.`

대기 시간을 짧게 설정하면 서버 부하를 일정 수준으로 유지할 수 있으며 서버를 안정적으로 운영하는 데 도움이 된다.

## 최대 유휴 시간, 유효성 검사, 최대 유지 시간
DB와 연결이 끊긴 커넥션을 사용하면 에러가 발생한다. 이러한 연결 끊김으로 인해 발생하는 에러를 방지하기 위해 커넥션 풀은 다음 2가지 기능을 제공한다.
- 최대 유휴 시간 지정 
- 유효성 검사 지원

커넥션 풀이 제공하는 또 다른 설정은 최대 유지 시간이다. 커넥션이 유효하더라도 이 시간이 지나면 커넥션을 닫고 풀에서 제거한다.

최대 유휴 시간과 최대 유지 시간을 무한대로 설정하지 않는 것이 좋다. 커넥션 풀의 기본값을 확인한 뒤 이 두 설정의 기본값이 무제한으로 되어 있다면 DB설정을 참고하여 알맞게 적절한 값으로 지정해야 한다.

## 서버 캐시
DB서버를 확장하려면 비용이 많이 든다. 수평 확장 하더라도 처리량을 늘릴 수 있지만 실행 시간이 획기적으로 줄어들지는 않는다.

DB서버를 확장하지 않고도 응답 시간과 처리량을 개선하고 싶다면 캐시 사용을 고려할 수 있다.

## 적중률과 삭제 규칙
캐시가 얼마나 효율적으로 사용되는지는 적중률로 판단할 수 있다. 캐시 적중률은 다음과 같이 계산한다.

- 적중률 = 캐시에 존재한 건수/캐시에서 조회를 시도한 건수

캐시에 모든 데이터를 무작정 저장할 수 없다. 캐시는 메모리 자원을 사용하기 때문이다 사용할 수 있는 메모리 용량은 한계가 있기에 캐시에 저장할 수 있는 데이터 개수나 크기도 제한된다.

삭제할 대상을 선택할 떄 주로 사용하는 규칙은 다음과 같다.
- LRU(Least Recently Used) : 가장 오래전에 사용된 데이터를 제거한다.
- LFU(Least Frequently Used) : 가장 적게 사용된 데이터를 제거한다.
- FIFO(First In First Out) : 먼저 추가된 데이터를 먼저 삭제한다.

많은 서비스에서는 오래된 데이터 보다 최신 데이터를 더 자주 조회하는 경향이 있다. 즉 오래된 데이터는 캐시에 있어도 사용되지 않을 가능성이 크다. 따라서 캐시가 가득 차 있지 않더라도 오래된 데이터는 미리 삭제하는 것이 좋다.

이렇게 하면 불필요한 메모리 사용을 줄일 수 있기 때문이다. 이를 위해 캐시에는 유효 시간(만료 시간)을 설정하는 방식도 함께 사용한다.

## 로컬 캐시와 리모트 캐시
서버가 사용하는 캐시에는 크게 두 종류가 있다. 
- 로컬 캐시 (서버 프로세스와 동일한 메모리를 캐시 저장소로 사용)
- 리모트 캐시 ( 별도 프로세스를 캐시 저장소로 사용)

캐시에 보관할 데이터 규모가 작고 변경 빈도가 매우 낮다면 로컬 캐시로 충분하다. 반면에 데이터 규모가 크다면 리모트 캐시를 사용해야 한다.

배포 빈도가 높은 서비스라면 (하루에 몇 번씩 배포) 리모트 캐시 사용을 적극적으로 고려해야 한다.

## 캐시 사전 적재
트래픽이 순간적으로 급증하는 패턴을 보인다면 캐시에 데이터를 미리 저장하는 것도 고려할 필요가 있다.

이를 통해 순간적으로 트래픽이 몰렸을 때도 응답 시간을 안정적으로 유지할 수 있으며, DB에 부하가 집중되는 현상도 효과적으로 방지할 수 있다.

## 캐시 무효화
캐시를 사용할 때 반드시 신경 써야 할 점은 유효하지 않은 데이터를 적절한 시점에 캐시에서 삭제하는 것.

## 가비지 컬렉터와 메모리 사용
가비지 컬렉터를 사용하는 언어는 사용이 끝난 객체를 힙 메모리에서 바로 삭제하지 않고 정해진 규칙에 따라 사용하지 않는 메모리를 찾아서 반환한다.

한번에 대량으로 객체를 생성하는 것도 주의해야 한다. 이런 경우 메모리가 부족해서 gc를 실행하지만 메모리가 부족한 상태는 계속된다 여전히 필요한 메모리가 크기 때문

파일 다운로드와 같은 기능을 구현할 때는 스트림을 활용한다. 파일 데이터를 한꺼번에 메모리에 로딩한 후에 응답하는 방식을 피해야 한다.

스트림을 활용하면 파일 처리 과정에서 필요한 메모리 크기를 줄일 수 있다.

## 응답 데이터 압축
응답 시간에는 데이터 전송 시간이 포함된다. 이 전송 시간은 2가지 요인에 영향을 받는다.
- 네트워크 속도 
- 전송 데이터 크기

서버는 사용자의 네트워크 속도를 제어할 수 없지만 전송하는 데이터의 크기는 제어할 수 있다.

이때 사용할 수 있는 방법이 바로 응답 데이터를 압축해서 전송하는 것이다. 웹 서버가 전송하는 응답 데이터 중에서 HTML, CSS, JS, JSON 과 같이 텍스트로 구성된 응답은 압축하면 데이터 전송량을 크게 줄일 수 있다.

응답 데이터를 압축해 데이터 전송량을 줄이는 것은 응답 시간뿐만 아니라 비용에도 영향을 준다.

아파치나 Nginx와 같은 웹 서버는 압축 기능을 제공하고 있으므로 약간의 설정만 추가하면 즉시 효과를 볼 수 있다.

### Accept-Encoding 요청 헤더와 Content-Encoding 응답헤더
웹 브라우저나 HTTP 클라이언트는 Accept-Encoding 헤더를 통해 서버에 처리할 수 있는 압축 알고리즘을 알린다.

> Accept-Encoding: gzip, deflate

웹서버는 Accept-Encoding 헤더에 명시된 알고리즘 중에서 자신이 지원하는 방식이 있을 경우, 해당 압축 알고리즘으로 응답 데이터를 압축해서 전송한다. 이때 사용된 압축 알고리즘은 Content-Encoding 응답 헤더를 통해 클라이언트에 전달된다.

응답 데이터를 압축할 떄는 다음 사항을 고려하자.
- html, css, js, json과 같은 텍스트 형식의 응답은 압축률이 높아 효과적이다. 반면 jpeg 이미지나 zip파일 처럼 이미 압축된 데이터에는 다시 압축해도 효과가 없다. 따라서 모든 응답에 압축을 적용하지 말고 텍스트 형식의 데이터에 압축을 적용하자.

- 웹 서버에서 압축을 적용했더라도 방화벽이 이를 해재해 응답할 수 있다. 즉 웹 서버에 압축 설정을 적용했음에도 실제 응답 데이터가 압축되지 않았다면 방화벽 설정도 확인해야 한다.

## 정적 자원과 브라우저 캐시
- 동적 자원은 브라우저가 요청할 때마다 결과가 방뀌는 데이터로 제품 목록 html이나 제품 상세 json응답이 여기에 해당한다.

- 정적자원은 같은 url에 대해 같은 데이터를 응답하는 콘텐츠로 이미지, js, css가 대표적이다. 정적 자원은 전체 트래픽에서 상당한 비중을 차지한다.

클라이언트 캐시를 활용하면 서버가 전송하는 트래픽을 줄이면서 브라우저가 더 빠르게 화면을 표시할 수 있다.

브라우저 캐시를 활용하면 서버 입장에서도 전송해야 할 트래픽이 줄어들어 그만큼 네트워크 전송 비용을 아낄 수 있다.

## 정적 자원과 CDN
이미지, js 같은 정적 자원을 CDN으로 제공하면 오리진 서버가 처리해야 할 트래픽을 상당히 줄일 수 있다.

## 대기 처리
순간적으로 폭증하는 트래픽을 처리하기 위해 서버와 DB를 증설하는 것이 잘못된 방법은 아니지만 비용이 많이든다.

클라우드에서 증설한 서버는 다시 줄일 수 있지만 DB는 그렇지 않다. 최대 트래픽에 맞춰 DB성능을 높여 놓으면 DB성능을 줄이기가 쉽지 않다.

반대의 접근 방법도 있다 처리할 수 있는 시스템의 처리량을 무작적 늘리기 보다는 수용할 수 있는 수준의 트래픽만 받아들이고 나머지는 대기 처리하는 것

나머지 사용자를 대기처리 하면 다음의 이점을 얻을 수 있다.
- 서버를 증설하지 않고도 서비스를 안정적으로 제공할 수 있다.
- 사용자의 지속적인 새로고침으로 인한 트래픽 폭증도 방지할 수 있다. 사용자는 새로 고침할 경우 순번이 뒤로 밀리기 때문에 불필요한 새로 고침을 자제하게 된다.


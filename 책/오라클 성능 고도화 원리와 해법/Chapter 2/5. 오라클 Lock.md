# 오라클 Lock

오라클은 공유 리소스와 사용자 데이터를 보호할 목적으로 DML Lock, DDL Lock, 래치(Latch), 버퍼 Lock, 라이브러리 캐시 Lock/Pin 등 다양한 종류의 Lock을 사용한다.

-   래치 : SGA에 공유돼 있는 갖가지 자료구조를 보호할 목적으로 사용하는 가벼운 Lock

-   버퍼 Lock : 버퍼 블록에 대한 액세스를 직렬화

-   라이브러리 캐시 Lock : 라이브러리 캐시 오브젝트에 대한 핸들을 보호
-   라이브러리 캐시 Pin : 라이브러리 캐시 오브젝트의 실제 내용이 담긴 힙 보호

-   DML 테이블 Lock : Enqueue Lock 으로 구현함
-   DML 로우 Lock : 로우 단위 Lock과 트랜잭션 Lock을 조합해서 구현(트랜잭션 lock은 Enqueue Lock으로 구현)

## Enqueue Lock

Enqueue는 공유 리소스에 대한 액세스를 관리하는 Lock 메커니즘이다.

Enqueue에 의해 보호되는 공유 리소스로는 테이블, 트랜잭션, 테이블 스페이스, 시퀀스 Temp 세그먼트 같은 것들이 있다.

Enqueue Lock으로 관리되는 공유 리소스에 대해 Lock을 획득하려면 먼저 Enqueue 리소스를 할당받아야 한다.

Enqueue 리소스는 소유자, 대기자 목록을 관리할 수 있는 구조체를 말한다.

각 Enqueue 리소스에는 고유한 식별자가 부여되며 식별자는 Type-ID1-ID2 로 구성된다.

Type (ex. TX, TM, TS) 2개의 문자열로 이루어지며 ID1, ID2에는 Lock 종류에 따라 다른 정보를 갖는다.

-   TM Lock 식별자 예제

    -   TYPE : TM
    -   ID1 : 오브젝트 ID
    -   ID2 : 0

-   TX Lock 식별자

-   TYPE : TX
-   ID1 : Undo 세그먼트 번호 + 트랜잭션 슬롯번호
-   ID2 : 트랜잭션 슬롯 Sequence 번호

오라클은 Enqueue 리소스 구조체를 통합 관리하는 리소스 테이블을 갖고 있으며, 리소스 테이블에서 관리되는 각 리소스를 찾을 때는 해싱알고리즘을 사용한다.

해싱을 위한 해시 키로는 리소스 식별자가 사용된다. 각 해비 버킷에는 연결리스트로 연결된 해시 체인을 가지며 여기에 리소스 구조체가 연결된다.

Enqueue 방식으로 관리되는 특정 리로스에 대해 Lock을 획득하려면
먼저 리소스테이블에서 해당 리소스 구조체를 찾는다 만약 없다면 새로운 리소스 구조체를 할당 받아 해시 체인 연결 리스트에 연결한다.

그 후 리소스 구조체의 소유자 목록에 자신을 등록하면 된다. 호환되지 않는 모드로 먼저 Lock을 획득한 세션이 있다면 Lock 요청을 대기자 목록에 등록하고 대기해야 한다.

소유자가 Exclusive 모드일 때는 한 순간에 하나의 세션만 Lock을 획득할 수 있지만. Shared 모드일때는 여러 세션이 동시에 Lock을 획득할 수 있다.

Enqueue Lock의 작동 메커니즘

-   A세션이 Shared모드로 Lock을 획득한다.
-   B세션이 Shared모드로 Lock을 획득하려고 한다.

    -   먼저 Lock을 소유한 A세션과 호환되므로 정상적으로 Lock을 획득한다.

-   C세션이 Exclusive모드로 Lock을 획득려고 한다. 호환성이 없으므로 대기자 목록에 자신을 등록하고 기다린다.

-   소유자 목록에 Shared모드로 달려있던 A, B 세션이 해제하면 C세션이 Exclusive 모드로 소유자 목록에 등록된다.

-   A세션이 다시 Exclusive 모드로 다시 Lock을 획득하려고 하면, Exclusive 모드와 호환되지 않으므로 대기자 목록에 자신을 등록하고 기다린다.

-   B세션이 다시 Shared 모드로 Lock을 획득하려고 할때도 호환되지 않으므로 대기자 목록에 등록한다.

-   Enqueue Lock은 순서가 보장되므르 C세션이 Lock을 해제하면 A세션이 가장 먼저 Exclusive모드로 Lock을 획득한다.

## TX Lock(트랜잭션 Lock)

트랜잭션을 시작하려면 먼저 Undo 세그먼터 헤더에 위치한 트랜잭션 테이블로부터 슬롯을 하나 할당받아야 한다.

이 트랜잭션이 변경을 가한 블록에 대한 Consistent버전을 얻으려는 다른 트랜잭션은 트랜잭션 슬롯에 기록된 상태 정보를 확인하고 필요하다면 CR블록을 생성해서 읽는다.

이 방식으로 오라클은 읽기작업에 대해서는 블로킹 없이 작업을 진핼할 수 있도록 구현하였다.

변경 중인 레코드를 동시에 변경하려는 트랜잭션에 대해서는 액세스를 직렬화 해야 하며, 그 목적으로 사용하는 Lock 메커니즘이 트랜잭션 Lock이다.

`TX Lock은 트랜잭션이 첫 번째 변경을 시작할 때 얻고, 커밋 또는 롤백할떄 해제한다.`

TX Lock도 Enqueue Lock으로 구현되었다.

-   TYPE : TX
-   ID1 : Undo 세그먼트 + 트랜잭션 슬롯번호
-   ID2 : 트랜잭션 슬롯 Sequence 번호

이 식별자를 갖는 리소스 구조체를 Enqueue 리소스 테이블 해시 체인에 연결하고, 소유자 목록에 트랜잭션을 등록함으로 써 Lock을 획득한다.

TX Lock 메커니즘

-   TX1 트랜잭션은 Undo 세그먼트에서 트랜잭션 슬롯을 할당 받고, Enqueue 리소스를 통해 TX Lock을 설정한다. 이상태에서 r1~ r5 까지 5개의 레코드를 변경하고 아직 커밋은 하지않았다.

-   TX2 트랜잰션도 트랜잭션 테이블에서 하나의 슬롯을 할당 받고, Enqueue 리소르를 통해 TX Lock을 설정한 후 r6 레코드를 변경한다.

-   TX2가 r3 레코드를 액세스하려는 순간 호환되지 않는 모드로 Lock이 걸려 있음을 인지하고 TX1 트랜잭션 슬롯 상태를 확인한다.

-   TX1이 아직 커밋되지 않은 Active 상태이므로 TX2는 TX1이 Lock을 설정한 Enqueue 리소스 구조체 대기자 목록에 자신을 등록하고 대기 상태로 들어간다.

-   TX2는 대기하면서 3초마다 한번씩 TX1이 설정한 TX Lock의 상태를 확인한다. 교착상태 발생 여부를 확인하기 위함

-   TX1이 커밋 또는 롤백하면, TX1이 설정한 TX Lock의 대기자 목록에서 가장 우선순위가 높은 TX2트랜잭션을 깨워 재개하도록 한다.

-   TX2는 r3레코드를 변경한다.

```sql
-- v$lock을 통해 TX LOCK을 조회할 수 있다.
-- 더 자세한 모니터링 방식 P133
select sid, type, id1, id2, lmode, request, block
     , to_char(trunc(id1/power(2,16))) USN
     , bitand(id1, to_number('ffff', 'xxxx')) + 0 SLOT
     , id2 SQN
 from v$lock
 where type = 'TX'
```

## TX Lock 무결성 제약 위배 가능성 또는 비트맵 인덱스 엔트리 갱신

로우 Lock 경합은 일반적으로 update나 delete시에만 발생한다. insert는 새로운 레코드를 삽입하는 것이므로 로우 Lock경합이 발생하지 않는다.

하지만 테이블에 Unique 인덱스가 정의되어 있을 떄는 insert에 의한 로우 Lock 경합이 발생할 수 있다.

두 개 이상 트랜잭션이 같은 값을 입력하려 할 때, 선행 트랜잭션이 아직 진행 중이라면 값의 중복 여부가 확정되지 않았으므로 후행 트랜잭션은 진행을 멈추고 대기해야만 하는 것

-   트랜잭션 TX1이 dept 테이블에 deptno = 40 레코드를 삽입한다.

-   TX2가 deptno = 40인 레코드를 입력하면 TX1이 커밋 또는 롤백할 떄까지 shared 모드로 enq: TX - row lock contention 대기 이벤트가 발생한다.

-   TX1이 커밋하면 TX2는 ORA-0001 에러를 만나게된다 (무결성 제약 오류)

-   TX1이 롤백하면 TX2는 정상적으로 입력된다.

-   반대로 부모 pk를 지우고 자식에 부모pk에 해당하는 레코드를 입력할 때도 마찬가지

비트맵 인덱스 엔트리에 대한 갱신을 수행할 떄도 Shared 모드로 enq : TX - row lock contention 이벤트가 발생할 수 있다.

## TX Lock ITL 슬롯 부족

블록에 레코드를 추가/갱신/삭제 하려면 ITL 슬롯을 먼저 할당 받고 그 곳에 트랜재션 ID를 먼적 기록해야 한다.

비어있는 ITL 슬롯이 없다면 사용중인 트랜잭션 하나가 커밋 또는 롤백할 때까지 기대려야 하며

이때 Shared 모드 enq : TX - allocate ITL entry 대기 이벤트가 발생한다.

한 블록을 동시에 갱신할 수 있는 트랜잭션 개수는 ITL 슬롯에 의해 결정된다.

테이블에 insert할 때는, ITL슬롯이 부족하더라도 굳이 그 블록에 insert하려고 대기할 필요가 없다. 새 블록을 할당해 그 곳에 insert 하면 되기 때문

하지만 인덱스에 값을 삽입할 때는 정렬 상태를 유지해야 하므로 ITL 경합이 발생한다.

update, delete 일 때는 테이블, 인덱스를 불문하고 ITL 경합이 나타날 수 있다.

## TX Lock 인덱스 분할

인덱스는 정렬된 상태를 유지해야 하므로 아무 블록에나 값을 입력할 수 없다. 따라서 값을 입력할 위치에 빈 공간이 없으면 인덱스 분할을 실시해 새 값을 입력할 공간을 확보하게 되며, 이 과정에서 Lock 경합이 발생할 수 있다.

인덱스 분할이 진행되는 동안 그 블록에 새로운 값을 입력하려는 또다른 트랜잭션이 생길 수 있다.

두번째 트랜잭션은 선행 트랜잭션이 인덱스 분할을 완료할 때까지 대기해야 한다.

만약 TX Lock은 선행 트랜잭션이 커밋 또는 롤백할 때 비로소 해제되는데 만약 인덱스 분할을 진행한 트랜잭션이 커밋하지 않은 채 계속 다른 갱신 작업을 진행한다면 TX Lock을 대기하던 트랜잭션은 어떻게 될까?

오라클은 이 문제를 해결하기 위해 autonomous 트랜잭션을 사용한다.

-   TX1 트랜잭션이 인덱스에 로우를 삽입하려는 순간 빈 공간을 찾지 못했다. 인덱스 분할이 필요하다.

-   TX1 트랜잭션은 autonomous 트랜잭션 TX2를 생성해 인덱스 분할을 진행토록 한다.

-   인덱스 분할이 진행 중인 블록에 TX3 트랜잭션이 로우를 삽입하려고 한다. 이 트랜잭션은 enq: TX - index contention 이벤트를 만나게 되고, TX2 트랜잭션이 커밋할 때까지 대기한다.

-   인덱스 분할이 완료되면 TX2 트랜잭션은 커밋한다. autonomous 트랜잭션이므로 TX1은 커밋되지 않은 상태로 계속 트랜잭션을 진행할 수 있다.

-   TX3 트랜잭션도 작업을 재개한다.

## TX Lock 기타 트랜잭션 Lock

앞에서 열거한 중요한 TX Lock 이외의 트랜잭션 대기 상황

ex. 읽기 전용 테이블 스페이스로 전환

## TX Lock DML 로우 Lock

DML Lock은 다중 사용자에 의해 동시에 액세스되는 사용자 데이터의 무결성을 보호해 준다.

DML 수행 중에 호환되지 않는 다른 DML 또는 DDL 오퍼레이션의 수행을 방지 시켜 주는 것

그중 로우 Lock은 두 개의 동시 트랜잭션이 같은 로우를 변경하는 것을 방지한다. 하나의 로우를 변경하려면 로우 Lock을 먼저 획득해야 한다.

오라클은 로우 Lock을 `로우 단위 Lock과 TX Lock을 조합해서 구현`하였다.

로우를 갱신하려면 Undo 세그먼트에서 트랜잭션 슬롯을 먼저 할당받고, `Enqueue 리소스를 통해 TX Lock을 획득한다.`

그후 DML 문장을 통해 갱신하는 각 로우마다 `Exclusive 모드로 로우 단위 Lock을 획득한다.` TX Lock은 트랜잭션을 시작할 때 한 번 만획득한다.

`로우 단위 Lock` TX1 트랜잭션이 로우 정보를 갱신할 때는, 블록 헤더 ITL슬롯에 트랜잭션 ID를 기록하고 로우 헤더에 이를 가리키는 Lock Byte를 설정한다.

이 레코드를 액세스하려는 다른 트랜잭션은, 로우 헤더에 설정한 Lock Byte를 통해 ITL 슬롯을 찾고 ITL 슬롯이 가리키는 Undo 세그먼트 헤더의 트랜잭션 슬롯에서 트랜잭션 상태 정보를 확인함으로써 해당 레코드에 대한 액세스 가능 여부를 결정한다.

TX1 트랜잭션이 진행중일 때 이 레코드를 읽으려는 TX2 트랜잭션은 TX1 트랜잭션의 상태를 확인하고 CR블록을 생성해서 읽기 작업을 완료한다.

TX1이 갱신중인 레코드를 같이 갱신하려는 TX2 트랜잭션은 TX1트랜잭션이 완료될 때까지 대기해야 한다. 이를 위해 TX Lock이 필요하다

오라클은 로우 갱신 시 ITL을 이용해 락 정보를 저장하고, 다른 트랜잭션은 이 정보를 통해 Undo를 사용해 CR 블록을 만들어 일관된 데이터를 읽는다.

`로우 단위 Lock : 블록 헤더 ITL과 로우 헤더 Lock Byte 설정을 의미함. 이를 통해 로우를 갱신중인 트랜잭션 상태를 확인하고 액세스 가능 여부를 결정함.`

`TX Lock : Enqueue 리소스를 통해 TX Lock을 설정하는 것을 의미함 Lock이 설정된 레코드를 갱신하고자 할 때 Enqueue 리소스에서 대기함`

## TM Lock DML 테이블 Lock

오라클은 로우 Lock 획득시 해당 테이블에 대한 테이블 Lock도 동시에 획득한다.

현재 트랜잭션이 갱신중인 테이블에 대한 호환되지않은 DDL 오퍼레이션을 방지한다.

테이블 Lock은 주로 DDL과 관련있지만 DML 문 간에도 테이블 Lock을 이용해 동시성을 제어할 때가 있다.

오라클은 변경 작업에만 로우 Lock을 사용하므로 로우 Lock은 항상 Exclusive모드다.

하지만 테이블 Lock에는 여러 가지 Lock모드가 사용되며 호환성이 다르다.

선행 트랜잭션과 호환되지 않는 모드로 테이블 Lock을 설정하려는 후행 트랜잭션은 대기해야 한다.

DML 문을 위해 로우 Lock을 설정하려면 해당 테이블에 RX 모드 테이블 Lock을 먼저 획득해야 한다.

select for update 문을 위해 로우 Lock을 설정하려면 RS 모드 테이블 Lock을 먼저 획득해야 한다.

RS, RX간에는 어떤 조합으로도 호환이 되므로 select for update나 DML문 수행시 이들 간에는 테이블 Lock에 의한 경합은 절대 발생하지 않는다.

다만 같은 로우를 갱신하려 할 때 로우 Lock에 의한 경합은 발생한다.

오라클은 테이블 Lock도 Enqueue로 구현하였으며 TM Enqueue라고 부른다. TML Lock이라고 부르기도 한다.

-   TYPE : TM
-   ID1 : 오브젝트 ID
-   ID2 : 0

`테이블 Lock 은 Lock을 획득한 선행 트랜잭션이 해당 테이블에서 어떤 작업을 수행중인지 알리는 일종의 푯말이다. `

테이블 Lock은 DDL과의 동시 진행을 막으려고 사용될 뿐만 아니라 DML간 동시성을 제어하려고 사용되기도 한다.

병렬 DML 또는 Direct Path Insert 방식으로 작업을 수행할 떄가 그렇다.

## Lock을 푸는 열쇠, 커밋

교착상태와 블로킹은 엄연히 다르다.

블로킹은 Lock경합이 발생해 특정 세션이 작업을 진행하지 못하고 멈춰있는 경우를 말하며 커밋 또는 롤백으로 해소

데드락은 두 세션이 각각 Lock 설정한 리소스를 서로 액세스 하려고 마주보고 진행하는 상황을 말하며 둘 중 하나가 뒤로 물러나지 않으면 영영 풀릴 수 없다.

오라클에서 교착상태가 발생하면 이를 먼저 인지한 세션이 문장수준 롤백을 진행 한 후 에러 메시지를 남긴다.

교착 상태를 발생시킨 문장 하나만 롤백하는 것

> ORA-00060 : deadlock detected while waiting for resource

교착상태는 해소됬지만 블로킹 상태에 놓이게 된다. 따라서 이 메시지를 받은 세션을 커밋 또는 롤백을 결정해야만 한다.

만약 프로그램 내에서 이 에러에 대한 예외처리(커밋 또는 롤백)를 하지 않는다면 대기 상태를 지속하게 되므로 주의가 필요하다.

불필요하게 트랜잭션을 너무 길게 정의하지 않도록 주의해야 한다. 트랜잭션이 너무 길면, 트랜잭션을 롤백해야 할 때 너무 많은 시간이 걸려 고생할 수 있다. (Undo 세그먼트 고갈 or Undo 세그먼트 경합)

불필요하게 커밋을 너무 자주 수행하면 Snapshot too old에러를 유발할 가능성이 높아지고 LGWR이 로그 버퍼를 비우는 동안 발생하는 log file sync 대기 이벤트 때문에 성능 저하 현상을 겪을 수 있다.

# DB 버퍼 캐시

빠른 데이터 입출력을 위해 SGA 공유 메모리를 이용 구체적으로는 사용자가 입력한 데이터를 데이터 파일에 저장하고 이를 다시 읽는 과정에서 거쳐가는 캐시 영역은 SGA 구성요소 중 하나인 DB 버커 패시이다.

## 블록 단위 I/O

오라클에서 I/O는 블록 단위로 이루어지는데, 메모리 버퍼 캐시에서 버퍼 블록을 액세스할 때뿐만 아니라

데이터 파일에 저장된 데이터 블록을 DB버퍼 캐시로 적재하거나 캐시에서 변경된 블록을 다시 데이터 파일에 저장할 때도 블록 단위로 처리한다.

`데이터 파일에서 버퍼 캐시로 블록을 적재할 때, 인덱스를 경유한 테이블 액세스 시에는 한번에 한 블록씩 읽어 들이지만 Full Scan시에는 성능 향상을 위해 한 번에 여러 개 블록을 읽어들인다.`

DBWR 프로세스는 버퍼 캐시로부터 변경된 블록(Dirty 버퍼 블록)을 주기적으로 데이터파일에 기록하는 작업을 수행하는데, 이때도 성능향상을 위해 한번에 여러 블록을 처리한다.

`블록 단위로 읽는다는 의미는 하나의 레코드에서 하나의 컬럼만 읽고자 하더라도 레코드가 속한 블록 전체를 읽게 됨을 의미`

SQL 성능을 좌우하는 가장 중요한 성능 지표는 액세스하는 블록 개수이며, 옵티마이저의 판단에 가장 큰 영향을 미치는 것도 액세스해야 할 블록 개수다.

옵티마이저가 인덱스를 이용해 테이블을 액세스할지 아니면 Full Table Scan 할지를 결정하는 데 있어 중요한 판단 기준은 읽어야 할 레코드 수가 아니라 블록 개수다.

## 버퍼 캐시 구조

SGA내에는 수없이 많은 자료구조가 사용되고 있으며 그 중 가장 많이 사용되는 것이 해시 태이블(또는 맵)이고, DB 버퍼 캐시도 해시 테이블 구조로 관리된다.

해시 버킷 내에서는 스캔 방식으로 값을 찾는다. 그렇더라도 키 값을 해시 값으로 변환해 해시 버킷을 찾아가는 속도가 워낙 빨라서 각 버킷에 기록되는 엔트리 개수를 일정 수준으로 유지할 수만 있다면 해싱에 의한 검색 속도가 가장 빠르다고 알려져 있다.

DB 버커 캐시 내에서 데이터 블록을 해싱하기 위해 사용되는 키 값은 데이터 블록 주소다(DBA Data Block Address)

해시 함수에 데이터 블록 주소를 입력해 리턴받은 해시 값이 같은 블록들을 같은 해시 버킷에 연결 리스트 구조로 연결하는 것

각각의 연결 리스트를 해시 체인이라고 한다.

찾고자 하는 데이터 블록주소를 해시 값으로 변환해서 해당 해시 버킷에서 체인을 따라 스캔하다가 거기서 찾아지면 바로 읽고 못찾으면 디스크에서 읽어 해시 체인에 연결한 후 읽으면 된다.

자신만 읽고 버리는 게 아니라 다른 사용자 들로 사용할 수 있도록 캐싱해 두는 것

`버퍼 블록이 통째로 해시 구조로 관리되는 것처럼 보이지만 정확히 표현하면 버퍼 헤더만 해시 체인에 연결되며 실제 데이터 값이 필요해지면 버퍼 헤더에 있는 포인터를 이용해 다시 버퍼 블록을 찾아가는 구조`

## 캐시 버퍼 체인

각 해시 체인은 래치(Latch)에 의해 보호된다. DB 버퍼 캐시는 공유 메모리 영역인 SGA 내에 존재하므로 여러 프로세스에 의한 동시 액세스가 일어날 가능성이 크다.

따라서 같은 리소스에 대한 액세스를 반드시 직렬화 해야하고, 이를 위해 구현된 일종의 Lock 메커니즘을 래치라고 부른다.

래치를 획득한 프로세스만이 그 래치에 의해 보호되는 자료구조로의 진입이 허용된다.

두 개 이상의 프로세스가 같은 해시 체인으로 진입해 새로운 버퍼 블록을 연결하고 해제하는 작업을 동시에 진행한다면 문제가 발생할 수 있고 이를 방지하기 위애 사용하는 것이 cache buffers chains 래치다.

하나의 cache buffers chains 래치가 여러 개 해시 체인을 동시에 관리한다는 사실도 기억할 필요가 있다.

하나의 체인에 하나의 버퍼만 달리는 것을 목표로 삼아야 하며 그래야 목표한 해시 체인을 찾고서 추가적으로 스캔하는 비용을 최소화할 수 있다.

그러려맨 해시 버킷 개수가 충분히 많아야 한다.

오라클 9i 부터 읽기전용 작업일 때는 cache buffers chains 래치를 Share모드로 획득할 수 있다.(select 문을 말하는 것이 아닌 해시 체인을 스캔하면서 필요한 블록을 읽는 작업을 말한다.)

그러므로 9i 이후 버전에서 Share 모드로 래치를 사용하는 것과 상관없이 select 문장을 동시에 수행하면 여전히 cache buffers chains 래치 경합이 발견된다.

래치는 데이터 자체를 보호하는 게 아니라 SGA에 공유돼 있는 자료구조를 보호하는 것이며, 그중 cache buffers chains 래치는 버퍼 캐시에 연결된 체인구조를 보호한다.

즉 해시 체인을 스캔하거나 거기에 블록을 추가, 제거할 때 래치가 요구된다.

cache buffers chains 래치의 중요한 용도가 한 가지 더 있는데, 버퍼 헤더에 Pin을 설정할 때

## 캐시 버퍼 LRU 체인

버퍼 헤더는 해시 체인 뿐 아니라 LRU 체인에 의해서도 연결돼 있다.

DB 버퍼 캐시는 한번 읽은 데이터 블록을 캐싱해 두는 메모리 공간이지만 메모리는 유한한 자원이어서 모든 데이터를 캐싱할 수는 없는 일이다.

따라서 버퍼 캐시가 사용빈도가 높은 데이터 블록들 위주로 구성될 수 있도록 LRU(least recently used)알고리즘을 사용해 관리된다.

모든 버퍼 블록 헤더를 LRU 체인에 연결해 사용빈도 순으로 위치를 옮겨 가다가 Free 버퍼가 필요하질 때마다 액세스 빈도가 낮은 데이터 블록들을 우선하여 밀어냄으로써 자주 액세스되는 블록들이 캐시에 오래 남아 있도록 관리하는 것

LRU 리스트에는 내부적으로 두개의 리스트를 갖는다.

-   Dirty 리스트 : 캐시 내에서 변경됐지만 아직 디스크에 기록되지 않은 Dirty 버퍼블록들을 관리하며 `LRUW(LRU Write)리스트` 라고도 한다.

-   LRU 리스트 : 아직 Dirty리스트로 옮겨지지 않은 나머지 버퍼 블록들을 관리한다.

모든 버퍼 블록들은 위 두 리스트중 하나에 반드시 속하지만 읽기 또는 쓰기 작업을 위해 액세스 되는 동안에는 리스트에서 잠시 풀려나왔다가 다시 원래의 리스트로 연결되거나, 최초 변경이 발생하였을 때는 Dirty 리스트로 옮겨간다.

참고로 LRU 리스트를 보호하기 위한 래치를 cache buffers lru chain 래치라고 한다.

### 버퍼 상태

모든 캐시 버퍼는 아래 세 가지중 하나의 상태에 놓이게 된다.

-   Free 버퍼 : 인스턴스 기동 후 아직 데이터가 읽히지 않아 비어있는 상태 이거나 데이터가 담겼지만 데이터파일과 서로 동기화돼 있는 상태여서 언제든지 덮어 써도 무방한 버퍼 블록을 말한다.

    -   데이터 파일로 부터 새로운 데이터 블록을 로딩하려면 먼저 Free 버퍼 를 확보해야 한다.

    -   Free상태인 버퍼에 변경이 발생하면 Dirty 버퍼로 상태가 바뀐다.

-   Dirty 버퍼 : 버퍼에 캐시된 이후 변경이 발생했지만 아직 디스크에 기록되지 않아 데이터 파일 블록과 동기화가 필요한 버퍼 블록을 말한다.

    -   이 버퍼 블록들이 다른 데이터 블록을 위해 재사용되려면 먼저 디스크에 기록되어야 하며 기록되는 순간 Free버퍼 상태가 된다.

-   Pinned 버퍼 : 읽기 또는 쓰기 작업을 위해 현재 액세스 되고 있는 버퍼 블록을 말한다.

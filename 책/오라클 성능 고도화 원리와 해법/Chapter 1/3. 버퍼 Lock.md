# 버퍼 Lock

## 버퍼 Lock 이란?

DB 버퍼 캐시 내에서 버퍼 블록을 찾았으면 가급정 빨리 쥐고 있던 래치를 해제해야 한다.

그렇지 않으면 하나의 cache buffers chains 래치에 여러 개의 해시 체인이 달렸으므로 래치에 대한 경합 발생 가능성이 증가하게 된다.

만약 버퍼에 먼저 접근한 프로세스가 아직 버퍼를 사용 중이라면? 아주 짧은 순간일지라도 두 개 이상의 프로세스가 동시에 버퍼 내용을 읽고 쓴다면 문제가 생길 수 있는 것

이를 막기 위해 캐시된 버퍼 블록을 읽거나 변경하려는 프로세스는 먼저 버퍼 헤더로부터 버퍼 Lock을 획득해야 한다.

`버퍼 Lock을 획득했다면 래치를 곧바로 해제한다.`

버퍼 내용을 읽기만 할 때는 Share 모드, 변경할 떄는 Exclusive 모드로 Lock을 설정한다.

액세스를 직렬화하기 위한 메커니즘이므로 당연히 Exclusive 모드Lock은 한 시점에 하나의 프로세스만 얻을 수 있다.

select 문이더라도 블록 클린아웃이 필요할 때는 버퍼 내용을 변경하는 작업이므로 Exclusive 모드 Lock을 요구한다.

만약 해시 체인 래치를 획득하고 목적한 버퍼를 찾았는데 다른 프로세스가 버퍼 Lock을 Exclusive 모드로 점유한채 내용을 갱신 중이라면 래치를 쥔 채 기다릴 수는 없다.

그럴 때는 버퍼 헤더에 있는 버퍼 Lock 대기자 목록에 자신을 등록하고 일단 래치는 해제한다. 이때 버퍼 Lock 대기자 목록에 등록돼 있는 동안 buffer busy waits 대기 이벤트가 발생한다.

대기자 목록에서 기라디라가 버퍼 lock이 해제되면 버퍼 lock을 획득하고 원했던 작업을 진행한다.

버퍼 lock을 해제할때도 버퍼 헤더를 액세스하려는 다른 프로세스와 충돌이 발생할 수 있으므로 해당 버퍼가 속한 체인 래치를 획득하고 lock을 해제 래피를 해제해야 버퍼 블록 읽기가 완료된다.

읽고자 하는 블록이 없다면 디스크 I/O까지 수반되므로 블록 읽기 작업은 고비용 작업이다.

Oracle에서 데이터 블록을 읽거나 수정할 때는

1. 먼저 **해시 체인을 따라 블록을 찾아야 하고**
2. 이후 **블록 자체에 대한 접근 제어**가 필요함

이 두 과정을 보호하기 위해 각각 다음과 같은 동기화 기법이 사용됨:

| 단계         | 역할                           | 보호 도구                      |
| ------------ | ------------------------------ | ------------------------------ |
| 🔍 블록 탐색 | 해시 체인을 순회하여 블록 찾기 | **cache buffers chains latch** |
| 🧱 블록 접근 | 찾은 블록에 대해 읽기/쓰기     | **buffer lock (buffer pin)**   |

### 🔹 cache buffers chains latch

-   버퍼 캐시 내부의 **해시 체인(bucket chain)** 구조 보호
-   블록을 **찾기 전에 획득**
-   매우 짧게 유지되지만, 접근 빈도가 높아 **경합 발생 가능**
-   대기 이벤트: `latch: cache buffers chains`

---

### 🔹 buffer lock (buffer pin)

-   **특정 블록**에 대한 **읽기/쓰기 작업** 보호
-   블록을 **찾은 이후 획득**
-   해당 스레드가 블록을 사용하는 동안 유지
-   관련 대기 이벤트: `buffer busy waits`

---

### ✅ 두 락의 비교 요약

| 항목           | cache buffers chains latch        | buffer lock (buffer pin)       |
| -------------- | --------------------------------- | ------------------------------ |
| 보호 대상      | 해시 체인 구조 (블록을 찾는 경로) | 특정 데이터 블록               |
| 획득 시점      | 블록을 **찾기 전**                | 블록을 **찾은 후**             |
| 유지 시간      | 매우 짧음 (μs 단위)               | 작업하는 동안 유지             |
| 경합 발생 원인 | 동일 체인에 접근하는 다중 세션    | 동일 블록을 요청하는 다중 세션 |
| 대기 이벤트    | `latch: cache buffers chains`     | `buffer busy waits`            |

### ✅ 결론

-   `cache buffers chains latch`는 **블록 탐색 과정에서의 데이터 구조 보호**
-   `buffer lock`은 **블록 자체에 대한 읽기/쓰기 충돌 방지**
-   두 락은 **목적과 시점이 다르며**, 모두 Oracle의 성능 병목 지점이 될 수 있음

## 버퍼 핸들

버퍼 Lock을 설정하는 것은 자신이 현재 그 버퍼를 사용중임을 표시하는 것으로 버퍼 헤더에 Pin을 걸었다고도 표현한다.

버퍼 Lock의 다른말로 버퍼 Pin이라고 표현하기도 하며 앞에서 말한 Pinned 버퍼가 여기에 해당

변경 시에는 하나의 프로세스만 Pin을 설정할 수 있지만 읽기 작업을 위해서라면 여러 개 프로세스가 동시에 Pin을 설정할 수 있다.

버퍼 헤더에 Pin을 설정하려고 사용하는 오브젝트를 버퍼 핸들이라고 부르며 버퍼 핸들을 얻어 버퍼 헤더에 있는 소유자 목록에 연결시키는 방식으로 Pin을 설정한다.

버퍼 핸들도 공유된 리소스이므로 버퍼 핸들을 얻으려면 또 다른 래치가 필요해 지는데 바로 cache buffer handles 래치가 그것이다.

버퍼를 Pin하는 오퍼레이션이 많을 수록 오히려 cache buffer handles 래치가 경합 지점이 될 것이므로 오라클은 각 프로세스마다 \_db_handles_cached 개수만큼 버퍼 핸들을 미리 할당해 주며 기본값은 5개다.

각 세션은 이를 캐싱하고 있다가 버퍼를 Pin할 떄마다 사용하며, 그이상의 버퍼 핸들이 필요할 때만 cache buffer handles 래치를 얻고 추가로 버퍼 핸들을 할당받는다

시스템 전체적으로 사용할 수 있는 총 버퍼 핸들 개수는 \_db_handles 파라미터에 의해 결정되며, 이는 processes 파라미터와 \_db_handles_cached 파라미터를 곱한 값으로 설정ㄷ된다.

## 버퍼 Lock 의 필요성

사용자 데이터를 변경할때는 DML Lock을 통해 보호하도록 돼 있는데, 그것을 담는 블록에 또 다른 Lock을 획득해야 하는 이유가 궁금할 수 있다.

이유는 오라클이 하나의 레코드를 갱신하더라고 블록 단위로 I/O를 수행하기 때문

블록 안에 저장된 10개 레코드를 읽는 짧은 순간 동안 다른 프로세스에 의해 변경이 발생하면 잘못된 결과를 얻게된다.

> Consistent 모드 읽기로 변경된 값은 Undo에서 읽으면 된다고 생각할지도 모르지만 그렇지 않다.

> Consistent 모드 읽기는, 쿼리 SCN과 블록 SCN을 비교해 읽어도 되는 블록인지 확인하면서 읽는 것을 말한다 읽을 수 있는 버전임을 확인하고 읽기 작업을 시작했는데 동시에 다른 프로세스에 의해 값이 변경될 수 있기 때문에 버퍼 Lock이 필요한 것

그리고 값을 변경하기 전에 레코드에 로우 단위 Lock을 설정하는 일 자체도 레코드의 속성을 변경하는 작업이므로 두 개의 프로세스가 동시에 로우 단위 Lock을 설정하려고 시도한다면(대상 로우가 다르더라도) 문제가 된다.

블록 헤더 내용을 변경하는 작업도 동시에 일어날 수 있는데 이런 동시 액세스가 실제로 발생한다면 Lost Update 문제가 생겨 블록 자체의 정합성이 깨지게 된다. 따라서 블록 자체로의 진입을 직렬화 해야 하는 것이다.

Pin된 버퍼 블록은 버퍼 캐시 전체를 비우려고 아래 시스템 명령어를 날리더라도 밀려나지 않는다.

> SQL : alter system flush buffer_cache;

## 버퍼 Pinning

버퍼 Pinning은 버퍼를 읽고나서 버퍼 Pin을 즉각 해제하지 않고 데이터베이스 call이 진행되는 동안 유지하는 기능을 말한다.

같은 블록을 반복적으로 읽을 때 버퍼 Pinning을 통해 래치 획득 과정을 생략한다면 논리적인 블록 읽기 횟수를 획기적으로 줄일 수 있다.

모든 버퍼 블록을 이 방식으로 읽는 것은 아니며, 같은 블록을 재 방문할 가능성이 큰 몇몇 오퍼레이션을 수행할 때만 사용한다.

v$sysstat, v$sesstat, v$mystat 등을 조회해 보면, 래치 획득 과정을 통해 블록을 액세스할 때는 session logical reads 항목이 증가하고, 래치 획득 과정 없이 버퍼 Pinning을 통해 블록을 곧바로 액세스할 때는 buffer is pinned count 항목의 수치가 증가한다.

버퍼 Pinning은 하나의 데이터베이스 Call(Parse Call, Execute Call, Fetch Call)내에서만 유효하다.

Call이 끝나고 사용자한테 결과를 반환하고 나면 Pin은 해제되어야 한다. 따라서 첫 번째 fetch call 에서 pin 된 블록은 두 번째 fetch call에서 다시 래치 획득 과정을 거쳐 pin되어야 한다.

`전통적으로 버퍼 Pinning이 적용되던 지점은 인덱스를 스캔하면서 테이블을 액세스할 때의 인덱스 리프 블록이다.
Index Range Scan 하면서 인덱스와 테이블 블록을 교차 방문할 때 블록 I/O를 체크해 보면, 테이블 블록에 대한 I/O만 계속 증가하는 이유가 여기에 있다.`

인덱스를 경유해 테이블을 액세스할 떄 인덱스 클러스터링 팩터가 좋다면 같은 테이블 블록을 반복 액세스할 가능성이 그만큼 커진다.

그래서 오라클 8i 부터 인덱스로부터 액세스되는 하나의 테이블 블록을 Pinning하기 시작했다.

실제 클러스터링 팩터가 좋은 인덱스를 경유해 테이블 액세스해 보면 논리적 블록 읽기 횟수가 매우 적게 나타나는 것을 관찰할 수 있다.

9i부터는 NL조인시 Inner 테이블을 룩섭 하기 위해 사용되는 인덱스 루트 블록을 Pinning하기 시작했다.

Index Skip Scan에서 브랜치 블록을 거쳐 리프 블록을 액세스 하는 동안에도 브랜치 블록을 계속 Pinning하고 있다가 그 다음 방문할 리프 블록을 찾으려 할때 추가적인 래치 획득과정 없이 브랜치 블록을 곧바로 읽는다.

11g 부터는 NL조인시 Inner 테이블의 루트블록 뿐 아니라 다른 인덱스 블록에 대해서도 Pinning을 함으로써 논리적 블록 읽기는 획기적으로 감소시키고 있다.

이외에도 DML 수행시 Undo 레코드를 기록하는 Undo블록에 대해서도 Pinning을 적용한다.

버퍼 Lock은 매우 Internal한 메커니즘이어서 이해하기 쉽지 않을 뿐 아니라 굳이 몰라도 상관없는 내용들이다.

다만 버퍼Pinning을 통한 블록 I/O 감소 효과는 SQL을 튜닝하는 데 있어 워낙 중요한 내용이므로 이 원리만큼은 기억할 필요가 있다.

인덱스를 통해 얼마 안되는 테이블 레코드를 읽는데도 성능이 매우 안좋을 때가 있는가 하면 대량의 데이터를 읽을 때도 빠를때가 있는데

인덱스 클러스터링 팩터와 관련이 있고 그 이면에는 버퍼 Pinning원리가 숨어 있다.

실제로 도저히 튜닝 방안을 찾을 수 없을 때 버퍼 Pinning효과를 노려 가장 액세스 빈도가 높은 인덱스 키 순서대로 테이블레코드를 재정렬 함으로써 성능을 획기적으로 개선한 사례가 있다.

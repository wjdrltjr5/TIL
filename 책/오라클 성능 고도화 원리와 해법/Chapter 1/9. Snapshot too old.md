# Snapshot too old

Snapshot too old(ORA-01555)에 대한 발생원인은 크게 두가지로 정리할 수 있다.(Undo 세그먼트가 손상되는 등의 물리적인 원인은 제외)

-   데이터를 읽어 내려가다가 쿼리 SCN 이후에 변경된 블록을 만나(이미 앞서 읽었던 블록을 다시 방문하는 경우일 수도 있음) 과거 시점으로 롤백한 Read Consistent 이미지를 얻으려고 하는데, Undo블록이 다른 트랜잭션에 의해 이미 재사용돼 필요한 Undo 정보를 얻을 수 없는 경우

    -   이경우 프로그램 코딩 패턴에 문제가 없다면 Undo 세그먼트가 너무 작다는 신호일 수 있다.

-   커밋된 트랜잭션 테이블 슬롯이 다른 트랜잭션에 의해 재사용돼 커밋 정보를 확인할 수 없는 경우
    -   Undo 세그먼트가 너무 작다는 신호일 수 있다.

## Undo 실패

고객별 미납금액을 계산하는 쿼리가 1시간쯤 걸린다고 가정했을때

-   SCN 123 시점에 이 쿼리가 시작
-   은행으로부터 고객의 입금내역을 전송받아 일괄 처리하는 배치 프로그램이 수행
    -   프로그램은 각 건별로 커밋하도록 작성
    -   프로그램이 돌기 시작한지 얼마 지나지 않아 홍길동 고객의 수납액을 10000 -> 20000으로 변경후 커밋
    -   이때 블록 SCN은 129로 변경
-   시간이 흘러 홍길동 고객의 수납액 변경내역을 담은 Undo 블록이 다른 트랜잭션에 의해 재사용되었다.
-   미납금액 계산 쿼리가 홍길동 고객 수납액이 담긴 블록에 도달했을때
    -   블록 SCN이 쿼리 SCN보다 크므로 CR만들기 위해
    -   변경된 Undo레코드를 찾으려고 ITL 엔트리에 기록된 UBA를 읽어 Undo세그먼트를 찾아간다.
    -   하지만 이지 매사용된 상태이므로 ORA-01555 에러를 발생시키면 진행을 멈춘다.

대량의 데이터를 기준으로 NL 조인을 하면 오래 걸릴 뿐 아니라 inner 테이블에 대해 같은 블록을 반복해서 방분할 가능성이 커진다. (등가조건이면 해시 조인 아니면 소트머지조인)

여러 세션에서 동시에 트랜잭션이 몰리지 않더라도 한 세션에서 독립적으로 수행되는 도중에 Snapshot too old 에러가 발생할 수 있다.

결국 Undo블록이 이전정보를 얻기 위한 롤백 CR블록을 생성하기 전에 재사용 되버리면 Snapshot too old 에러가 발생

## 블록 클린아웃 실패

대량 업데이트 후에 커밋된 트랜잭션은 변경했던 블록들을 모두 클린아웃 하지 않은 상태에서 자신이 사용하던 트랜잭션 테이블 슬롯을 Free 상태로 변경하고 트랜잭션을 완료한다.

이때부터 그 트랜잭션 테이블 슬롯은 다른 트랜잭션에 의해 재사용될 수 있다.

시간이 흘러 그 변경된 블록들이 읽혀야 하는 시점에 Delayed 블록 클린아웃을 위해 트랜잭션 테이블 슬록을 찾아갔는데 이미 재사용 되고 없다면 정상적인 블록 클린아웃과 일관성 모드 읽기가 불가능해질 수 있다.

오라클은 일반 데이터 블록과 마찬가지로 Undo 세그먼트 헤더 블록을 갱신한 내용도 Undo 레코드로서 기록한다.

따라서 트랜잭션 테이블 슬롯이 덮어 쓰인 것을 발견하면 우선 Undo 세그먼트 헤더 블록에 가해진 변경사항을 롤백하려고 시도한다.

찾고자 하는 트랜잭션에 대한 커밋 정보가 Undo블록에 남아있다면 현재 읽고자 하는 블록의 정확한 커밋 SCN을 가지고 블록 커밋아웃을 수행할 수있다.

클린아웃에 필요한 트랜잭션 테이블과 Undo 정보는 언젠가 덮어 쓰이기 마련인데

갱신 후에 오랫동안 읽히지 않았던 블록이 언젠가 읽히면서 에외없이 Snapshot too old에러가 발생한다고 생각할 수 있는데 블록 클린아웃에 의핸 Snapshot too old 에러는 거의 발생하지 않는다.

트랜잭션 슬롯이 필요해지면 커밋 SCN이 가장 낮은 트랜잭션 슬롯부터 재사용하는데

해당 슬롯에 기록돼 있던 커밋 SCN을 Undo 세그먼트 헤더에 최저 커밋 SCN으로서 기록해 둔다.

트랜잭션 슬롯이 재사용되고 나면 그 슬롯을 사용하던 이전 트랜잭션의 정확한 커밋 SCN을 확인하는 것이 불가능해 지지만 Undo세그먼트 헤더에 기록돼있는 최저 커밋 SCN 이전에 커밋 되었다는 사실만큼은 짐작할 수 있다.

따라서 아직 클린아웃 되지 않은 블록을 클린아웃 하려고 ITL이 가리키는 트랜잭션 테이블 슬롯을 찾아갔을때 커밋정보가 없다면

Undo세그먼트 헤더에 있는 최저 커밋 SCN을 블록 ITL 엔트리에 커밋 SCN으로서 기록(추정) 함으로써 블록 클린아웃을 마무리하고, 블록 SCN도 변경한다.

쿼리가 진행되는 동안애 많은 트랜잭션이 한꺼번에 몰리지만 않는다면 최저 커밋 SCN이 많이 증가하지는 않을 것이므르 최저 커밋 SCN으로 추정된 블록 SCN은 대개 쿼리 SCN 보다 작다.

따라서 쿼리가 시작된 이후에 해당 블록에 변경이 가해지지 않았음이 확인되므로 정상적인 일관성 모드 읽기도 가능하다.

결론적으로 Snapshot too old가 발생하는 원인은 `최저 커밋 SCN`이 쿼리 SCN보다 높아질 정도로 갑자기 트랜잭션이 몰리는 데에 있으며,

이때는 추정에 의한 블록 SCN이 쿼리 SCN보다 높아지게 된다.

## Snapshot too old 회피방법

이 에러는 재현이 어려워 발생 원인을 찾는 것도 쉽지 않다. 에러 발생 가능성을 줄이기 위한 애플리케이션 측면에서의 솔루션들

-   불필요하게 커밋을 자주 수행하지 않는다.

-   fetch across commit 형태의 프로그램 작성을 피해 다른 방식으로 구현한다.

    -   ANSI 표준에 따르면 커밋 이전에 열려있던 커서는 더는 Fetch하면 안된다.

-   트랜잭션이 몰리는 시간대에 오래 걸리는 쿼리가 같이 수행되지 않도록 시간을 조정한다.

-   큰 테이블을 일정 범위로 나누어 읽고 단계적으로 실행할 수 있도록 코딩한다.

    -   Snapshot too old 발생 가능성을 줄일 뿐 아니라 문제가 발생했을때 특정 부분부터 시작할 수 있다.
    -   읽기 일관성에 문제가 없을때 적용

-   대량데이터 조회시 ML조인 말고 다른거 사용

-   소트 부하를 감수하더라도 order by등을 강제로 삽입해 소트연산이 발생하도록 한다.

    -   많은 데이터를 오랜 시간에 걸쳐 Fetch 하는 동안 Undo정보를 지속적으로 참조하기 때문에 문제가 발생
    -   서버내에서 빠르게 데이터를 읽어 Temp 세그먼트에 저장하는 데에만 성공하면 같은 블록을 재방문시 에러 발생 걱정 안해도 된다.

-   만약 delayed 블록 클린아웃에 의해 Snapshot too old 에러가 발생한다고 의심되면 대량 업데이트 후 해당 테이블에 대해 FullScan하도록 쿼리를 날린다.

```sql
select /*+ full(t) */ from table_name t
```

만약 인덱스 블록에서 문제가 발생한다고 판단되면 리프 블록을 모두 스캔하도록 쿼리한다.

```sql
-- index 컬럼이 숫자형이고 0보다 큰값을 가질때
select count(*) from table_name where index_column > 0

```

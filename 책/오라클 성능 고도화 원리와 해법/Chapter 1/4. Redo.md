# Redo

오라클은 데이터파일과 컨트롤 파일에 가해지는 모든 변경사항을 하나의 Redo로그 엔트리로서 Redo 로그에 기록한다.

Redo로그는 Online Redo 로그와 Archived(Offline) Redo 로그로 구성된다.

Online Redo 로그는 Redo 로그 버퍼에 버퍼링된 로그 엔트리를 기록하는 파일로서, 최소 두 개 이상의 파일로 구성된다.

현재 사용 중인 Redo 로그 파일이 꽉 차면 다음 Redo 로그 파일로 로그 스위칭이 발생하며, 게속 Redo 로그를 써 나가다가 모든 Redo 로그파일이 꽉 차면 다시 첫 번째 Redo 로그 파일부터 재사용하는 라운드 로빈 방식을 사용한다.

Archived Redo 로그는 Online Redo 로그가 재사용되기 전에 다른 위치로 백업해 둔 파일을 말한다.

Redo 아래 3가지 목적을 위해 사용된다

-   Database Recovery

    -   물리적으로 디스크가 깨지는 등의 Media Fail 발생시 데이터베이스를 복구하기 위해 사용되며 이때는 Archived Redo 로그를 사용하게 된다. (Media Recovery 라고도 한다.)

-   Cache Recovery

    -   Instance Recovery 라고도 하며 모든 데이터베이스 시스템이 버퍼 캐시를 도입하는 것은 I/O성능 향상을 위해서이기도 하다

    -   버퍼 캐시는 휘발성이므로 캐시에 저장된 변경사항이 디스크 상의 데이터 블록에 기록되지 않은 상태로 정전등이 발생했을때의 트랜잭션 데이터 유실에 대비하기 위해 사용

    -   Instance Crash 발생 후 시스템을 재기동하면 우선 Online Redo 로그에 저장된 기록사항들을 읽어 마지막 체크 포인트 이후부터 사고 발생 직전까지 수행되었든 트랜잭션들을 재현한다. (트랜잭션 커밋 여부를 불문하고 일단 버퍼 캐시를 시스템이 셧다운 되기 이전 상태로 되돌림)

    -   Cache Recovery가 완료되면 Undo 데이터를 이용해 시스템이 셧다운 되는 시점에 아직 커밋되지 않았던 트랜잭션들을 모두 롤백하는 Transaction Recovery 가 진행된다(rollback 단계)

    -   이렇게 roll forward와 rollback 단계를 모두 완료하고 나면 커밋되지 않은 기록사항들은 모두 제거되어 데이터파일에는 커밋에 성공한 데이터만 남게되면 완전히 동기화 된다.

-   Fast Commit

    -   변경된 메모리 버퍼 블록을 디스크 상의 데이터 블록에 기록하는 작업은 Random 액세스 방식으로 이루어지기 때문에 느리다.

    -   로그는 append 방식으로 기록하므로 상대적으로 빠르다. 우선 변경사항을 append 방식으로 로그 파일에만 기록하고 후에 메모리 데이터 블록과 데이터 파일간 동기화는 적절한 수단을 사용해 나중에 배치 방식으로 일괄 수행한다.

Fast Commit을 구현하는 데 있어 오라클만의 특징적인 기능이 있는데 Delayed 블록 클린아웃이 바로 그것이다.

완전한 커밋을 위해서는 Lock을 해제하는 일까지 완료해야 하는데 다른 DBMS는 Lock 매니저를 통해 로우 Lock을 관리하기 때문에 커밋시점에 빠르게 Lock 리소스를 해제할 수 있다.

반면 오라클은 별도의 Lock 매니저 없이 레코드의 속성으로서 로우 Lock을 구현 했기 때문에 Lock을 해제하려면 갱신했던 블록들을 일일이 찾아다녀야 한다.

따라서 Redo 로그에 기록하는 것만으로는 도저히 커밋을 빠르게 처리할 수 없는 구조

그래서 오라클은 Delayed 블록 클린아웃 이라는 추가적인 메커니즘을 사용한다.

커밋 시점에는 Undo 세그먼트 헤더의 트랜잭션 테이블에만 커밋 정보를 기록하고 블록 클린아웃(갱신된 블록에 커밋 정보를 기록하고 Lock을 해제하는 작업)은 나중에 수행하도록 하는 것을 말한다.

Redo 레코드를 기록할 때도 곧바로 Redo 로그 파일에 저장하는 것은 아니며 먼지 Redo 로그 버퍼에 기록한다

데이터 블록 버퍼를 변경하기 전에 항상 Redo 로그 버퍼에 기록하고 일정 시점마다 LGWR 프로세스에 의해 Redo 로그 버퍼에 있는 내용을 Redo 로그 파일에 기록하는 것

LGWR가 Redo 로그 버퍼를 Redo 로그에 기록하는 시점은 다음과 같다

-   3초마다 DBWR 프로세스로부터 신호를 받을 때(DBWR은 Dirty 버퍼를 데이터 파일에 기록하기 전에 로그 버퍼 내용을 LGWR에게 신호를 보냄)

-   로그 버프 1/3이 차거나 기록된 Redo 레코드량이 1MB를 넘을 때

-   `사용자가 커밋 또는 롤백 명령을 날릴 때`

핵심은 커밋 또는 롤백 명령을 날릴때이다 트랜잭션이 영속성을 보장받으려면 최소한 커밋 시점에는 Redo정보가 메모리가 아닌 디스크 상에 저장되었음이 확인되어야 한다.

1,2는 대량의 트랜잭션이 발생해 이를 메모리에서 파일로 일괄 반영하려고 할때 작업량이 한꺼번에 몰리는 것에 대비해 주기적으로 Dirty 버퍼를 해소하고 로그 버퍼를 비우도록 구현된 부차적인 기능

1번에서 DBWR가 Drity 버퍼를 데이터파일에 기록하기 전에 로그 버퍼를 먼저 Redo 로그에 기록하도록 하는 이유는 Instance Crash발생시 복구를 위해 (로그에 없는 파일이 이미 데이터 파일에 기록되어 있으면 사용자가 최종 커밋하지 않은 트랜잭션이 커밋되는 결과를 초래하기 때문)

> Write Ahead Logging : 버퍼 캐시에 있는 블록 버퍼를 갱신하기 전에 먼저 Redo 엔트리를 로그 버퍼에 기록해야 하며, DBWR가 버퍼 캐시로부터 Ditry 블록들을 디스크에 기록하기 전에 LGWR가 해당 Redo 엔트리를 모두 Redo 로그파일에 기록했음이 보장되어야 한다.

1. 사용자가 커밋을 날리면
2. 서버 프로세스는 커밋 레코드를 Redo로그 버퍼에 기록
3. LGWR은 이것을 즉시 트랜잭션 로그 엔트리와 함께 redo 로그파일에 저장
4. 커밋을 수행한 서버 프로세스에 success code를 리턴한다.

여기까지 완료되면 아직 사용자의 갱신내용이 메모리상의 데이터 버퍼에만 기록된채 디스크에 기록되지 않음(Fast Commit)

Instance Crash가 발생하더라도 Redo 로그를 이용해 언제든 복구 가능한 상태가 되었음

시스템을 모니터링 해보면 사용자가 커밋 또는 롤백할 때마다 log file sync라는 대기 이벤트가 발생하는걸 볼 수 있는데

LGWR 프로세스가 로그 버퍼 내용을 Redo 로그 파일에 기록할 때까지 서버 프로세스가 대기하는 현상 때문에 발생한다.

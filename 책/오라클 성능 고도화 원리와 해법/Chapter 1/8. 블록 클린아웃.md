# 블록 클린아웃

블록 클린아웃은 트랜잭션에 의해 설정된 로우 Lock을 해제하고 블록 헤더에 커밋정보를 기록하는 오퍼레이션이다.

오라클에서 로우 단위 Lock은 레코드의 속성으로 관리되며, 이는 로우 헤더로부터 블록 헤더에 있는 ITL 엔터리를 가리키는 포인터다.

사용자는 블록 클린아웃까지 완료해야 완전한 커밋이라고 할 수 있는데 대량 갱신 작업의 경우 블록들을 일일이 찾아다니며 클린아웃을 수행하면 시간이 오래걸린다.

오라클은 그래서 대량의 갱신작업이 있고 나서는 커밋 정보를 트랜잭션 테이블에만 기록하도 빠르게 커밋을 끝내버린다.

추후에 해당 블록이 처음 액세스 되는 시점에 클린아웃을 진행하는데 항상 이방식으로 진행하는 것은 아니며 두가지 메커니즘을 사용한다.

-   Delayed 블록 클린아웃
-   커멋 클린아웃

## Delayed 클린아웃

트랜잭션이 갱신한 블록 개수가 총 버퍼 캐시 블록 개수의 1/10을 초과할때 사용하는 방식

해당 블록을 액세스하는 첫번재 쿼리에 의애 클린아웃이 이루어진다.

-   ITL 슬롯에 커밋 정보 저장
-   레코드에 기록된 Lock Byte 해제
-   Online Redo에 Logging

블록을 읽는 과정에서 Active 상태의 블록 즉 아직 커밋 정보가 ITL에 기록되지 않았다면 읽기 전에 클린 아웃을 시도한다.

ITL 슬롯에 기록된 트랜잭션 ID를 이용해 Undo 세그먼트 헤더에 있는 트랜잭션 테이블 슬롯을 찾아가 트랜잭션 현재 상태를 확인하고 커밋된 트랜잭션이라면 ITL슬롯에 반영, 로우 Lock 정보를 해제해 클린아웃시킨다.

갱신내용도 Redo에 로깅하며 블록 SCN도 변경한다.

## 커밋 클린아웃(Fast 블록 클린아웃)

블록 클린아웃도 쓰기 작업이므로 Current 블록에서 진행하며 트랜잭션이 갱신한 블록 개수가 버퍼 캐시 블록 개수의 1/10을 초과하지 않을 때 커밋 시점에 바로 클린아웃을 수행한다.

다만 이 경우에도 커밋 시점에는 불완전항 형태의 클린아웃을 수행하며 해당 블록을 갱신하는 다음 트랜잭션에 의해 완전한 클린아웃이 이루어진다.

즉 커밋 시점에는 ITL 슬롯에 커밋 정보만 저장하고 로우 헤더에 기록된 Lock Byte는 해제하지 않는다.

(해제하지 않는 이유는 로깅을 수행하지 않기 위해 커밋 클린아웃 시에는 Online Redo에 로그를 남기지 않는다. 로깅 시점을 뒤로 미루는 것 해당 블록을 갱신하려고 Current 모드로 읽는 시점에 Lock Byte를 해제하고 완전한 클린아웃 수행후 로깅한다.)

커밋 시점에 이미 완전한 커밋 정보가 ITL에 기록돼있기 때문에 이후 CR 모드 읽기 시 커밋 여부와 커밋 SCN을 확인하려고 트랜잭션 테이블을 조회하지 않아도 되며 Lock Byte를 무시하고 그대로 블록을 읽는다.

## ITL과 블록 클린아웃

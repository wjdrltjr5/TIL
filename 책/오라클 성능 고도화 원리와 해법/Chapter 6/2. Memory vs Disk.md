# Memory vs Disk I/O

## I/O 효율화 튜닝의 중요성

디스크를 경유한 입출력은 물리적으로 액세스 암이 움직이면서 헤드를 통해 데이터를 잃고 쓰기 때문에 느리다

반면 메모리를 통한 입출력은 전기적 신호에 불과하기 때문에 디스크I/O에 비해 비교할 수 없을 정도로 빠르다.

모든 DBMS는 버퍼 캐시를 경유해 I/O를 수행한다 DB 버퍼 캐시를 경유한다는 것은 읽고자 하는 블록을 먼저 버퍼 캐시에서 찾아보고 찾지 못할 때만 디스크에서 읽는 것을 말한다.

유한한 메모리 자원을 좀 더 효율적으로 사용해야 하므로 자주 액세스하는 블록들이 캐시에 더 오래 남아있도록 LRU알고리즘을 사용한다.

결국 디스크 I/O를 최소화하고, 대부분 처리를 메모리에서 할 수 있도록 버퍼 캐시 효율성을 높이는 것이 데이터베이스 성능을 좌우하는 열쇠

## 버퍼 캐시 히트율

전체 읽을 블록 중에서 얼만큼을 메모리 버퍼 캐시에서 찾았는지를 나타내느 것 구하는 공식은 아래와 같다.

```
BCHR = (캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수) X 100
     = ( (논리적 블록 읽기 - 물리적 블록 읽기) / 논리적 블록 읽기) X 100
     = ( 1 - (물리적 블록 읽기) / (논리적 블록 읽기)) X 100
```

-   논리적 블록 읽기 = 총 읽은 블록 수
-   캐시에서 곧바로 찾은 블록 수 = 논리적 블록 읽기 - 물리적 블록 읽기

공식에서 알 수 있듯 BCHR는 물리적인 디스크 읽기를 수반하지 않고 곧바로 메모리에서 찾은 블록을 찾은 비율을 말한다.

Direct Path Read 방식으로 읽는 경우를 제외하면 모든 블록 읽기는 버퍼 캐시를 통해 이루어진다.

읽고자 하는 블록을 먼저 버퍼 캐시에서 찾아보고 없을 때 디스크로 부터 읽어들이며, 이때도 디스크로부터 곧바로 읽는 게 아니라 먼저 버퍼 캐시에 적재한 후에 일근ㄴ다.

캐시에서 곧바로 찾은 블록 수는 총 읽은 블록수에서 물리적 블록 읽기를 차감해서 구한다.

온라인 트랜잭션을 주로 처리하는 시스템이라면 99% 달성을 목표로 해야한다. BCHR 주로 시스템 전체적인 관점에서 바라보지만, 개별 SQL 측면에서 구해볼 수도 있는데 이 비율이 낮은 것이 쿼리 성능을 떨어트리는 주된 원인이다.

트레이스 항목에서 Disk 항목이 물리적 블록읽기에 해당하며 논리적블록읽기는 Query와 Current 항목을 더해서 구하며, Direct path Read 방식으로 읽은 블록이 없다면 이 두 값을 더한 것이 총 읽은 블록 수 가된다.

다른 대기 이벤트가 없었다면 CPU time과 Elapsed time간에 발생한 시간차는 대부분 디스크 I/O 때문이다.

`논리적은 블록 요청 횟수를 줄이고 그럼으로써 물리적으로 디스크에서 읽어야할 블록 수를 줄이는 것이 I/O 효율화 튜닝의 핵심원리다.`

BCHR가 100%라고 하더라도 논리적으로 읽어야 할 블록 수의 절대량이 많다면 반드시 SQL 튜닝을 실시해서 논리적인 블록 읽기는 최소화해야 한다.

## 네트워크 파일시스템 캐시가 I/O 효율에 미치는 영향

메모리 I/O, 디스크 I/O 발생량뿐 아니라 최근에는 네트워크 속도가 I/O 성능에 지대한 영향을 미치고 있다.

`디스크 속도가 문제이든 SAN이 문제이든 아니면 RAC 인터커넥스가 문제이든 I/O 성능에 관한 가장 확실하고 근본적인 해결책은 논리적인 블록 요청 횟수를 최소화하는 것`

# SQL 처리과정

-   SQL 파싱
-   옵티마이저

    -   쿼리 변환
    -   추정
    -   계획생성

-   로우 소스 생성
-   실행

사용자가 SQL문을 던지면 SQL파싱후 해당 SQL이 메모리에 캐싱되있는지 확인 메모리에서 찾으면 바로 실행 찾미 못하면 최적화 단계를 거친다.

-   소프트 파싱 : 파싱 단계에서 SQL 커서를 메모리에서 찾아 바로 실행단계로 넘어가는 것

-   하드 파싱 : 메모리에서 찾는데 실패해 최적화 및 로우 소스 생성 단계를 거치는 것

같은 쿼리를 5000번 반복히 최소 한번 하드파싱 후 나머지는 소프트파싱으로 수행한다.

## SQL 파싱

SQL 파서 : 사용자가 던진 SQL을 가장 먼저 받아서 처리하는 엔진으로 SQL문장을 이루는 개별요소를 분석하고 파싱해서 파싱 트리를 만든다.

해당 과정에서 문법적 오류가 없는지 Syntax체크가 이루어진다.

파싱트리가 만들어지고 나면 Semantic 체크를 통해 의미상 오류가 없는지 확인한다 (존재하지 않거나 권한없는 오브젝트 사용 체크, 또는 존재하지 않는 컬럼 사용확인)

이 단계를 모두 통과하면 해싱 알고리즘을 이용해 SQL 커서가 Shared Pool에 캐싱돼있는지 확인

Shared Pool에서 찾은 SQL문장이 현재 수행하려는 SQL문과 100%일치하더라도 파싱을 요청한 사용자가 다르거나 옵티마이저 관련 설정이 다르다면 새로운 SQL 파서를 생성해야 한다.

## SQL 최적화

시스템 통계 및 오브젝트 통계정보를 판단기준으로 삼아 다양한 액세스 경로를 비교하고 그중 가장 효율적인 실헁계획을 선택해준다.

옵티마이저가 최적화를 수행할 때 세부적으로 아래 3가지의 서브엔진을 사용한다.

-   Query Transformer : 사용자가 던진 SQL을 그대로 둔 채 최적화하는 게 아니라 우선 최적화하기 쉬운 형태로 변환을 시도한다.(쿼리 변환 전후 결과가 동일할때만)

-   Plan Generator : 하나의 쿼리를 수행하는 데 있어, 후보군이 될만한 실행계획들을 생성해 내는 역할을 한다.

-   Estimator : 쿼리 오퍼레이션 각 단계의 선택도, 카디널리티, 비용을 계산하고, 궁극적으로는 실행게획 전체에 대한 총 비용을 계산해 낸다. (예상치)
    -   각 단계를 수행하는데 필요한 I/O, CPU , 메모리 사용량 등을 예측하기 위해 데이터베이스 오브젝트 통계정보와 하드에워적인 시스템 성능 통계정보를 이용한다.

## Row-Source Generation

옵티마이저의 최적화 과정을 거치면 SQL처리과정을 표현한 실행계획이 만들어진다.

그후 실행 가능한 코드 또는 프로시저 형태로 포맷팅하는 작업이 필요하며 이 역할을 Row-Source Generator가 담당한다.

Row_Source는 레코드 집합을 반복 처리하면서 사용자가 요구한 최종 결과집합을 실제적으로 생성하는데 사용되는 제어 구조를 말한다.

최적화를 수반한 하드파싱은 매우 무거운 작업 데이버테이스에서 이루어지는 처리과정은 대부분 I/O 작업에 집중되는 반면 하드 파싱은 CPU가 많이 소비하는 몇 안되는 작업 중 하나에 속한다.

하드 파싱 과정에서 Shared pool과 라이브러리 캐시에 대해 발생하는 래치 경합도 CPU를 많이 소비하게 만드는 요인으로 작용한다.

한번 수행될 때마다 내부적으로 많은 데이터 딕셔너리 조회를 수반흐므로 하드 파싱은 우리가 생각하는 것 이상으로 비용이 크다.

# ASH(Active Session History)

Ratio 기반 분석 방법론의 한계점은 시스템에 문제가 있는 것으로 진단되었을 때 그 원인을 찾아 실제 문제를 해결하는 데 까지 많은 시간이 걸리는 데 있다.

이것은 대기 이벤트 기반 분석 방법론을 사용하더라도 마찬가지 대기 이벤트 발생량과 대기 시간을 통해 문제의 원인을 금방 알 수는 있지만, 실제 문제를 해결하려면 구체적으로 어떤 프로그램에서 문제를 일으켰고, 어떤 세션에서 성능 떄문에 고생했는지를 확인할 수 있어야 한다.

ASH는 별도의 Third Party 모니터링 도구 없이 오라클 내에서 세션 레벨 실시간 모니터링을 가능케 하는 강력한 기능으로써 OWI의 활용성을 극대화 해준다.

```sql
select * from v$sgastat where name = 'ASH buffers';

Pool         Name                   BYTES
------------ ----------------- -----------
shared pool  ASH buffers          65011712
```

오라클은 현재 접속해서 활동중인 Active 세션 정보를 1초에 한번씩 샘플링해서 ASH 버퍼에 저장한다.

SGA Shared Pool 에서 CPU당 2MB의 버퍼를 할당 받아 세션 정보를 기록하며 1시간 혹은 버퍼의 2/3가 찰 때마다 디스크로 기록한다. 즉 AWR에 저장

v$active_session_history 뷰를 이용해 ASH 버퍼에 저장된 세션 히스토리 정보를 조회할 수 있다.

```sql
SELECT
    sample_id, sample_time,                            -- ① 샘플링이 일어난 시간과 샘플 ID
    session_id, session_serial#, user_id, xid,         -- ② 세션정보, User ID, 트랜잭션 ID
    sql_id, sql_child_number, sql_plan_hash_value,     -- ③ 수행 중인 SQL 정보
    session_state,                                     -- ④ 세션 상태
    qc_instance_id, qc_session_id,                     -- ⑤ 병렬 쿼리 coordinator 정보
    blocking_session, blocking_session_serial#, blocking_session_status,  -- ⑥ 블로킹 세션 정보
    event, event#, seq#, wait_class, wait_time, time_waited,              -- ⑦ 대기 이벤트 정보
    p1text, p1, p2text, p2, p3text, p3,                 -- ⑧ 대기 이벤트 파라미터
    current_obj#, current_file#, current_block#,       -- ⑨ 현재 액세스 중인 블록 정보
    program, module, action, client_id                 -- ⑩ 프로그램 및 클라이언트 정보
FROM
    V$ACTIVE_SESSION_HISTORY;

```

7,8번의 대기 이벤트 정보는 두말할 것도 없고 6번 블로킹 세션 정보와 9번 현재 액세스 중인 오브젝트 정보도 유용하다.

오브젝트 정보도 더할 나위 없이 유용하지만 현재 발생 중인 대기 이벤트의 Wait Class가 Application, Concurrency, Cluster, User I/O일 떄만 의미 있는 값임을 알아야 한다.

예로 ITL 슬롯 부족 때문에 발생하는 enq: TX - allocate ITL entry 대기 이벤트는 Configuration 에 속하므로,

v$active_session_history 뷰를 조회할 때 함께 출력되는 오브젝트에 Lock이 걸렸다고 판단해서는 안된다.

대개 그럴 떄는 오브젝트 번호가 -1로 출력되지만 직전에 발생한 이벤트의 오브젝트 정보가 계속 남아서 보이는 경우가 있으므로 잘못 해석하지 않도록 주의해야 한다.

초 단위로 쓰기가 발생하는 ASH 버퍼를 읽을 때 래치를 사용한다면 경합이 생길 수 있다.

따라서 오라클은 ASH 버퍼를 읽는 세션에 대해서는 래치를 요구하지 않으며 그 때문에 간혹 일관성 없는 잘못된 정보가 나타날 수도 있다.

ASH 기능을 이용하면 현재뿐 아니라 과거시점에 발생한 장애 및 성능저하 원인까지 세션 레벨로 분석할 수 있게 도와준다. Statspack을 이용할 때는 이튿날 아침에 분석 보고서를 생성해 문제점을 발견하더라도 이를 좀더 세밀하게 분석해 볼 방법이 없었다.

이미 문제의 세션은 종료되고 없기 때문

오라클 10g 부터는 v$active_session_history 정보를 AWR내에 보관하므로 과거치에 대한 세션 레벨 분석이 가능해졌다

이것도 SGA를 DAM 방식으로 액세스하기 때문에 가능해진 일 방대한 정보를 다 저장하는 것은 무리가 되므로 1/10만 샘플링해서 잦ㅇ한다.

문제가 되는 대기 이벤트는 일정간격을 두고 지속적으로 발생하기 때문에 샘플링된 자료만으로도 원인을 찾는데 큰 지장은 없다.

v$active_session_history를 조회했을 때 정보가 찾아지지 않는다면 이미 AWR에 쓰여진 것이므로 dba_hist_active_sess_history 뷰를 조회하면 된다.

AWR과 ASH를 잘 이용하면 전문 성능관리 툴의 도움없이도 효과적으로 성능 분석을 할 수 있다.

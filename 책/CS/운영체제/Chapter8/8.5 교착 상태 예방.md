# 교착 상태 예방

교착상태의 4가지 조건중 최소한 하나가 성립하지 않도록 보장함으로써 교착상태의 발생을 예방할 수 있다.

## 8.5.1 상호 배제

적어도 하나의 자원은 공유가 불가능한 자원이어야 한다. 반면에 공유 가능한 자원들은 배타적인 접근을 요구하지 않으며, 따라서 교착 상태에 관련될 수 있다.

읽기-전용 파일이 공유 가능한 자원의 좋은 예 만일 여러 스레드가 읽기-전용 파일을 열면 그 파일에 동시 접근을 허용한다. 프로세스는 공유 가능한 자원을 위해 대기할 필요가 없다.

그러나 일반적으로 상호 배제 조건을 거부함으로써 교착 상태를 예방하는 것은 불가능하다. 어떤 자원들은 근본적으로 공유가 불가능하기 때문 mutex락을 동시에 여러 스레드가 공유할 수 없다.

## 8.5.2 점유하며 대기

시스템에서 점유하며 대기 조건이 발생하지 않도록 하려면 스레드가 자원을 요청할때 마다 다른 자원을 보유하지 않도록 보장해야 한다.

우리가 사용할 수 있는 하나의 프로토콜은 각 스레드가 실행을 시작하기 전에 모든 자원을 요청하고 할당해야 한다. (자원 요청의 동적 특성으로 인해 대부분의 응용프로그램에는 실용적이지 않다.)

한 대안 프로로콜은 스레드가 자원을 전혀 갖고 있지 않을 때만 자원을 요청할 수 있도록 허용한다. 스레드는 일부 자원을 요청하고 사용할 수 있다. 스레드가 추가의 자원을 요청할 수 있으려면, 자신에게 할당된 모든 자원을 반드시 먼저 방출해야 한다.

이 두 프로토콜은 두가지 주요 단점이 있다.

-   자원이 할당되었지만 장기간 사용되지 않을 수 있기 때문에 자원 이용률이 낮을 수 있다.

-   기아가 발생할 수 있다.

## 8.5.3 비선점

만일 어떤 자원을 점유하고 있는 스레드가 즉시 할당할 수 없는 다른 자원을 요청한다면(스레드가 반드시 대기해야 한다면)

현재 점유하고 있는 모든 자원들이 선점된다. 즉 이들 자원들이 묵시적으로 방출된다. 선점된 자원들은 그 스레드가 기다리고 있는 자원들의 리스트에 추가된다.

스레드는 자신이 요청하고 있는 새로운 자원을 물론 이미 점유하였던 옛 자원들을 다시 획득할 수 있을 때만 다시 시작될 것

대안으로 한 스레드가 어떤 자원들을 요청하면, 우리는 이들이 사용 가능한지를 검사한다. 사용 가능하다면 할당하고 불가능하다면 어느 스레드에 할당되어 있는지를 검사한다.

만약 그렇다면 대기 중인 스레드로부터 원하는 자원을 선점해 이들을 요청하는 스레드에게 할당한다.

만일 자원을 이용할 수 없거나 다른 스레드에 점유되어 있지 않다면, 요청 스레드는 반드시 대기해야 한다.

`스레드가 대기하는 동안, 그 스레드의 자원들 중 일부는 다른 스레드가 이들을 요청하는 경우에만 선덤될 수 있다.`

스레드가 요청중인 새로운 자원을 할당받고 또한 대기 중에 선점되었던 모든 자월을 회복할 때에만 다시 시작할 수 있다.

이 프로토콜은 CPU 레지스터나 데이터베이스 트랜잭션 처럼 그 상태가 쉽게 저장되고 후에 복원될 수 있는 자원에 종종 적용된다.

이것은 일반적으로 교착상태가 가장 흔하게 발생하는 자원 유형인 mutex락이나 세마포 같은 자원에는 적용될 수 없다.

## 8.5.4 순환 대기

교착 상태 예방을 위해 앞서 세가지 옵션은 대부분 상황에서 일반적으로 실용적이지 않다.

순환 대기 조건은 필요한 조건 중 하나를 무효화하여 실용적인 해결책을 제공할 수 있는 기회를 제공한다.

순환 대기 조건이 성립하지 않도록 하는 한 가지 방법은 모든 자원 유형에 전체적인 순서를 부여햐여 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 요구하는 것

각 자원 유형의 고유의 정수 번호를 부여하고 이 번호는 우리가 두 자원을 비교해 어느 것이 순서가 빠른지 결정할 수 있게 한다.

시스템의 모든 동기화 객체 간에 순서를 정하여 응용프로그램에서 이 기법을 구현할 수 있다.

이제 교착상태를 예방하기 위해 다음과 같은 프로토콜을 고려할 수 있다.

각 스레드는 오름차순으로만 자원을 요청할 수 있다. 만일 동일한 자원 유형의 인스턴스가 여러 개 필요하다면, 이들 모두에 대한 하나의 요청이 주어져야 한다.

대안으로 스레드가 자원 유형 Ri의 인스턴스를 요청할 때마다. F(Ri) >= F(Rj)인 모든 자원 Ri를 방출하도록 요구하는 방법이 있다. 동일한 유형의 자원이 여러 개 필요할 경우 단 한 번의 요청으로 ㅁ모든 자원을 할당받아야 한다.

이 두가지 프로토콜을 사용하면 순환 대기 조건이 발생하지 않는다. 순서나 계층 구조를 정하는 것 자체만으로는 교착 상태를 에방할 수 없다는 것을 유의

순서를 지키는 프로그램을 작성하는 것은 응용프로그래머에게 달려있다. 그러나 락 순서를 설정하는 것은 특히 수백 또는 수천 개의 락이 있는 시스템에서 어려울 수 있다.

이 문제를 해결하기 위해 많은 Java 개발자는 System.identityHashCode(Object) 메소드를 락 획득 순서를 지정하는 함수로 사용하는 전략을 채택하였다. 이 메소드는 전달된 object 매개변수의 디폴트 해시 코드 값을 반환한다.

락이 동적으로 획득될 수 있다면 락 순서는 부여한다고 해서 교착 상태 예방을 보장하지 않는다는 것을 주의

```c
// 락 순서로 인한 교착상태의 예
void transaction(Account from, Account to, Double, amount){
  mutex lock1, lock2;
  lock1 = get_lock(from);
  lock2 = get_lock(to);

  acquire(lock1);
    acquire(lock2);

      withdraw(from, amount);
      deposit(to, amount);

    release(lock2);
  release(lock1);
}
```

두개의 스레드가 계좌의 순서를 바꾸어 동시에 transaction() 함수를 호출하면 교착 상태가 발생할 가능성이 있다.

한스레드가

> transaction(checking_account, savings_account, 25.0)
> 다른스레드가
> transaction(savings_account, checking_account, 50.0)

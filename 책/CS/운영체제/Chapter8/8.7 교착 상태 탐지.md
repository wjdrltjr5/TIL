# 교착 상태 탐지

만일 시스템이 교착 상태 예방이나 교착 상태 방지 알고리즘을 사용하지 않는다면 교착 상태가 발생할 수 있다. 이러한 환경에서는 시스템은 다음 알고리즘들을 반드시 지원해야 한다.

-   교착 상태가 발생했는지 결정하기 위해 시스템의 상태를 검사하는 알고리즘
-   교착 상태로부터 회복하는 알고리즘

## 8.7.1 각 자원 유형이 한 개씩 있는 경우

모든 자원이 한 개의 인스턴스만 있다면 `대기` 그래프 라고 하는 , 자원 할당 그래프의 변형을 사용해 교착 상태 탐지 알고리즘을 정의할 수 있다.

자원 할당 그래프로부터 자원 유형의 노드를 제거하고 적절한 간선들을 결합함으로써 대기 그래프를 얻을 수 있다.

정확히는 대기 그래프에서 T(i) -> T(j)로의 간선은 프로세스 T(j)가 가지고 있는 자원들이 T(i)가 필요하여 방출되기를 기다리는 것

간선 T(i) -> T(j)는 해당 자원 할당 그래프가 자원 R에 대해 두 개의 간선 T(i) -> R, R -> T(j) 를 포함하는 경우에만 대기 그래프에 존재한다.

대기 그래프에 사이클을 포함하는 경우에만 시스템에 교착 상태가 존재한다. 교착 상태를 탐지하기 위해 시스템은 대기 그래프를 유지할 필요가 있고, 주기적으로 그래프에서 사이클을 탐지하는 알고리즘을 호출한다.

그래프에서 사이클을 탐지하는 알고리즘은 O(n\*n)의 연산을 요구한다. (n은 그래프에 있는 정점의 수)

## 8.7.2 각 유형의 자원을 여러 개 가진 경우

대기 그래프는 종류마다 자원이 여러 개씩 존재하는 상황에서는 사용할 수 없다. 아래와 같은 기법은 이러한 상황에서 교착 상태를 탐지할 수 있다 이 알고리즘은 은행원 알고리즘과 마찬가지로 시시가각 그 내용이 달라지는 자료구조를 사용한다(8.6.3 참조)

-   Available : 각 종류별로 가용한 자원의 개수를 나타내는 벡터로 크기가 m이다.

-   Allocation : 각 스레드에 현재 할당된 자원의 개수를 나타내는 행렬로 크기가 n\*m 이다

-   Request : 각 스레드가 현재 요청 중인 자원의 개수를 나타내는 행렬로 크기가 n \* m이다.
    -   Request[i][j] == k 라면 T(i)가 R(j)를 k개 요청중

두개의 벡터 사이에 <=가 의미하는 바는 8.6.3.과 동일하다.
여기서 기술하는 탐지 알고리즘의 원리는 가능한 모든 할당 순서를 조사해 보는 방식이다

> java는 교착 상태 감지를 명시적으로 지원하지 않지만 스레드 덤프를 사용하여 교착 상태가 있는지 판별하기 위해 실행 중인 프로그램을 분석할 수 있다.

-   Work 와 Finish는 크기가 m과 n인 벡터다
-   Work는 = Available로 초기 값을 준다. i = 0,1 ,,, n - 1 에 대해서 Allocation != 0이면 Finish[i] = false 로 준다.

-   아래 두 조건을 만족시키는 i 값을 찾는다.

    -   Finish[i] == false
    -   Request(i) <= Work
    -   이런 값을 찾을 수 있다면 step 5로 간다.

-   Work = Work + Allocation(i) , Finish[i] = true 다시 3번으로 간다.

-   어떠한 i 값(0 <= i < n)에 대해 Finish[i] == false 이면 이 시스템은 교착상태에 빠져있는 것 그리고 T(i)가 교착 상태에 빠져있다.

이 탐지 알고리즘을 실행하는 데에는 m _ n _ n개의 연산이 필요하다.

# 🔍 Deadlock Detection Algorithm 예시

## ✅ 시스템 정보

-   스레드: T₀ ~ T₄
-   자원 종류: A, B, C
-   자원 수량:
    -   A: 7개
    -   B: 2개
    -   C: 6개

---

## ✅ 현재 시스템 상태

### 🔹 Allocation Matrix

| 프로세스 | A   | B   | C   |
| -------- | --- | --- | --- |
| T₀       | 0   | 1   | 0   |
| T₁       | 2   | 0   | 0   |
| T₂       | 3   | 0   | 3   |
| T₃       | 2   | 1   | 1   |
| T₄       | 0   | 0   | 2   |

---

### 🔹 Request Matrix (초기 상태)

| 프로세스 | A   | B   | C   |
| -------- | --- | --- | --- |
| T₀       | 0   | 0   | 0   |
| T₁       | 2   | 0   | 2   |
| T₂       | 0   | 0   | 0   |
| T₃       | 1   | 0   | 0   |
| T₄       | 0   | 0   | 2   |

---

### 🔹 Available 자원

A: 0, B: 0, C: 0

현재 이 시스템은 교착 상태에 처해있지 않음

T0 → T2 → T3 → T1 → T4

## ❗ 새로운 요청 발생 시 (T₂가 C를 1개 더 요청)

### 🔹 수정된 Request Matrix

| 프로세스 | A   | B   | C   |
| -------- | --- | --- | --- |
| T₀       | 0   | 0   | 0   |
| T₁       | 2   | 0   | 2   |
| T₂       | 0   | 0   | 1   |
| T₃       | 1   | 0   | 0   |
| T₄       | 0   | 0   | 2   |

이제는 시스템이 교착상태에 빠지게된다. T0의 자원을 회수한다고 하더라도 다른 프로세스들이 요구하는 자원을 충족시켜줄 방법이 없기 때문 T1,T2,T3,T4,가 교착상태에 연루되게 된다.

## 8.7.3 탐지 알고리즘 사용

탐지 알고리즘은 언제 돌리는가는 두가지 관점에 달려있다.

-   교착 상태가 얼마나 자주 일어나는가?
-   교착 상태가 일어나면 통상 몇 개의 스레드가 거기에 연루되는가?

교착 상태가 일어나는 시점은 어떤 스레드가 자원을 요청했는데 그것이 즉시 만족되지 못하는 시점이다.

오버헤드를 줄이는 가장 간단한 대안은 지정된 시간 간격으로 또는 CPU 이용률이 40%이하로 떨어졌을때 탐지 알고리즘을 돌리는 것

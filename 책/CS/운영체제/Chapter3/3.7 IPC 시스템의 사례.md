# IPC 시스템의 사례 (프로세스 간 통신)

## 3.7.1 POSIX 공유 메모리

POSIX 공유 메모리란 : POSIX(Portable Operating System Interface) 표준에 따라
서로 다른 프로세스들 간에 메모리를 공유할 수 있도록 정의된 공유 메모리 IPC 메커니즘

공유 메모리와 메시지 전달을 포함하여 POSIX시스템을 위한 다수의 IPC 기법이 사용가능하다.

POSIX 공유 메모리는 메모리-사상파일을 사용하여 구현된다. 메모리-사상 파일은 공유 메모리의 특정 영역을 파일과 연관시킨다.

프로세스는 먼저 아래와 같이 shm_open() 시스템 콜을 사용하여 공유 메모리 객체를 생성해야 한다.

```
fd = shm_open(name, O_CREATE | O_RDWR, 0666);
```

-   첫번째 인자는 공유 메모리 객체의 이름을 지정한다.
    -   공유 메모리에 접근하고자 하는 프로세스는 이 이름을 통하여 객체를 언급한다.
-   두번째 인자는 객체가 존재하지 않으면 생성되고(O_CREATE)객치는 읽기와 쓰기가 간으한 상태로 열린다는 것을 나타낸다 (O_RDWR)

-   마지막 인자는 공유 메모리 객체에 파일-접근 허가권을 부여한다. shm_open()이 성공하면 공유 메모리 객체를 나타내는 정수형 파일 설명자를 반환한다.

객체가 설정되면 ftruncate() 함수를 사용하여 객체의 크기를 바이트 단위로 설정한다.

```
-- 객체의 크기를 4096 단위로 설정한다.
ftruncate(fd, 4096)
```

마지막으로 mmap() 함수가 공유 메모리 객체를 포함하는 메모리-사상파일을 구축한다. mmap() 함수는 공유 메모리 객체에 접근할 때 사용될 메모리-사상 파일의 포인터를 반환한다.

사상파일(mapping) : 디스크에 저장된 파일이나 공유 메모리 객체를 프로세스의 가상 메모리에 "직접 연결"하는 것을 말합니다.

생산자는 공유 메모리 객체를 구축하고 공유 메모리에 데이터를 쓰고, 소비자는 공유 메모리에서 데이터를 읽는다.

## 3.7.2 Mach 메시지 전달.

Mach운영체제는 특히 분산 시스템용으로 설계되었지만 macOS 및 iOS 운영체제에 포함되었듯이 데스크톱 및 모바일 시스템에도 적합하다.

Mach커널은 프로세스와 유사하지만 제어 스레드가 많고 관련 자원이 적은 다중 태스크의 생성 및 제거를 지원한다.

모든 태스크간 통신을 포함하여 Mach에서 대부분의 통신은 `메시지`로 수행된다. Mach에는 `포트`라고 하는 메일박스로 메시지를 주고받는다.

포트는 크기가 정해져 있고 단방향이다. 양방향 통신의 경우 메시지가 한 포트로 전송되고 응답이 별도의 응답 포트로 전송된다.

각 포트에는 여러 송신자가 있을 수 있지만 수신자는 오직 하나만 존재한다. Mach는 포트를 사용하여 태스크, 스레드, 메모리 및 프로세스와 같은 자원을 나타내며, 메시지 전달은 이러한 시스템 자원 및 서비스와 상호 작용하기 위한 객체 지향 접근 방식을 제공한다.

동일한 호스트 또는 분산 시스템의 별도 호스트의 두 포트 사이에서 메시지 전달이 발생할 수 있다.

각 포트에는 그 포트와 상호 작용하는데 필요한 자격을 식별하는 `포트 권한`집합이 연관된다.

태스크가 포트에서 메시지를 수신하려면 해당 포트에 대해 MACH_PORT_RIGHT_RECEIVE 자격이 있어야 한다.

포트를 생성한 태스크가 해당 포트의 소유자이며 소유자는 해당 포트에서 메시지를 수신할 수 있는 유일한 태스크이다.

포트의 소유자는 포트의 자격을 조작할 수도 있다. 이러한 조작은 일반적으로 응답 포트를 설정할 때 수행된다.

동일한 태스크에 속하는 모든 스레드가 동일한 포트 권한을 공유한다 두 개의 스레드는 각 스레드와 관련된 스레드-별 포트를 통해 메시지를 교환하여 쉽게 통신할 수 있다.

각 태스크는 또한 부트스트랩 포트에 액세스 할 수 있어서 태스크가 생성한 포트를 시스템 전체의 부트스트랩 서버에 등록할 수 있다. 다른 태스크가 이 레지스트리에서 포트를 검색하여 포트로 메시지를 보낼 수 있는 권한을 얻을 수 있다.

각 포트와 관련된 큐는 크기가 제한되어있으며 메시지가 포트로 전송되면 큐에 복사된다.

모든 메시지는 안정적으로 전달되어 동일한 우선순위를 가진다. Mach는 동일한 송신자의 여러 메시지가 큐에 삽입되지만 절대적 순서를 보장하지는 않는다. 두명의 송신가자 보낸 메시지는 임의의 순서로 큐에 저장된다.

Mach 메시지에는 다음 두 필드를 포함한다.

-   고정 크기의 메시지 헤더 : 메시지 크기, 소스 및 대상 포트를 포함한 메시지에 관한 메타 데이터를 포함한다.
    -   일반적으로 송신 스레드는 응답을 예상하므로 소스의 포트 이름이 수신 태스크로 전달되어 응답을 보내는 데 반환 주소로 사용할 수 있다.
-   데이터를 포함하는 가변 크기 본체

mach_msg() 함수는 메시지를 보내고 받는 표준 API다

송수신 작업 자체는 융통성이 있다. 메시지가 포트로 전송되었을 떄, 큐가 가득찼다면 mach_msg()의 매개변수를 통해 다음중 하나를 선택할 수 있다.

-   큐에 공간이 생길 때까지 무기한 기다린다.
-   최대 N밀리초 동안 기다린다.
-   기다리지 않고 즉시 복귀한다.
-   메시지를 일시적으로 캐시한다. 큐가 가득 차더라도 운영체제에 전달하여 보존한다.
    -   메시를 큐에 넣을 수 있을때, 통지 메시지가 송신자에게 전송된다.
    -   큐가 가득 찼을 경우 송신 스레드마다 하나의 메시지만 커널에 보관할 수 있다.
    -   이 옵션은 서버 태스크를 위한 것 요청을 완료한 후 서버 태스크는 서비스를 요청한 태스크에 일회성 응답을 보내야 한다.
    -   그러나 클라이언트의 응답포트가 가득 찬 경우에도 다른 서비스 요청을 계속 서비스 해야 한다.

메시지 시스템의 주요 문제점을 일반적으로 송신자의 포트에서 수신자의 포트로 메시지를 복사해야 하므로 발생하는 성능저하이다. 가상 메로리 관리 기술을 사용하여 복사 연산을 피하려고 한다.

### IPC 포트 vs 네트워크 포트 개념 정리

#### ✅ 핵심 요약

| 항목            | IPC에서의 "포트"                            | 네트워크에서의 "포트"                             |
| --------------- | ------------------------------------------- | ------------------------------------------------- |
| 개념            | 프로세스 간 통신을 위한 엔드포인트 (식별자) | 네트워크를 통한 프로세스 연결 엔드포인트 (식별자) |
| 범위            | 같은 컴퓨터 안                              | 로컬 ↔ 원격 컴퓨터 간                             |
| 번호 관리       | OS 내부 관리 (메시지 큐 ID 등)              | TCP/UDP 포트 번호 (0~65535)                       |
| 사용 예         | System V Message Queue, POSIX Message Queue | HTTP(80번 포트), SSH(22번 포트)                   |
| 프로세스당 포트 | 하나 이상 가질 수 있음                      | 하나의 포트로 서비스 대기하는 것이 일반적         |

#### ✅ 질문에 대한 결론

-   **포트라는 기본 개념**: 통신할 프로세스/채널을 식별하기 위한 번호
-   **IPC와 네트워크 포트**: 목적은 비슷하다 (프로세스/서비스 식별)
-   **네트워크 포트 지정 이유**: 외부 요청을 올바른 프로세스로 연결하기 위해

#### ✉️ IPC (운영체제 내부)

-   프로세스 A → 메시지 큐 ID → 프로세스 B로 통신

#### 🌎 네트워크

-   클라이언트 → (서버 IP + 포트) → 서버의 특정 프로세스에 연결

#### ✅ 결론 정리

-   IPC의 "포트"와 네트워크의 "포트"는 **기본 개념이 비슷**하다.
-   둘 다 통신 엔드포인트를 **정확하게 식별하기 위한 번호** 역할을 한다.

## 3.7.3 Windows

Windows 운영체제는 모듈화를 이용하여 기능을 향상시키고 새로운 기능을 구현하는 시간을 감소시킨 최신 설계의 예

Windows는 다중 운영 환경 또는 서브 시스템을 지우너하며, 응용 프로그램은 메시지 전달 기법을 통해 이들과 통신한다. 따라서 응용 프로그램은 서브시스템 서버의 클라이언트로 간주 할 수 있다.

Windows의 메시지 전달 설비는 `고급 로컬 프로시저 호출 설비 (advanced local procedure call facility, ALPC)`라 불린다.

APLC는 동일 기계상에 있는 두 프로세스간의 통신에 사용한다. 널리 사용되는 표준 원격 프로시저 호출(RPC)기법과 같으나 Windows에 맞게 특별히 최적화 되어 있다.

Mach와 유사하게 Windows는 두 프로세스 간에 연결을 구축하고 유지하기 위해 포트 객체를 사용한다.

Windows는 `연결 포트` 와 `통신 포트`의 두 가지 유형의 포트를 사용한다.

서버 프로세스는 모든 프로세스가 접근할 수 있는 연결 포트 객체를 공표한다. 클라이언트가 서브시스템으로부터 서비스를 원할 경우, 서버의 연결 포트 객체에 대한 핸들을 열고 연결 요청을 보낸다.

서버는 채널을 생성하고 핸들을 클라리언트에게 반환한다. 채널은 한 쌍의 사적인 통신 포트로 구성되는데, 하나의 클라이언트에서 서버로 메시지를 보내기 위한 포트이고 다른 하나는 서버에서 클라이언트로 메시지를 보내기 위한 포트

추가적으로 통신 채널은 클라이언트와 서버가 응답 메시지를 기다리고 있는 동안에도 다른 요청을 받아들일 수 있도록 콜백 기법을 제공한다.

ALPC 채널이 생성되면 다음 3가지중 하나의 메시지 전달기법이 선택된다.

-   256바이트까지의 작은 메시지의 경우 포트의 메시지 큐가 중간 저장소로 사용되고, 메시지는 프로세스에서 프로세스로 복사된다.

-   대용량 메시지는 반드시 `섹션 객체`를 통하여 전달되어야 한다. 섹션 객체란 채널과 연관된 공유 메모리의 영역을 말한다.

-   데이터의 양이 너무 많아서 섹션 객체에 저장될 수 없는 경우, 서버 프로세스가 클라이언트의 주소 공간을 직접 읽거나 쓸 수 있는 API를 사용할 수 있다.

클라이언트는 채널을 설정할 때 대용량 메시지 전송이 필요한지 결정해야만 한다.

클라이언트가 대용량 메시지를 보내야 한다고 결정하면 섹션 객체의 생성을 요청한다. 마찬가지로 서버의 응답메시지가 대용량이라고 예상되면 서버가 섹션 객체를 생성한다.

섹션 객체를 사용하려면 가리키는 포인터와 크기에 관한 정보를 담고 있는 작은 메시지가 전송된다.

Windows의 고급 로컬 프로시즈 호출 설비는 Windows API의 부분이 아니기 때문에 응용프로그래머는 사용할 수 없다.

Windows API를 사용하는 응용은 표준 원격 프로시저 호출을 부른다. 같은 시스템상에 존재하는 프로세스의 RPC가 호출되면 이 RPC는 간접적으로 고급 로컬 프로시저 호출을 통하여 처리된다.

커널 서비스들은 클라리언트 프로세스와 통신하기 위하여 ALPC를 사용한다.

## 3.7.4 파이프

`파이프`는 두 프로세스가 통신할 수 있게 하는 전달자로서 동작한다.

파이프는 초기 UNIX 시스템에서 제공하는 IPC기법의 하나였다. 파이프를 구현하기 위해서는 다음 4가지 문제를 고려해야 한다.

-   파이프가 단방향 통신 또는 양방향 통신을 허용하는가?
-   양방향 통신이 허용된다면 반이중(half duplex)방식인가, 전이중 (full duplex)방식인가?
    -   반이중 방식은 한순간에 한 방향 전송만 가능하고 전이중 방식은 동시에 양방향 데이터 전송이 가능하다.
-   통신하는 두 프로세스 간에 부모-자식과 같은 특정 관계가 존재해야만 하는가?
-   파이프는 네트워크를 통하여 통신이 가능한가, 아니면 동일한 기계 안에 존재하는 두 프로세스끼리만 통신할 수 있는가?

UNIX와 Windows 시스템에서 사용되는 일반 파이프와 지명 파이프

### 3.7.4.1 일반 파이프

일반 파이프는 생산자 - 소비자 형태로 두 프로세스 간의 통신을 허용한다. 생산자는 파이프의 한 종단(쓰기 종단)에 쓰고, 소비자는 다른 종단(읽기 종단)에서 읽는다.

결과적으로 일반 파이프는 한쪽으로만 데이터를 전송할 수 있으며 오직 단방향 통신만을 가능하게 한다.

양방향 통신이 필요하다면 각각 다른 방향의 두 개의 파이프를 사용해야 한다.

### 3.7.4.2 지명 파이프

일반 파이프는 한 쌍의 프로세스가 통신할 수 있는 간단한 기법을 제공한다. 그러나 오로지 프로세스들이 서로 통신하는 동안에만 존재한다. UNIX와 Windows시스템 모두에서 프로세스들이 통신을 마치고 종료하면 일반 파이프는 없어지게 된다.

지명파이프(named pipes)는 좀 더 강력한 통신 도구를 제공한다. 통신은 양방향으로 가능하며 부모-자식 관계도 필요로 하지 않는다.

지명 파이프가 구축되면 여러 프로세스들이 이를 사용하여 통신할 수 있다.

# 기본 개념

다중 프로그래밍의 목적은 CPU이용률을 최대화하기 위해 항상 실행 중인 프로세스를 가지게 하는데 있다.

어떤 프로세스가 대기해야 할 경우(I/O 작업 대기) 운영체제는 CPU를 그 프로세스로부터 회수해 다른 프로세스에 할당한다. 이러한 패턴은 계속된다.

이러한 종류의 스케줄링은 운영체제의 기본적인 긴으이다. 거의 모든 컴퓨터 자원들은 사용되기 전에 스케줄된다. CPU의 스케줄리은 운영체제 설계의 핵심이 된다.

## 5.1.1 CPU-I/O 버스트 사이클

CPU 스케줄링의 성공은 프로세스들의 다음과 같은 관찰자 성질에 의해 좌우된다. 프로세스 실행은 CPU 실행과 I/O 대기의 `사이클`로 구성된다. 프로세스들은 이들 두 상태 사이를 교대로 왔다 갔다한다.

프로세스 실행은 `CPU 버스트`로 시작된다 뒤에 `I/O 버스트`가 발생하고의 반복이다.

마지막 CPU 버스트는 또 다른 I/O 버스트가 뒤따르는 대신 실행을 종료하기 위한 시스템 요청과 함께 끝난다.

주로 짧은 CPU 버스트가 많이 있으며 긴 CPU 버스트는 적다. I/O 중심의 프로그래밈은 전형적으로 짧은 CPU 버스트를 많이 가질 것이다.

CPU 지향 프로그램은 다수의 긴 CPU 버스트를 가질 수 있다. 이러한 분포는 CPU 스케줄링 알고리즘을 구현할 때 매우 중요할 수 있다.

## 5.1.2 CPU 스케줄러

CPU가 유휴 상태가 될 때마다 운영체제는 준비 큐에 있는 프로세스 중에서 하나를 선택해 실행해야 한다. 선택 절차는 `CPU 스케줄러`에 의해 수행된다.

스케줄러는 실행 준비가 되어 있는 메모리 내의 프로세스 중에서 선택하여, 이들 중 하나에게 CPU를 할당한다

준비 큐는 반드시 선입선출 방식의 큐가 아니어도 되는 것에 유의해야 한다.

여러가지 스케줄링 알고리즘들을 고려할 때 알게 되겠지만, 준비 큐는 선입선출 큐, 우선순위 큐, 트리 또는 단순히 순서가 없는 연결리스트로 구현할 수 있다.

개념적으로 볼 때 준비 큐에 있는 모든 프로세스는 CPU에서 실행될 기회를 기다리며 대기하고 있다. 큐에 있는 레코드들은 일반적으로 프로세스들의 프로세스 제어 블록 들이다.

## 5.1.3 선점 및 비선점 스케줄링

CPU 스케줄링 결정은 다음의 네 가지 상황에서 발생할 수 있다.

1.  한 프로세스가 실행 상태에서 대기 상태로 전환될 때

    -   예. I/O 요청이나 자식 프로세스가 종료되기를 기다리기 위해 wat() 호출할때

2.  프로세스가 실행 상태에서 준비 완료 상태로 전환될 때

    -   예. 인터럽트가 발생할 때

3.  프로세스가 대기 상태에서 준비 완료 상태로 전환될 때

    -   예 I/O의 종료 시

4.  프로세스가 종료할 때

상황 1,4의 경우 스케줄링 면에서 선택의 여지가 없다. 실행을 위해 새로운 프로세스(준비 큐에 하나라도 존재할 경우)가 반드시 선택되어야 한다.

상황 2와 3을 위해서는 선택의 여지가 있다.

상황 1,4에서만 스케줄링이 발생할 경우 이러한 스케줄링 방법을 `비선점` 또는 `협조적`이라고 한다. 그렇지 않으면 그것을 (2,3의 경우) `선점`이라고 한다.

비선점(대기상태로 바뀌거나, 종료)스케줄링 하에서는 일단 CPU가 한 프로세스에 할당되면 프로세스가 종료하든지 또는 대기 상태로 전환해 CPU를 방출할 때까지 점유 한다.

Windows, macOS, Linux, UNIX 를 포함한 거의 모든 최신 운영체제들은 선점 스케줄링 알고리즘을 사용한다.

선점 스케줄링은 데이터가 다수의 프로세스에 의해 공유될 때 경쟁 조건을 초래할 수 있다. 두 프로세스가 자료를 공유할때 한 프로세스가 자료를 갱신하고 있는 동안 선점되어 두 번째 프로세스가 실행 가능한 상태가 될 수 있다.

이때 두 번째 프로세스가 데이터를 읽으려고 할 때 데이터의 일관성은 이미 꺠진 상태이다.

선점은 또한 운영체제 커널 설계에 영향을 준다. 시스템 콜을 처리할 동안, 커널은 한 프로세스를 위한 활동으로 바쁠 수 있다. 그러한 활동은(I/O 큐와 같은) 중요한 커널 자료 변경을 포함할 수 있다.

운영체제 커널은 선점 또는 비선점 방식으로 설계될 수 있다. 비선점형 커널은 문맥 교환을 하기 전에 시스템 콜이 완료되거나 입출력 완료를 기다리며 프로세스가 봉쇄되기를 기다린다.

커널 자료구조가 비일관적인 상태에 있을 때 커널이 해당 프로세스를 선점하지 않기 때문에 이러한 방법은 커널 구조를 단순하게 만든다.

하지만 이러한 커널 실행 모델은 주어진 시간안에 태스크의 실행이 완료되어야 하는 실시간 컴퓨팅을 지원하기에는 좋은 모델이 아니다.

선점형 커널에는 공유 커널 데이터 구조에 액세스 할 때 경쟁 조건을 방지하기 위해 mutex락과 같은 기법이 필요하다. 대부분의 최신 운영체제는 이제 커널 모드에서 실행될 때 완전히 선점 될 수 있다.

인터럽트는 언제 일어날지 모르기 때문에 인터럽트에 영향을 받는 코드 부분은 반드시 동시 사용으로부터 보호되어야 한다.

운영체제는 거의 항상 인터럽트를 받아들일 필요가 있는데 그렇지 않으면 입력을 잃어버리거나 또는 출력이 겹쳐서 쓰일 수 있다.

따라서 이러한 부분은 다수 프로세스가 병행으로 접근할 수 없도록 그 진입점에서 인터럽트를 불능화하고 출구에서 인터럽트를 다시 가능화한다.

인터럽트 불능화는 자주 발생해서는 안 되고 아주 적은 수의 명령어들만 포함하여야 한다.

| 구분                | 선점 스케줄링 (Preemptive)                                          | 비선점 스케줄링 (Non-Preemptive)                          |
| ------------------- | ------------------------------------------------------------------- | --------------------------------------------------------- |
| **정의**            | CPU를 할당받은 프로세스를 강제로 중단하고 다른 프로세스로 전환 가능 | CPU를 할당받은 프로세스가 스스로 CPU를 반환할 때까지 유지 |
| **강제 중단 여부**  | 가능 (타이머, 우선순위 등으로 중단)                                 | 불가능 (자발적인 반환만 가능)                             |
| **응답 시간**       | 빠름 (대기 중인 고우선순위 프로세스에 유리)                         | 느림 (긴 작업이 CPU 독점 가능)                            |
| **스케줄링 복잡도** | 복잡하고 오버헤드 큼                                                | 단순하고 오버헤드 적음                                    |
| **대표 알고리즘**   | Round Robin, SRTF, 우선순위 스케줄링 등                             | FCFS, SJF 등                                              |

## 5.1.4 디스패치

CPU 스케줄링 기능에 포함된 또 하나의 요소는 `디스패처`이다 디스패처는 CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에 주는 모듈

다음과 같은 작업을 포함한다.

-   한 프로세스에서 다른 프로세스로 문맥을 교환하는 일 (준비큐-> 실행상태)
-   사용자 모드로 전환하는 일
-   프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동(jump)하는 일

`디스패처는 모든 프로세스의 문맥 교환 시 호출되므로, 가능한 한 최고로 빨리 수행되어야 한다.`

디스패처가 하나의 프로세스를 정지하고 다른 프로세스의 수행을 시작하는데 까지 소요되는 시간을 `디스패치 지연` 이라고 한다.

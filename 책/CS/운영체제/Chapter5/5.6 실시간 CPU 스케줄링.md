# 실시간 CPU 스케줄링

실시간 운영체제에서 CPU를 스케줄링 할 때는 특별한 쟁점을 고려해야 한다. 일반적으로 연성(soft) 실시간 시스템과 경성(hard) 실시간 시스템으로 구분한다.

`연성 실시간 시스템`은 중요한 실시간 프로세스가 스케줄 되는 시점에 관해 아무런 보장을 하지 않는다. 오직 중요 프로세스가 그렇지 않은 프로세스들에 비해 우선권을 가진다는 것만 보장한다.

`경성 실시간 시스템`은 더 엄격한 요구조건을 만족시켜야 한다. 태스크는 반드시 마감시간 까지 서비스를 받아야 하며 마감시간이 지난 이후에 서비스를 받는 것은 서비스를 전혀 받지 않는 것과 동일한 결과를 낳는다.

## 5.6.1 지연시간 최소화

실시간 시스템의 이벤트-중심의 특성을 생각해보자 시스템을 일반적으로 실시간으로 발생하는 이벤트를 기다린다. 이벤트는 타이머가 만료되었을 떄처럼 스프트웨어적으로 발생하기도 하고, 우너격으로 제어되던 장치가 방해물을 만났을 떄와 같이 하드웨어적으로도 발생하기도 한다.

이벤트가 발생하면 시스템은 가능한 빨리 그에 응답을 하고 그에 맞는 동작을 수행하여야 한다. `이벤트 지연시간`은 이벤트가 발생해서 그에 맞는 서비스가 수행될 때까지의 시간을 말한다.

일반적으로 이벤트가 다르면 그에 따른 지연시간 역시 다르다.

다음의 두 가지 유형의 지연시간이 실시간 시스템의 성능을 좌우한다.

-   인터럽트 지연시간
-   디스패치 지연시간

`인터럽트 지연시간`은 CPU에 인터럽트가 발생한 시점부터 해당 인터럽트 처리 루틴이 시작하기까지의 시간을 말한다.

인터럽트가 발생하면 운영체제는 우선 수행 중인 명령어를 완수하고 발생한 인터럽트의 종류를 결정한다. 해당 인터럽트 서비스 루틴(ISR)을 사용하여 인터럽트를 처리하기 전에 현재 수행중인 프로세스의 상태를 저장해야만 한다. 이러한 작업을 모두 수행하는 데 걸리는 시간이 인터럽트 지연시간이다.

실시칸 태스크가 즉시 수행될 수 있도록 인터럽트 지연시간을 최소화하는 것은 실시간 운영체제에 매우 종요한 일이다.

경성(하드) 실시간 시스템에서는 인터럽트 지연시간을 최소로 해야 할 뿐만 아니라 엄격한 요구조건을 만족시키기 위하여 정해진 시간보다 작아야 한다.

인터럽트 지연시간에 영향을 주는 요인 중 하나는 커널 데이터 구조체를 갱신하는 동안 인터럽트가 불능케 되는 시간이다. 실시간 운영체제는 인터럽트 불능 시간을 매우 짧게 해야 한다.

`디스패치 지연시간`은 스케줄링 디스패처가 하나의 프로세스를 블록시키고 다른 프로세스를 시작하는 데까지 걸리는 시간을 말한다.

CPU를 즉시 사용해야 하는 실시간 태스크가 있다면, 실시간 운영체제는 이 지연 시간을 최소화해야 한다. 디스패치 지연시간을 최소화하는 가장 효과적인 방법은 선점형 커널이다

디스패치 지연시간의 `충돌 단계`는 다음의 두 가지 요소로 구성되어 있다.

-   커널에서 동작하는 프로세스에 대한 선점
-   높은 우선순위의 프로세스가 필요한 자원을 낮은 우선순위 프로세스 자원이 방출

충돌 단계에 이어 디스패치 단계는 우선순위가 높은 프로세스를 사용 가능한 CPU에 스케줄한다.

## 5.6.2 우선순위 기반 스케줄링

실시간 운영체제에서 가장 중요한 기능은 실시간 프로세스에 CPU가 필요할 때 바로 응답을 해주는 것이다.

따라서 실시간 운영체제의 스케줄러는 선점을 이용한 우선순위 기반의 알고리즘을 지원해야만 한다.

선점 및 우선순위 기반의 스케줄러를 제공하는 것은 단지 연성 실시간 기능을 제공하는 것에 불과하다.

경성 실시간 시스템에서는 실시간 태스크가 마감시간 내에 확실히 수행되는 것을 보장해야만 하며, 그렇기 때문에 부가적인 스케줄링 기법이 필요하다.

프로세스들은 주기적이다 일정한 간격으로 CPU가 필요하다. 스케줄러는 이들 주기, 마감, 수행 시간사이의 관게를 이용하여 마감시간과 주기적 프로세스의 실행 빈도에 따라서 우선순위를 정한다.

이런 형식의 스케줄링에서 일반적이지 않은 것은 프로세스가 자신의 마감시간을 스케줄러에게 알려야만 할 수도 있다는 것

따라서 `승인 제어`알고리즘을 이용해서 스케줄러는 마감시간 이내에 완수할 수 있는 프로세스는 실행을 허락하고 그렇지 못한 경우에는 요구를 거절한다.

## 5.6.3 Rate-Monotonic 스케줄링

Rate-Monotonic 스케줄링 알고리즘은 선점 가능한 정적 우선순위 정책을 이용하여 주기 태스크들을 스케줄 한다. 낮은 우선순위의 프로세스가 실행 중이고 높은 우선수의 프로세스가 실행 준비가 되면, 높은 우선순위의 프로세스가 낮은 우선순위 프로세스를 선점한다

주기가 짧은 태스크는 높은 우선순위가, 주기가 길면 낮은 우선순위가 배정된다.

이 정책은 CPU를 더 자주 필요로 하는 태스크에 더 높은 우선순위를 주려는 원리에 기반들 두고 있다.

rate-monotonic 스케줄링은 주기 프로세스들의 처리시간은 각각의 cpu 버스트와 같다고 가정한다, 즉 프로세스가 CPU를 차지하는 시간은 cpu버스트 시간과 같다.

rate-monotonic 스케줄링 기법은 최적이기는 하지만 많은 제약이 있다 cpu 이용률은 한계가 있기 때문에 cpu 자원을 최대화해서 사용하는 것은 불가능하다.

| 항목          | 설명                                         |
| ------------- | -------------------------------------------- |
| 스케줄 방식   | 고정 우선순위, 선점형                        |
| 우선순위 기준 | 짧은 주기 → 높은 우선순위                    |
| 스케줄 조건   | 모든 태스크는 자신의 주기 내에 종료되어야 함 |
| 활용 분야     | 임베디드 시스템, 미션 크리티컬 시스템 등     |

| 태스크 | 실행 시간(C) | 주기(T) | 우선순위 |
| ------ | ------------ | ------- | -------- |
| T1     | 1            | 4       | 높음     |
| T2     | 2            | 6       | 낮음     |

→ T1이 더 짧은 주기를 가지므로 높은 우선순위를 가짐  
→ T2 실행 중이라도 T1이 도착하면 **T2를 선점**

-   비주기적 태스크 처리 불가
-   CPU 100% 활용 어려움 (이론적 한계 존재)
-   동적인 우선순위 변경 불가능

## 5.6.4 Earliest-Deadline-First 스케줄링

Earliest-Deadline-First 스케줄링 (EDF) 스케줄링 기법은 마감시간에 따라서 우선순위를 동적으로 부여한다. 마감시간이 빠를수록 우선순위는 높아지고 늦을수록 낮아진다.

EDF정책에서는 프로세스가 실행 가능하게 되면 자신의 마감시간을 시스템에 알려야 한다. 우선순위는 새로 실행 가능하게 된 프로세스의 마감시간에 맞춰서 다시 조정된다. 이점이 고정되어 있는 rate-monotonic 스케줄링 기법과의 차이

rate-monotonic 알고리즘과는 달리 EDF 스케줄링 알고리즘은 프로세스들이 주기적일 필요도 없고, CPU 할당시간도 상수 값으로 정해질 필요가 없다.

그러나 프로세스가 실행 가능해질 때 자신의 마감시간을 스케줄러에게 알려주어야 한다. EDF가 매력적인 이유는 이론상으로 최적이라는 것

이론적으로 모든 프로세스가 마감시간을 만족시키도록 스케줄 할 수 있고 cpu 이용률 역시 100%가 될 수 있다. 그러나 실제로는 프로세스 사이, 또는 인터럽트 핸들링때의 문맥교환 비용 떄문에 100% cpu 이용률은 불가능하다.

| 항목          | 설명                                |
| ------------- | ----------------------------------- |
| 우선순위 기준 | 마감 기한이 가장 가까운 태스크      |
| 우선순위 타입 | 동적 (실행 시점마다 재계산)         |
| 스케줄 가능성 | CPU 사용률 100%까지 스케줄 가능     |
| 스케줄 방식   | 선점형 또는 비선점형                |
| 실시간성      | 하드/소프트 실시간 시스템 모두 적합 |
| 구현 복잡도   | RMS보다 복잡 (우선순위 재계산 필요) |

| 태스크 | 실행 시간(C) | 주기(T) | 마감 기한(Deadline) | 우선순위 |
| ------ | ------------ | ------- | ------------------- | -------- |
| T1     | 1            | 4       | 4                   | 높음     |
| T2     | 2            | 6       | 6                   | 낮음     |

→ T1의 마감이 더 빠르므로 먼저 실행됨

-   CPU를 최대 **100%까지 효율적으로 활용**
-   **비주기적 태스크 처리 가능**
-   실시간성 높고 **적응성 우수**

-   **우선순위 계산 오버헤드 존재**
-   모든 태스크에 마감기한 정보 필요
-   **정렬 및 선점이 잦아 구현이 복잡**

| 항목                 | RMS (Rate-Monotonic) | EDF (Earliest Deadline First) |
| -------------------- | -------------------- | ----------------------------- |
| 우선순위 기준        | 주기가 짧을수록 높음 | 마감기한이 가까울수록 높음    |
| 우선순위 유형        | 고정                 | 동적                          |
| 스케줄 가능성        | 약 69~82%            | 최대 100%                     |
| 비주기적 태스크 처리 | 불가능               | 가능                          |
| 구현 난이도          | 낮음                 | 높음                          |

## 5.6.2 알정 비율의 몫 스케줄링

`일정 비율의 몫`스케줄러는 모든 응용들에 T개의 시간 몫을 할당하여 동작한다.

한개의 응용이 N개의 시간 몫을 할당 받으면 그 응용은 모든 프로세스 시간 중 N/T 시간을 할당받게 된다.

일정 비율의 몫 스케줄러는 응용이 시간 몫을 할당받는 것을 보장하는 승인 제어 정책과 함께 동작해야만 한다.

승인 제어 정책은 사용가능한 충분한 몫이 존재할 때, 그 범위 내의 몫을 요구하는 클라이언트들에게만 실행을 허락한다.

총100개의 예에서 50 + 15 + 20 = 85개의 몫이 할당되어 있을때 새로운 프로세스 D가 30 몫을 요구하면 승인 컨트롤러는 D의 진입을 거부한다.

## 5.6.6 POSIX 실시간 스케줄링

POSIX는 실시간 컴퓨팅 용으로 POSIX.1b라는 확장을 제공한다

POSIX는 다음과 같이 실시간 스레드를 위하여 두 개의 스케줄링 클래스를 정의한다.

-   SCHED FIFO
-   SCHED RR

# 운영체제의 작동

```
HADOOP
단순하고 저렴한 하드웨어 구성요소를 포함하는 클러스터형 시스템에서 빅데이터의 분산처리에 사용되는 공개 소스 소프트웨어 프레임워크

작업은 클러스터 노드에 할당되며 하둡은 노드 간 통신을 정렬하여 처리할 병렬 계산을 관리하고 결과를 통합

하둡의 세 가지 구성요소
- 분산 컴퓨팅 노드에서 데이터와 파일을 관리하는 분산파일 시스템
- YARN(Yet Another Resource Negotiator) 프레임워크는 클러스터 내의 자원을 관리하고 노트에 작업을 스케줄
- MapReduce 시스템은 클러스터의 노드에서 데이터를 병렬 처리
```

-   전원을 켜거나 재부팅할때 초기 프로그램을 실행해야 한다.

-   초기 프로그램 또는 부트스트랩 프로그램은 단순한 형태를 띠는 경향이 있다.
-   일반적으로 컴퓨터 하드웨어 내에 펌웨어로 저장
-   CPU 레지스터에서 장치 컨트롤러, 메모리 내용에 이르기까지 시스템의 모든 측면을 초기화
-   부트스트램 프로그램은 운영체제를 적재하는 방법, 해당 시스템을 실행 시작하는 방법을 알아야 한다.
    -   그러기위해 부트스트랩 프로그램이 운영체제 커널을 찾아 메모리에 적재
-   커널이 적재되어 실행되면 시스템과 사용자에게 서비스를 제공할 수 있다.
-   일부 버시스는 커널이 실행되는 전체 시간동안 실행되는 `시스템 데몬`이 되기 위해 부팅할때 메모리에 적재되는 시스템 프로그램에 의해 커널 외부에서 제공된다.
    -   Linux에서 첫 번째 시스템 프로그램은 "systemd" 이며 많은 다른 데몬을 시작
-   이 단계가 완료되면 시스템이 부팅되고 이벤트를 기다린다
-   실행할 프로세스, I/O장치, 응답할 사용자가 없는 경우 OS는 발생할때까지 기다린다.
-   이벤트는 인터럽트를 발생시켜 신호를 보낸다.
    -   또다른 인터럽트의 형태는 `트랩(또는 예외)`으로 오류또는 사용자 프로그램의 특정 요청에 의해 발생하는 소프트웨어 생성 인터럽트이다.
    -   이 특정 요청은 `시스템 콜`이라는 특수 연산을 실행하여 요청되고 OS가 제공하는 서비스가 수행될것을 요구한다.

## 1.4.1 다중 프로그래밍과 다중 태스킹

다중 프로그래밍 : CPU 가 항상 한 개는 실행할 수 있도록 프로그램을 구성하여 CPU 이용률을 높이고 사용자 만족도를 높인다.

프로세스 : 다중 프로그램 시스템에서 실행 중인 프로그램

운영체제는 여러 프로세스를 동시에 메모리에 유지한다. 이러한 프로세스 중 하나를 선택하여 실행하기 시작한다.

다중 태스킹 : 다중 프로그래밍의 논리적 확장이다. 다중 태스킹 시스템에서 CPU는 여러 프로세스를 전환하며 프로세스를 실행하지만 전환이 자주 발생하여 사용자에게 빠른 응답 시간을 제공하게 된다.

여러 프로세스를 병행하게 실행하려면 프로세스 스케줄링, 디스크 저장장치 및 메모리 관리를 포함하여 운영체제의 모든 단계에서 서로 영향을 미치는 기능에 제한되어야 한다.

다중 태스킹 시스템에서 운영체제는 적절한 응답 시간을 보장해야한다. 일반적으로 `가상 메모리`를 사용 일부만 메모리에 적재된 프로세스의 실행을 허용하는 기법

가상메모리 기법의 주요한 이점은 프로그램이 물리 메모리의 크기보다 더 커도 된다는 것

가상메모리는 메인 메모리를 크고 균등한 저장장치의 배열로 추상화 하여 사용자에게 보이는 논리 메모리를 물리 메모리로부터 분리시킨다.

파일시스템을 제공해야 하고 프로세스 동기화 및 통신을 위한 기법과 교착상태에 빠지지 않도록 보장해야 한다.

### 1.4.2 이중-모드와 다중모드 운용

운영체제와 사용자는 컴퓨터 시스템의 하드웨어 및 소프트웨어 자원을 공유하기 때문에 잘못된 프로그램으로 인해 다른 프로그램 또는 운영체제 자체가 잘못 실행될 수 없도록 보장해야 한다.

적어도 두 개의 독립된 연산모드(비트번호)

-   사용자 모드(1)
-   커널 모드(수퍼바이저 모드, 시스템 모드, 특권 모드)(0)

`모드 비트`라고 하는 하나의 비트가 현재의 모드를 나타내기 위해 컴퓨터의 하드웨어에 추가되었다.

컴퓨터 시스템의 사용자 응용을 위하여 실행될 때 시스템은 사용자 모드에 있게 된다. 사용자 응용이 운영체제로부터 서비스를 요청하면 (`시스템 콜을 통함`) 이 요청을 수행하기 위해서는 사용자 모드에서 커널 모드로 전환해야 한다.

시스템 부트시 하드웨어는 커널모드에서 시작한다. 이어 운영체제가 적재되고 사용자 모드에서 사용자 프로세스가 시작된다.

트랩이나 인터럽트가 발생할 떄마다, 하드웨어는 사용자 모드에서 커널 모드로 전환한다. (모드비트를 0으로 변경)

운영체제는 컴퓨터의 제어를 얻을 떄마다 항상 커널 모드에 있게 된다. 시스템은 사용자 프로그램으로 제어를 넘기기 전에 항상 사용자모드(비트 1)로 전환한다.

동작의 이중 모드는 잘못된 사용자로부터 운영체제를, 그리고 잘못된 사용자 서로를 보호하는 방법을 제공한다.

악영향을 끼칠 수 있는 일부 명령을 `특권 명령`으로 지정함으로 써 이러한 보호를 달성한다.

`하드웨어는 특권 명령이 커널 모드에서만 수행되도록 허용한다.(사용자 모드에서 특권 명령 수행 시도시 하드웨어는 이를 실행하지 않고 운영체제로 트랩을 건다.)`

커널 모드로 전환하는 명령어가 특권 명령의 예이다. 다른 예로는 I/O 제어, 타이머 관리 및 인터럽트 관리가 있다.

가상화를 지원하는 CPU는 종종 VMM(virtual machine manager)이 시스템을 제어하는 시점을 표시하기 위한 별도의 모드를 가진다.

정리하자면

-   초기 제어는 운영체제에 있으며 여기서 명령은 커널 모드에서 실행된다.
-   사용자 응용프로그램에 제어가 넘어가면 모드는 사용자 모드로 설정된다.
-   결국 인터럽트, 트랩 또는 시스템 콜을 통해 제어가 운영체제로 다시 전환된다.

시스템 콜은 사용자 프로그램이 자신을 대신하여 운영체제가 수행하도록 지정되어 있는 작업을 운영체제에 요청할 수 있는 방법을 제공한다.

운영체제안에 커널이 있고 응요프로그램은 시스템 콜을 통해 커널에 작업을 지시한다

시스템 콜은 일반적으로 인터럽트 벡트의 특정 위치로 트랩을 거는 형태를 취한다. 이 트랩은 보통의 trap 명령어를 통해 수행되지만 몇몇 시스템은 syscall 이라는 특정 명령어를 가지기도 한다.

### 1.4.3 타이머

사용자 프로그램이 무한 루프에 빠지거나 시스템 서비스 호출에 실패하여 제어가 운영체제로 북기하지 않는 경우를 방지하기 위해 `타이머`를 사용할 수 있다.

타이머는 지정된 시간 후 컴퓨터를 인터럽트 하도록 설정할 수 있다.

이 시간은 고정 혹은 가변일 수 있다

`가변 타이머`는 일반적으로 고정률의 클록과 계수기로 구현한다. 운영체제는 계수기 값을 설정한다.

사용자에게 제어를 양도하기 전에 운영체제는 타이머가 인터럽트 할 수 있도록 설정되었는지를 확인한다. 타이머가 인터럽트를 발생시키면 제어는 자동으로 운영체제로 넘어간다.

운영체제는 인터럽트를 치명적인 오류로 취급하거나, 또는 프로그램에게 더 많은 시간을 줄 수 있다.

타이머의 값 변경 명령은 특권 명령이다.

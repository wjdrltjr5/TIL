# Mutex Locks

운영체제 설계자들은 임계구역 문제를 해결하기 위한 상위 수준 소프트웨어 도구들을 개발한다.

가장 간단한 도구가 `mutex 락`이다 뮤텍스라는 용어는 mutual exclusion의 축약 형태이다.

임계구역을 보호하고, 경쟁 조건을 방지하기 위해 뮤텍스 락을 사용한다.

프로세스는 임계구역에 들어가기 전 반드시 락을 획득해야 하고 빠져나올때 락을 반환해야 한다.

acquire()함수가 락을 획득하고 release() 함수가 락을 반환한다.

Mutex 락은 available이라는 불린 변수를 가지는데 이 변수 값이 락의 가용 여부를 표시한다.

락이 가용하면 acquire() 호출은 성공하고 락은 곧 사용 불가 상태가된다.

사용 불가 상태의 락을 획득하려고 시도하는 프로세스는 락이 반환될 때까지 봉쇄된다.

```c
acquire(){
  while(!available){
    /* busy wait*/
  }
  available = false;
}

release(){
  available = true;
}

```

Mutex 락을 이용한 임계구역 문제 해결책

```c
while(true){
  acquire()
  critical section

  release()
  remainder section
}

```

acquire() 또는 release() 함수 호출은 원자적으로 수행되어야 한다. 따라서 뮤텍스 락은 CAS를 사용하여 구현될 수 있다.

지금까지의 단점은 `바쁜 대기 (busy waiting)`를 해야 한다는 것 프로세스가 임계구역에 있는 동안 들어가기를 원하는 다른 프로세스들은 acquire()함수를 호출하는 반복문을 계속 실행해야 한다.

> 락경합 : 락을 획득하려고 시도하는 동안 스레드가 봉쇄되면 락은 경합 상태로 간주한다. 스레드가 락을 얻으려고 시도학때 락을 사용할 수 있으면 락은 비경합 상태로 간주한다. 높은 경합 상태의 락은 병행 실행 응용프로그램의 성능을 전체적으로 저하한다.

> 짧은 기간이란 : 스핀락은 락이 짧은 기간동안 유지될 때 다중 처리기 시스템에서 선택하는 락 기법으로 종종 인식된다. 락을 기다리는 스레드는 2번의 문맥교환이 필요하다. 첫 번째는 스레드를 대기 상태로 옮기기위한 교환, 두 번째는 락이 사용 가능해지면 대기 중인 스레드를 복원하기 위한 문맥 교환. 일반적인 규칙은 락이 유지되는 기간이 문맥교환을 두 번 하는 시간보다 짧은 경우 스핀락을 사용하는 것이다

`바쁜 대기는 다른 프로세스가 생산적으로 사용할 수 있는 CPU주기를 낭비한다 (계속 점유하니까)`

위에서 설명한 뮤텍스 락 유형을 `스핀락` 이라고 한다 락을 사용할 수 있을 때까지 프로세스가 회전하기 때문

`그러나 스핀락은 프로세스가 락을 기다려야 하고 문맥 교환에 상당한 시간이 소요될 때 문맥교환이 필요하지 않다는 장점이 있다.`

다중 코어 시스템의 특정 상황에서는 실제로 락이 필요할 때 스핀락이 선호된다. 잠깐동안 락을 유지해야 하는 경우 다른 스레드가 하나의 코어에서 임계구역을 실행하는 동안 스레드는 다른 처리 코어에서 스핀하고 있을 수 있다.

최신 다중 코어 컴퓨팅 시스템에서 스핀락은 많은 운영체제에서 널리 사용된다.

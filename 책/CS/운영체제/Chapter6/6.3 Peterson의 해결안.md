# Peterson의 해결안

현대 컴퓨터 구조가 load와 store같은 기본적인 기계어를 수행하는 방식 때문에 Peterson의 해결안이 이러한 구조에서 올바르게 실행된다고 보장할 수는 없다.

그러나 임계구역 문제를 해결하기 위한 좋은 알고리즘적인 설명을 제공하고 상호 배제, 진행, 한정된 대기의 요구 조건을 중점으로 다루는 소프트웨어를 설계하는데 필요한 복잡성을 잘 설명한다.

Peterson의 해결안은 임계구역과 나머지 구역을 번갈가 가며 실행하는 두 개의 프로세스로 한정된다.

프로세스는 p0과 p1로 번호를 매긴다 편의상 pi라고 표현하면 pj는 다른 프로세스를 가리키고 j는 1-i와 같게 된다.

Peterson의 해결안은 두 프로세스가 두 개의 데이터 항목을 공유하도록 하여 해결한다.

```
int turn;
boolean flag[2];
```

변수 turn은 임계구역으로 진입할 순번을 나타낸다. turn == i 이면 프로세스 Pi가 임계구역에서 실행될 수 있다 flag 배열은 프로세스가 임계구역으로 진입할 준비가 되었다는 것을 나타낸다.

flag[i] 가 참이라면 Pi가 임계구역을 진입할 준비가 된다.

임계구역으로 진합하기 위해서 Pi는 먼저 flag[i]를 참으로 만들고, turn을 j로 지정한다.

이렇게 함으로 써 프로세스 j가 임계구역으로 진입하기를 원한다면 진입 가능하다는 것을 보장한다. 만일 두 프로세스가 동시에 진입하기를 원한다면 turn은 거의 동시에 i와j로 지정될 것이다 그러나 둘 중 오직 한 배정만이 지속된다. 다른 배정은 발생하기는 하지만 곧바로 겹쳐 쓰이게 된다.

turn의 궁극적인 값이 둘 중 누가 먼저 임계구역으로 진입할 것인가를 결저앟ㄴ다.

해결책이 올바르게 동작하는 것을 증명하려면 다음과 같은 사실을 보여야 한다.

-   상호 배제가 제대로 지켜진다는 사실
-   진행에 대한 요구 조건을 만족한다는 사실(progress)
-   대기 시간이 한없이 길어지지 않는다는 사실(bounded waiting)

```c
while(true){
  flag[i] = true;
  turn = j;
  while(flag[j] %% turn == j)
    ;
    /*critical section*/
  flag[i] = false;

    /*remainder section*/
}
```

1번을 증명하려면 각 Pi가 임계구역에 들어가기 위해서는 반드시 flag[j] == false이든지 아니면 turn == i 여야 함을 주목해야 한다.

두 프로세스 모두 자기 임계구역을 수행중이라면 flag[0] == flag[1] == true 로 지정하여야 한다.

위 두가지 분석을 살펴보면 P0과 P1이 모두 while문을 동시에 성공적으로 지나가지는 못했을 것

turn 변수의 값은 0이든지 1 둘 중 하나여야 하지 동시에 두 값을 가질 수는 없기 때문 따라서 둘 중 하나만이 while을 성공적으로 지나갈 수 있었을 것이도 나머지는 turn == j 문을 한번 이상 더 실행했어야 할 것

그렇지만 그 순간에 flag[j] == true && turn == j 인 상태는 Pj가 임계구역 안에 있을 때에는 변하지 않는다. 따라서 상호 배제는 지켜진다.

2,3을 증명하려면 프로세스 Pi가 임계구역에 진입 못 하도록 막는 방법은 while문에서 (flag[j] == true && turn == j)조건으로 묶어 두어 계속 공회전 하도록 만드는 방법이라는 사실에 주목

이 while loop가 유일한 방법이기 때문이다 Pj가 임계구역에 들어갈 준비가 안 되었을 때는 (flag[j] == false) 이고 Pi는 임계구역에 진입할 수 있다.

Pj가 flag[j]를 true로 지정하고 역시 자신의 while문을 수행하게 되면 이때 turn == i 이든지 turn == j일것이다 turn == i 라면 Pi가 임계구역에 진입하게 되고 turn == j 라면 Pj가 임계구역에 진입하게 된다.

추후 Pj가 임계구역에 빠져나올 때는 Pj가 flag[j]를 false로 재지정하여 Pi로 하여금 진입하게 만들어 준다.

Pj가 flag[j]를 true로 재지정하고 나면 반드시 turn 값도 i로 재지정해주어야 한다. Pi는 while문을 수행하는 동안 turn값을 바꾸지 않기 때문에 Pi는 Pj가 지난번에 진입했다면 이번에도 자기도 한번은 들어갈 수 있게 (progress 보장)된다. (대기시간이 한없이 길어지지 않음)

Peterson의 해결안은 최신 컴퓨터 아키텍처에서 작동한다고 보장되지 않는다 주된 이유는 시스템 성능을 향상하기 위해 프로세서 및 또는 컴파일러가 종속성이 없는 읽기 및 쓰기 작업을 재정렬 할 수 있기 떄문

단일 스레드 응용프로그램의 경우 최종 결과가 예상한 것과 일치하기 떄문에 프로그램의 정확성 측면에서 재정렬은 중요하지 않다.

그러나 데이터를 공유하는 다중 스레드 응용프로그램의 경우 명령 순서가 바뀌게 되면 데이터의 일관성이 깨지거나 예기치 못한 결과를 낳을 수 있다.

상호 배제를 유지하는 유일한 방법은 적절한 동기화 도구를 사용하는 것이다

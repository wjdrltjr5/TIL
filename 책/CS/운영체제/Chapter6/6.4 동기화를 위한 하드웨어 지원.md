# 6.4 동기화를 위한 하드웨어 지원

논의된 것처럼 소프트웨어 기반 해결책은 최신 컴퓨터 아키텍처에서 작동하지 않을 수 있다.

임계구역 문제를 해결하기 위한 지원을 제공하는 세 가지 하드웨어 명령어를 제시한다.

이러한 프리미티브 연산은 동기화 도구로 직접 사용될 수 있거나 더 추상적인 동기화 기법의 기초 형태로 사용될 수 있다.

## 6.4.1 메모리 장벽

컴퓨터 아키텍처가 응용 프로그램에게 제공하는 메모리 접근 시 보장되는 사항을 결정한 방식을 `메모리 모델`이라고 한다.

일반적으로 메모리 모델은 두 가지 범주 중 하나에 속한다.

-   강한 순서 : 한 프로세서의 메모리 변경 결과가 다른 모든 프로세서에 즉시 보임

-   약한 순서 : 한 프로세서의 메모리 변경 결과가 다른 프로세서에 즉시 보이지 않음

메모리 모델은 프로세서 유형에 따라 다르므로 커널 개발자는 공유 메모리 다중 처리기에서 메모리 변경의 가시성에 대한 어떠한 가정도 할 수 없다.

이 문제를 해결하기 위해 컴퓨터 아키텍처는 메모리의 모든 변경 사항을 다른 모든 프로세서로 전파하는 명령어를 제공하여 다른 프로세서에서 실행 중인 스레드에 메모리 변경 사항이 보이는 것을 보장한다.

이러한 명령어를 `메모리 장벽` 또는 `메로리 펜스`라고 한다.

메모리 장벽 명령어가 실행될 때, 시스템은 후속 적재 또는 저장 연산이 수행되기 전에 모든 적재 및 저장이 완료되도록 한다.

따라서 명령이 재정렬되더라도 메모리 장벽은 향후 적재 또는 저장 작업이 수행되기 전에 저장 작업이 메모리에서 완료되어 다른 프로세서에 보이도록 한다.

메모리 장벅은 매누 낮은 수준의 연산으로 간주하며 일반적으로 상호 배제를 보장하는 특수 코드를 작성할 때 커널 개발자만 사용한다.

## 6.4.2 하드웨어 명령어

많은 현대 기계들은 한 워드의 내용을 검사하고 변경하거나 두 워드의 내용을 `원자적으로`교환 할 수 있는 인터럽트 되지 않는 하나의 단위로서 특별한 하드웨어 명령어들을 제공한다.

이들 특별한 명령어들을 사용하여 임계구역 문제를 상대적으로 간단한 방식으로 해결할 수 있다.

test_and_set()명령어의 중요한 특징으로는 이 명령어가 `원자적`으로 실행된다는 것.

```c
boolean test_and_set(boolean *target){
  boolean rv = *target;
  *target = true;

  return rv;
}
```

만일 두 개의 test_and_set() 명령어가 동시에 실행된다면(다른 코어에서) 이들은 어떤 임의의 순서로 순차적으로 실행될 것이다.

```c
do{
  while(test_and_set(&lock))
    /*do noting*/

    /*critical section */

  lock = false;
    /*remainder section*/
}while(true);
```

compare_and_swap() 명령어(CAS)는 test_and_set() 명령어와 마찬가지로 두 개의 워드에 대해 원자적인 연산을 하지만 두 워드의 내용 교환에 기반을 둔 다른 기법을 사용한다.

CAS는 3개의 피 연산자를 대상으로 연산을 하며, 피연산자 value는 오직 (\*value == expected)수식이 참일 때에만 new_value로 지정된다.

```c
int compare_and_swap(int *value, int expected, int new_value){
  int temp = *value;

  if(*value == expected)
    *value = new_value;


  return temp;
}
```

어떠한 경우에든 CAS 명령어는 언제나 value의 원래 값을 반환한다. 이 명령의 중요한 특징은 명령이 원자적으로 실행된다는 것

따라서 두개의 CAS 명령이 실행되면 임의의 순서로 순차적으로 실행된다.

CAS를 사용하는 상호 배제는 전역변수(lock)이 선언되고 0으로 초기화 된다. compare_and_swap()을 호출한 첫 번째 프로세스는 lock을 1로 지정할 것이다.

lock의 원래 값이 expected값과 같으므로 프로세스는 임계구역으로 들어간다. 이후의 compare_and_swap() 호출은 현재 lock의 값이 기댓 값 0과 같지 않기 때문에 성공하지 못한다. 프로세스가 임계구역을 빠져나올 때 lock을 으로 변경하고 다른 프로세스가 임계구역에 들어갈 수 있게 허용한다.

```c
while(true){
  while(compare_and_swap(&lock, 0, 1) != 0)
    /* do noting */

    /* critical section*/
  lock = 0;
  /*remainder section */
}
```

위 알고리즘은 상호 배제 조건은 만족시키지만 한정된 대기 조건을 만족시키지 못한다. 임계구역 요구 조건을 모두 만족시키는 compare_and_swap() 알고리즘

```c
while(true){
  waiting[i] = true;
  key = 1;
  while(waiting[i] && key == 1)
    key = compare_and_swap(&lock, 0, 1);
  waiting[i] = false;
    /* critical section */
  j = (i + 1) % n;
  while((j != i) && !waiting[j])
    j = (j+1) % n;

  if(j == i)
    lock = 0;
  else
    waiting[j] = false;

    /*remainder section*/
}
```

공통 데이터는 아래와 같다.

```c
boolean waiting[n];
int lock;
```

waiting 배열의 원소는 false로 초기화 되고 lock는 0으로 초기화 된다. 이 ㄹ알고리즘이 상호 배제 조건을 만족시킨다는 것을 증명하기 위해서 Pi가 임계구역에 진입하는 경우가 오직 waiting[i] == false 이든지 key == 0 이라는 사실에 주의

key값은 compare_and_swap() 명령어를 실행했을 경우에만 0이 된다. 처음으로 compare_and_swap()을 실행시키는 프로세스는 key == 0을 발견할 것이다.

다른 프로세스들은 모두 기다려야 한다. 변수 waiting[i] 가 false가 되는 것은 다른 프로세스가 임계구역을 떠날 때 뿐이다.

이때 오직 한개의 waiting[i]만이 false로 지정되고 따라서 상호 배제가 보장된다.

progress 조건이 만족함을 보이기 위해서는 위의 상호 배제 논리를 여기에도 비슷하게 사용할 수 있다 임계구역을 떠나는 프로세스는 lock을 0으로 하든지 waiting[j]를 false로 한다.

어느 쪽이든 둘 다 임계구역으로 들어가고자 하는 프로세스를 진입하게 만들어준다.

한정된 대기 조건을 만족시킴을 증명하기 위해서는 한 프로세스가 임계구역을 떠날때에는 waiting 배열을 순횐하면서 훑어본다는 사실에 착안하면 된다.

순환하면서 조사하여 (waiting[j] == true)이면서 위 순환 순서 중 첫 번째 프로세스가 임계구역에 들어가게 된다.

따라서 임계구역에 들어가고자 하는 프로세스는 최대한 n-1회만 양보하면 들어갈 수 있다.

## 6.4.3 원자적 변수

일반적으로 compare_and_swap() 명령어는 상호 배제를 제공하기 위해 직접 사용하지 않는다.

오히려 임계구역 문제를 해결하는 다른 도구를 구축하기 위한 기본 구성요소로 사용된다.

그러한 도구 중 하나는 `원자적 변수`로 , 정수 및 부울과 같은 기본 데이터 유형에 대한 원자적 연산을 제공한다.(Java의 Atomic 이 CAS사용)

정수 값을 증가시키거나 감소시키면 경쟁 조건이 발생할 수 있음을 알고있다.

원자적 변수는 카운터가 증가할 떄와 같이 갱신되는 동안 단일 변수에 대한 데이터 경재이 있을 수 있는 상황에서 상호 배제를 보장하는 데 사용될 수 있다.

원자적 변수를 지원하는 대부분의 시스템은 원자적 변수에 접근하고 조작하기 위한 기능뿐만 아니라 특별한 원자적 데이터 유형을 제공한다.

이러한 함수는 compare_and_swap() 연산을 사용하여 구현된다.

```c
// 원자적정수 sequence를 증사시킨다.
increment(&sequence);

void increment(atomic_int *v){
  int temp;
  do{
    temp = *v;
  }while(temp != compare_and_swap(v, temp, temp+1));
}
```

원자적 변수를 원자적 갱신을 제공하지만 모든 상황에서 경쟁 조건을 완벽히 해결하지는 않는다.

`원자적 변수는 운영체제 및 병행 응용프로그램에서 일반적으로 사용되지만 카운터 및 시퀀스 생성기와 같은 데이터 한 개의 갱신에만 제한되는 경우가 많다.`

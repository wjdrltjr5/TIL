# 모니터

세마포가 프로세스 간의 동기화를 위해서 편리하고 효과적으로 쓰일 수 있지만 세마포는 자칫 잘못 사용하면 발견하기 어려운 타이밍 오류를 야기할 수 있다.

이러한 타이밍 오류들은 특정 실행 순서로 진행되었을 때만 발생하고 이러한 순서가 항상 일어나는 것은 아니기 때문이다.

생산자-소비자 문제에 대한 해결책을 설명하면서 count를 사용할 때 이러한 오류 중 한가지가 발생하는 것을 보았다. 시간적인 오류는 매우 드물게 발생하며, 설사 그 오류가 발생하더라고 count 값이 단지 1만 차이 나기 떄문에 외관상으로는 합당한 것처럼 보였다.

Mutex락과 세마포를 도입한 이유는 바로 이러한 오류를 해결하기 위한 것이기 때문

하지만 Mutex락이든 세마포를 사용할 때에도 타이밍 오류는 여전히 발생할 수 있다.

모든 프로세스는 mutex라는 이진 세마포 변수를 공유하며 그 초기 값은 1이다. 각 프로세스는 임계구역에 진입하기 전에 wait(mutex)를 실행해야 하며 임계구역을 나올 떄 signal(mutex)를 실행해야 한다.

만일 이 순서가 제대로 지켜지지 않으면 두 프로세스가 동시에 임계구역 안에 있을 수 있다.

일어날 수 있는 여러 문제점

-   프로그램의 세마포에 대한 wait()와 signal() 연산의 순서가 뒤바꾸어 아래와 같은 코드일때

    ```
    signal(mutex);
      critical section
    wait(mutex);
    ```

    -   이 경우 여러 프로세스가 동시에 임계구역 으로 진입 상호 배제 요구 조건을 위반
    -   이러한 오류는 여러 프로세스가 동시에 자신의 임계구역안에서 실행되었을 때에만 발견될 수 있다.

-   프로그램이 signal(mutex)를 써야 할 곳에 잘못해서 wait(mutex)를 썻다고 가정

    ```
      wait(mutex);
        critical section
      wait(mutex);
    ```

    -   세마포를 사용할 수 없으므로 프로세스는 두 번째 wait() 호출에서 영구적으로 봉쇄된다.

-   프로세스가 wait(mutex)나 signal(wait) 또는 둘 다를 빠트렸다고 가정했을때 상호 배제 요구 조건을 위반하던지 프로세스는 영원히 봉쇄된다.

이러한 오류를 처리하기 위한 한 가지 전략은 간단한 동기화 도구를 통합하여 고급 언어 구조물을 제공하는것

## 6.7.1 모니터 사용법

`추상화된 데이터 형 (abstract data type, ADT)`은 데이터와 이 데이터를 조작하는 함수들의 집합을 하나의 단위로 묶어 보호한다.

이때 함수의 구현은 ADT의 특정한 구현과는 독립적이다. 모니터 형은 모니터 내부에서 상호 배제가 보장되는 프로그래머가 정의한 일련의 연산자 집합을 포함하는 ADT이다.

모니터 형은 또한 변수들의 선언을 포함하고 있는데 이 변수들의 값은 그 형에 해당하는 한 인스턴스의 상태를 정의한다.

모니터 형은 이 변수들을 조작할 수 있는 프로시저 또는 함수들의 본체도 같이 포함하고 있다.

모니터의 의사 코드 구문

```c
monitor monitor name
{
  /* shared variable declarations */
  function P1(...){
    ...
  }

  function P2(...){
    ...
  }
  ...
  function Pn(...){
    ...
  }

  initialization_code(...){
    ...
  }
}
```

모니터 형의 표현은 다른 프로세스들이 직접 사용할 수 없다. 따라서 모니터 내에 정의된 함수만이 오직 모니터 내에 지역적으로 선언된 변수들과 형식 매개변수들에만 접근할 수 있다. 마찬가지로 모니터 내의 지역변수는 오직 지역 함수만이 접근할 수 있다.

모니터 구조물은 모니터 안에 항상 하나의 프로세스만이 활성화되도록 보장해 준다. 그러므로 프로그래들은 이와 같은 동기화 제약 조건을 명시적으로 코딩해야 할 필요가 없다.

지금까지 정의한 모니터 구조물은 어떤 동기화 기법을 모델링하는 데에는 충분한 능력을 제공하지 않는다. 이를 위해 우리는 부가적인 동기화 기법을 정의해야 할 필요가 있다.

이 동기화 기법들은 condition이라는 구조물로 제공될 수 있다. 자신의 주문형 동기화 기법을 작성할 필요가 있는 프로그래머는 하나 이상의 condition 형의 변수를 정의할 수 있다.

```
condition x, y;
// 이 condition 형 변수에 호출될 수 있는 연산은 오직 wait()와 signal() 이다.
x.wait(); // 이 연산을 호출한 프로세스는 다른 프로세스가 signal()을 호출할 때까지 일시 중지 되어야 한다는 것을 의미

x.signal();
```

x.signal() 연산은 정확히 하나의 일시 중지 프로세스를 재개한다. 일시 중지된 프로세스가 없다면 아무런 효과가 없다.

즉 x의 상태는 마치 연산이 전혀 실행되지 않는 것과 같다. 이것을 세마포 signal() 연산과 대조하면 세마포의 signal() 연산은 항상 세마포의 상태에 영향을 준다.

x.signal() 연산이 프로세스 P에 의하여 호출될 떄 조건 x와 연관된 일시중지된 프로세스 Q가 있다고 가정했을때

만일 일시 중지된 스레드 Q가 실행을 재개하도록 허용된다면 signal()을 보낸 스레드 P는 반드시 대기해야 한다.

그렇지 않으면 P와 Q는 모니터안에서 동시에 활성화 된다. 그러나 두 프로세스는 개념적으로 그들의 실행을 계속할 수 있다는 사실에 유의해야 한다.

여기에는 두가지 가능성이 존재한다.

-   Signal and wait : P는 Q가 모니터를 떠날 때까지 기다리거나 또는 다른 조건을 기다린다.

-   Signal and continue : Q는 P가 모니터를 떠날 때까지 기다리거나 또는 다른 조건을 기다린다.

## 6.7.2 세마포를 이용한 모니터의 구현

각 모니터 마다 mutex라는 이진 세마포가 정의되고 그 초기 값은 1이다. 프로세스는 모니터로 들어가기 전에 wait(mutex)를 실행하고 모니터를 나온 후에 signal(mutex)을 실행 해야 한다.

모니터 구현히 signal-and-wait기법을 사용한다. Signaling 프로세스는 실행 재게되는 프로세스가 모니터를 떠나든지 아니면 wait()할 때까지 그 자신이 다시 기다려야 하므로 next라는 이진 세마포가 추가로 필요하게 되고 0으로 초기화 된다.

Signaling 프로세느느 자신을 중단시키기 위해 next를 사용할 수 있다. 정수형 변수 next_count도 next에서 일시 중지 되는 프로세스의 개수를 세기 위해 제공된다.

따라서 각 외부 프로시저 F는 이제 아래로 대체된다.

```c
wait(mutex);
  ...
  body of F
  ...
if( next_count > 0)
  signal(next);
else
  signal(mutex);
```

이처럼 하면 모니터 안에서 상호 배제는 보장된다.

이제 조건 변수를 세마포로 구현하는 방법 각 조건 x 마다 x_sem이라는 이진 세마포와 x_count라는 정수형 변수를 도입하고 둘 다 초기 값으로 0으로 준다.

```c
// x.wait() 연산
x_count++;
if(next_count > 0)
  signal(next);
else
  signal(mutex);
wait(x_sem)l
x_count--;

// x.signal()연산
if(x_count > 0){
  next_count++;
  signal(x_sem)l
  wait(next);
  next_count--;
}
```

## 6.7.3 모니터 내에서 프로세스 수행 재개

조건 변수 x에 여러 프로세스가 일시 중지 되어있고 어떤 프로세스가 x.signal()연산을 수행했다면 어떤 프로레스가 다시 수행 재개 되어야 하는가를 결정

가장 간단한 방법은 FCFS순 하지만 많은 경우 이러한 간단한 스케줄링 기법은 충분하지 않다.

이를 위해서 아래와 같은 형식의 `conditional-wait ` 구조물을 사용할 수 있다.

```c
x.wait(c)
```

여기서 c는 정수 수식이고 이 수식은 wait() 연산이 호출될 때 값이 계산된다.

c의 값은 `우선순위 번호`라고 불리며 일시 중지 되는 프로세스의 이름과 함께 저장된다. x.signal()이 수행되면 가장 작은 우선순위 번호를 가진 프로세스가 다음번에 수행 재개 된다.

```c
R.acquire(t);// 락획득
  access the resource;
R.release(); // 락 반납

// 하나의 자원을 할당해주는 모니터
monitor ResourceAllocator{
  boolean busy;
  condition x;

  void acquire(int time){
    if (busy)
      x.wait(time);
    busy = true;
  }

  void release(){
    busy = false;
    x.signal();
  }

  initialization_code(){
    busy = false;
  }
}
```

불행하게도 모니터의 개념은 위에서 예시한 순서가 그대로 지켜지는 것을 보장해주지 않는다. 특히 다음과 같은 문제점들이 발생할 수 있다.

-   프로세스가 자원에 대한 허락을 받지 않고 자원을 액세스할 경우
-   프로세스가 자원에 대한 허락을 받은 다음 그 자원을 방출하지 않을 경우
-   프로세스가 자원에 대한 허락을 받지 않았는데도 그 자원을 방출할 경우
-   프로세스가 자원에 대한 허락을 받은 다음 방출하지 않은 상태에서 또 그 자원을 요청할 경우

사실은 동일한 문제가 세마포를 사용할 때도 발생한다 이 문제는 모니터 구조물을 개발하려고 했던 동기와 비슷 한 유형의 문제

이 문제를 위한 한 가지 방법은 자원 액세스 연산 자체를 ResourceAllocator 모니터 내부에 두는것 하지만 이렇게 하면 스케줄링을 우리카 코딩한 스케줄링 방식이 아니고 모니터 자체의 스케줄러에 맡기는 꼴이 된다.

프로세스들이 올바른 순서를 지키도록 보장하기 위해서는 모니터와 모니터가 관리하는 자원을 사용하는 모든 프로그램을 검사하여야 한다.

이 시스템이 제대로 작동하는 지 알려면 두 가지 조건을 검사하여야 한다.

-   프로세스들이 모니터를 정확한 순서에 맞추어 호출하는지
-   비협조적인 프로세스가 액세스 제어 프로토콜을 사용하지 않아서 모니터가 정한 상호 배제 규칙 경로를 무시하여 공유 자원을 직접 액세스 하지 않는다는 것을 보장해야 한다.

위 두조건이 보장됐을 때에만 시간 종속적인 오류가 일어나지 않고, 원하는 스케줄링 지켜진다는 것을 보장할 수 있다.

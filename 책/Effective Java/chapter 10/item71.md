## 필요 없는 검사 예외 사용은 피하라.

---

검사 예외를 싫어하는 자바 프로그래머가 많지만 제대로 활용하면 API와프로그램의 질을 높일 수 있다.

결과를 코드로 반환하거나 비검사 예외를 던지는 것과 달리, 검사 예외는 발생한 문제를 프로그래머가 처리하여 안전성을 높이게끔 해준다.

검사예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없기 때문에 자바8부터는 부담이 커졌다.

검사 예외가 프로그래머에게 지우는 부담은 메서드가 단 하나의 검사 예외만 던질 때가 특히 크다. 이미 다른 검사 예외를 던지는 상황이라면 catch문하나 추가하는데 그치지만 단 하나 뿐이라면 그 예외때문에 try블록을 추가하고 스트림에서 사용할 수 없다.

검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다. 검사 예외를 던지는 대신 빈 옵셔널을 반환하면 된다. 단점은 예외 발생 정보를 넘길 수 없다. 예외를 사용하면 구체적인 타입과 메서드를 이용해 정보를 넘길 수 있기 때문

또 다른 방법으론 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꿀 수 있다. 이방식에서 첫번째 메서드는 예외가 던져질지 여부를 boolean값으로 반환한다.

```java
// 검사 예외를 던지는 메서드 -리팩터링 전
try{
  obj.acion(args);
}catch(TheCheckedException e){
  ...
}

//-------------리팩터링 후
if(obj.actionPermitted(args)){
  obj.action(args)
}else{
  ...//예외사항 대처
}
```

이 리팩터링을 모든 상황에 적용할 수는 없다. 그래도 적용한다면 더 쓰기 편한 API를 제공할 수 있다. 실패 시 스레드를 중단하길 원한다면 다음처럼 한 줄로 작성해도 무방하다.

```java
obj.action(args)
```

한줄짜리 호출 방식이 주로 쓰일 거로 판단되면 리팩터링하는 편이 바람직하다

actionPermiited는 상태검사 메서드에 해당하므로 item69에서 말한 단점도 그대로 적용되니 주의 즉 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인에 의해 상태가 변할 수 있다면 이 리펙터링은 적절하지 않다. actionPermitted와 action 호출 사이에 객체의 상태가 변할 수 있기 때문 또한 actionPermitted가 action 메서드 작업 일부를 중복 수행한다면 성능에서 손해이니, 역시 이 리팩터링이 적절하지 않을 수 있다.

---

필요한 곳에만 사용한다면 검사 예외는 프로그램의 안전성을 높여주지만, 남용하면 쓰기 고통스러운 API를 낳는다. API호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자. 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자. 옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자.

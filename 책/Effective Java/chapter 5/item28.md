## 배열보다는 리스트를 사용해라

---

배열과 제네릭 타입에는 중요한 차이가 두가지 있다.

-   배열은 공변이다. 어려워 보이는 단어지만 뜻은 간단하다. Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위타입이 된다.(공변, 즉 함께 변한다는 뜻)<br>
    반면 제네릭은 불공변이다. 즉 서로 다른 타입 타입1과 타입2가 있을 때, List<타입1>은 List<타입2>의 하위 타입도 아니고 상위 타입도 아니다.

```java
//런타임시에 실패함!
Object[] array = new Long[1];
array[0] = "타입이 달라 넣을 수 없다";//ArrayStoreException

//컴파일이 되지 않음! 당연히 이때 알아차리는 것이 더 좋다.
List<Object> ol = new ArrayList<Long>;
ol.add("타입이 달라 넣을 수 없다");
```

-   배열은 실체화 된다.(reify)된다. 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다.(그래서 위 코드에 런타임시에 오류가 발생) <br>
    반면 제네릭은 타입 정보가 런타임에는 소거된다. 원소 타입을 컴파일타임에만 검사하며 런타임에는 알수조차 없다는 뜻이다.

이상의 주요 차이로 배열과 제네릭은 잘 어우러지지 못한다. 예컨데 배열은 제네릭타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다.(`new List<E>[], new List<String>, new E[] -> 컴파일 오류`)
<br>
제네릭 배열 생성이 불가능한 이유는 타입 안전하지 않기 때문 이를 허용시 컴파일러가 자동 생성한 형변환 코드에서 런타임에 ClassCastException이 발생할 수 있음

```java
List<String>[] stringLists = new List<String>[1]; // (1)
List<Integer> intList = List.of(42);              // (2)
Object[] objects = stringLists;                   // (3)
objects[0] = intList;                             // (4)
String s = stringLists[0].get(0);                 // (5)

만약 (1)이 허용된다고 가정할때
(2)는 원소가 하나인 List<Integer>를 생성한다.
(3)은 (1)에서 생성한 List<String>의 배열을 Object 배열에 할당한다.배열은 공변이니 아무 문제가 없다.
(4) 번은 (2)에서 생성한 List<Integer>의 인스턴스를 Object 배열의 첫 원소로 저장한다.
제네릭은 런타임 시점에서 타입 정보를 소거하니 List<Integer>은 List가 되고
List<Integer>[]는 List[]가 된다.
따라서 (4)에서도 ArrayStoreException이 발생하지 않는다.
(5)에서는 List<String> 인스턴스만 담겠다고 선언한 stringLists 배열에는
List<Integer> 인스턴스가 저장돼 있다.
(5)는 이 배열의 처음 리스트에서 첫 원소를 꺼내려 하는데 컴파일러는 꺼낸 원소를 자동으로 String으로
형변환 하는데, 이 원소는 Integer이니 런타임에 ClassCastException 발생
```

이를 막기 위해서 제네릭 배열 생성을 막도록 (1)에서 컴파일 오류를 내야 한다.

---

배열과 제네릭에는 매우 다른 타입 규칙이 적용된다. 배열은 공변이고 실체화되는 반면, 제네릭은 불공변이고 타입 정보가 소거된다. 그 결과 배열은 런타임에는 타입 안전하지 않지만 컴파일 타임에는 그렇지 않다. 제네릭은 반대다. 그래서 둘은 섞어 쓰기란 쉽지 않다. 둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 가장 먼저 배열을 리스트로 대체하는 방법을 적용해보자.

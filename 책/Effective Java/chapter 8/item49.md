## 매개변수가 유효한지 검사하라

---

메서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다.

메서드 몸체가 실행되기 전에 매개변수를 확인한다면 잘못된 값이 넘어왔을때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있다.

매개변수 검사를 제대로 하지 못하면 몇 가지 문제가 생길 수 있다.

메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.(메서드가 수행되지만 결과가 이상한게 최악, 특히 객체가 이상하면)
(빠른실패가 좋다)
즉 매개변수 검사에 실패하면 실패 원자성(item76)을 어기는 결과를 낳을 수 있다.

public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화 해야 한다.(@throw 자바독 태그를 사용하면 된다 item74) 보통은 IllegalArumentException, IndexOutOfBoundsException, NullPorinterException중 하나(item72)

매개변수 제약을 문서화 한다면 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다.

```java
//예제

/**
 * (현재값 mod m)값을 반환 항상 음이 아닌 BigInterger을  반환한다는 점에서 remainder 메서드와 다르다
 *
 * @Param m 계수(양수여야 한다.)
 * @return 현개 값 mod m
 * @throws ArithmeticException m이 0보다 작거나 같으면 발생한다.
*/
public BigInteger mod(BigInteger m){
  if(m.signm() <= 0 ){
    throw new ArithmeticException("계수(m)는 양수여야 합니다." + m);
  }
  ...
}
```

m이 null일때 널포인트예외설명이 없는 이유는 이설명을 메서드란이 아닌 BigInteger클래스 수준에서 기술하였기 때문 클래스 수준 주석은 크 클래스의 모든 public 메서드에 적용되므로 메서드에 일일이 작석하는 것보다 클래스 단위에 작성하는 것이 효율적

자바7에 추가도니 java.util.Object.requireNonNull 메서드는 유연하고 사용하기도 편하니, 더이상 null검사를 수동으로 하지 않아도 된다. 원하는 예외용 메시지도 지정할 수 있다.

```java
this.strategy = Object.requireNonNull(strategy, "전략");

//반환값은 그냥 무시하고 필요한 곳 어디서든 순수한 null검사 목적으로 사용해도 된다.
```

(Objects.requireNonNull의 경우 결과값이 절대로 null이 되어서는 안된다는 것을 보장한다.

하지만 Optional의 경우 null을 반환하면 NPE가 발생할 가능성이 높은 경우 이를 안전하게 처리하기 위해 사용한다.

각자 사용법이 다르며 생성자나 메소드에서 절대 null이 되면 안되는 매개변수에는 Objects.requireNonNull을

프로그램 내에서 객체가 null일 가능성이 있을때 NPE를 막기 위해선 Optional을 사용하면 되겠다.)

자바9에서는 Object에 범위 검사 기능도 더해졌다. checkFromIndexSize, checkFromToIndex,checkIndex라는 메서드들인데, null 검사 메서드만큼 유연하지는 않다. 예외 메세지를 지정할 수 없고 리스트와 배열 전용으로 설계됐다. 닫힌범위(양 끝단값을 포함하는)는 다루지 못한다.

비공개 메서드라면 패키지 제작자인 여러분이 메서드가 호출되는 상황을 통제할 수 있다. 따라서 유효한 값만이 메서드에 넘겨지리라는 것을 보증할 수 있고 그렇게 해야 한다. public이 아닌 메서드라면 단언문(assert)을 사용해 매개변수 유효성을 검증할 수 있다.

```java
private static void sort(long a[], int offset, int length){
  assert a != null;
  assert offset >= 0 && offset <= a.length;
  assert length >=0 && length <= a.length - offset;

  ...


}
```

핵심은 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다는 것이다. 이 메서드가 포함된 패키지를 클라이언트가 어떤 식으로 지지고 복든 상관없다.

단언문은 몇 가지 면에서 일반적인 유효성 검사와 다르다.

-   실패하면 AssertionError를 던진다
-   런타임에 아무런 효과도, 성능 저하도 없다.(명령줄에서 -ea or --enableassertions 플래스 설정하면 영향을 준다)

메서드가 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경써서 검사해야한다. 나중에 디버깅 하기가 더 힘들다.

매개변수 유효셩을 검사해야 한다는 규칙에도 예외는 있다.

-   유효성 검사 비용이 지나치게 높거나 실용적이지 않을때
-   계산과정에서 암묵적으로 검사가 수행될때.

Collections.sort(List)처럼 객체 리스트를 정렬하는 메서드를 생각해보자. 리스트 안의 객체들은 모두 상호 비교될 수 있어야 하며, 정렬과정에서 비교가 이루어 진다. 만약 비교할 수 없는 타입의 객체가 있다면 ClassCastException을 던질것이다. 그러므로 미리 유효성 검사해봐야 별다른 실익이 없다.

계산과정에서 필요한 유효성 검사가 이뤄지지만 실패했을 때 잘못된 예외를 던지기도 한다. 발생한 예외와 api문서 기재 예외가 다를 수 있다는 말 이런경우 item73의 예외 번역(exception translate) 관용구를 사용하여 API 문서에 기재된 예외로 번역해주어야 한다.

매개변수에 제약을 두는게 좋다가 아니다 메서드는 최대한 범용적으로 설계해야 한다.

---

메서드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있을지 생각해야 한다. 그제약들을 문서화하고 메서드 코드 시작 부분에서 명시적으로 검사해야 한다. 이런 습관을 반드시 기르도록 하자. 그 노력은 유효성 검사가 실제 오류를 처음 걸러낼 때 충분히 보상받을 것이다.

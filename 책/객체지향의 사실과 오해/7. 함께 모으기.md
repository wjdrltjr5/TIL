# 함께 모으기

마틴 파울러는 객체지향 설계 안에 존재하는 세 가지 상호 연관된 관점에 관해 설명한다.

-   개념관점 : 설계는 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다.
-   명세관점 : 사용자의 영역인 도메인을 벗어나 개발자의 영역인 소프트웨어로 초점이 옮겨진다. 도메인이 아닌 객체들의 책임에 초점을 맞춘다.
-   구현관점 : 객체들이 챔임을 수행하는 데 필요한 동작하는 코드를 작성하는 것이다.

개념 관점, 명세 관점, 구현 관점은 동일한 클래스를 세가지의 다른 방향에서 바라노는 것이지 순서대로가 아님.

클래스가 은유하는 개념은 도메인관점을 반영한다. 클래스의 공용인터페이스는 명세관점을 반영한다. 클래스의 속성과 메서드는 구현관점을 반영한다.

## 커피 전문점 도메인

커피 주문 : 커피 전문점에서 커피를 주문하는 과정을 협력관계로 구현

## 예제

#### 커피 제조하기

커피 전문점에서는 아메리카노, 카푸치노, 카라멜 마끼아또, 에스프레소 4가지 커피를 판매중이다.
|Menu||
|---|---|
|아메리카노|1500|
|카푸치노|2000|
|카라멜 마끼아또|2500|
|에스프레소|2500|

-   손님은 메뉴판을 보고 바리스타에게 원하는 커피를 주문한다.

    -   손님 객체는 메뉴판 객체 안에 적힌 메뉴 항목 객체들 중에서 자신이 원하는 메뉴 항목 객체 하나를 선택해 바리스타 객체에게 전달한다.

    -   바리스타객체는 주문을 받은 메뉴에 따라 적절한 커피를 제조한다.

    -   제조된 커피객체를 반환한다.(커피 역시 구별되는 자신만의 경계를 가지므르 객체로 볼 수 있다.)

#### 관계

-   손님은 메뉴판을 알아야 하므로 관계가 존재한다. (연관관계)
-   손님은 바리스타에게 주문을 해야하므로 관계가 존재한다. (연관관계)
-   바리스타는 커피를 제조하는 사람이므로 커피와 관계가 존재한다. (연관관계)

-   메뉴 항목은 메뉴판에 포함되어있다. (포함관계)

도메인 모델에서는 사실 관계가 존재한다는 사실을 이해하는 것만으로 충분하다.

## 설계하고 구현하기

### 커피를 주문하기 위한 협력 찾기.

객체지향 설계의 첫 번째 목표는 휼룡한 객체를 설계하는 것이 아니라 휼룡한 협력을 설계하는 것이라는 점을 잊지 말자.

협력을 설계할때는 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택해야 한다.

-   커피를 주문하는 것 (협력)

    -   커피를 주문하라 : 메시지
    -   손님 객체가 수신
    -   손님객체 메뉴를 모름 메뉴판객체에게 메뉴 항목을 찾아라 : 메시지
    -   메뉴판 객체가 수신 메뉴 항목 반환
    -   손님객체 바리스타객체에 커피 제조 요청: 메시지
    -   바리스타 객체 커피제조
    -   커피 객체 생성

-   인터페이스
    -   손님 : 커피 주문
    -   메뉴판 : 메뉴항목찾아라
    -   바리스타 : 커피제조
    -   커피 : 생성

```java
class Customer{
  public void order(String menuName);
}

class MenuItem{}

class Menu{
  public MenuItem choose(String name);
}

class Barista{
  public Coffee makeCoffee(MenuItem menuItem);
}

class Coffee{
  public Coffee(MenuItem menuItem){}
}
```

### 구현하기

Customer 는 Menu에게 menuName에 해당하는 MenuItem을 찾아달라고 요청해야 한다. 그리고 MenuItem을 받아 이를 Barista에게 전달하여 커피를 제조하도록 요청해야 한다

객체에게 메세지를 전송하기 위해서는 자신과 협력하는 객체에대한 참조가 있어야 한다.

```java
//여기서는 그냥 인자로 받음
class Customer{
  public void order(String menuName, Menu menu, Barista barista){
      MenuItem menuItem = menu.choose(menuName);
      Coffee coffee = barista.makeCoffee(menuItem);
  }
}
```

menu는 menuName에 해당하는 MenuItem을 찾아야 하는 책임이 있다.

```java
public Menu{
  private List<MenuItem> items;

  public Menu(List<MenuItem> items){
    this.items = items;
  }

  public MenuItem choose(String name){
    for(MenuItem each : items){
      if(each.getName().equals(name)){
        return each;
      }
    }
    return null;
  }
}
```

바리스타는 MenuItem을 이용해서 커피를 제조한다.

```java
class Barista{
  public Coffee makeCoffee(MenuItem menuItem){
    Coffee coffee = new Coffee(menuItem);
    return coffee;
  }
}

class Coffee{
  private String name;
  private int price;

  public Coffee(MenuItem menuItem){
    this.name = menuItem.getName();
    this.price = menuItem.cost();
  }
}

public class MenuItem{
  private String name;
  private String cost;

  public MenuItem(String name, int price){
    this.name = name;
    this.price = price;
  }

  public int cost(){
    return price;
  }
  public String getName(){
    return name;
  }
}
```

## 코드와 세가지 관점

개념관점, 명세관점, 구현관점

개념 관점에서 코드를 바라보면 Customer, Menu, MenuItem, Barista, Coffee 클래스가 보인다.

이 클래스들을 자세히 살펴보면 커피 전문점 도메인을 구성하는 중요한 개념과 관계를 반영하는 사실을 쉽게 알 수 있다. 소프트웨어 클래스가 도메인 개념의 특성을 최대한 수용하면 변경을 관리하기 쉽고 유지보수성을 향상시킬 수 있다.

소프트웨어 클래스와 도메인 클래스 사이의 간격이 좁으면 좁을수록 기능을 변경하기 위해 뒤적거려야 하는 코드의 양도 점점 줄어든다.

명세 관점은 클래스의 인터페이스를 바라본다. 클래스의 public 메서드는 다른 클래스가 협력할 수 있는 공용 인터페이스를 드러낸다.

최대한 변화에 안정적인 인터페이스를 만들기 위해서는 인터페이스를 통해 구현과 관련된 세부사항이 드러나지 않게 해야 한다.

구현 관점은 클래스의 내부 구현을 바라본다. 메서드의 구현과 속성의 변경은 원칙적으로 외부의 객체에게 영향을 미쳐서는 안된다.
캡슐화를 잘하자.

개념 관점, 명세 관점, 구현 관점은 동일한 코드를 바라보는 서로 다른 관점이다.

휼룡한 객체지향 프로그래머는 하나의 클래스 안에 세 가지 관점을 모두 포함하면서도 각 관점에 대응되는 요소를 명확하고 깔끔하게 드러낼 수 있다.

### 도메인 개념을 참조하는 이유

어떤 메시지가 있을 때 그 메시지를 수신할 객체를 어떻게 선택하는가?

1.  도메인 개념 중에서 가장 적절한 것을 선택하는 것이다. 도메인 개념 안에서 적절한 객체를 선택하는 것은 도메인에 대한 지식을 기반으로 코드의 구조와 의미를 쉽게 유추할 수 있게 한다.

도메인 개념을 따르면 변화에 쉽게 대응할 수 있다.

### 인터페이스와 개념을 분리하라

인터페이스가 구현 세부사항을 노출하기 시작하면 아주 작은 변동에도 전체 협력이 요동치는 위약한 설계를 얻을 수 밖에 없다.

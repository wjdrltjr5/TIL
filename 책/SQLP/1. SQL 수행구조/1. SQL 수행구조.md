# SQL 수행 구조

## 1

DBMS마다 데이터베이스에 대한 정의가 조금씩 다른데 오라클은 물리적은 OS파일의 집합을 데이터베이스라고 부른다.

그리고 SGA 공유 메모리 영역과 이를 액세스하는 프로세스 집합을 합쳐서 인스턴스라고 부른다.

기본적으로 하나의 인스턴스가 하나의 데이터 베이스만 액세스하지만, RAC(Real Application Cluster)환경에서는 여러 인스턴스가 하나의 데이터베이스를 액세스할 수 있다.

하나의 인스턴스가 여러 데이터데이터베이스를 액세스할 수는 없다.

## 2 백그라운드 프로세스

-   System Monitor(SMON) : 장애가 발생한 시스템을 재기동할 때 인스턴스 복구를 수행하고, 임시 세그먼트와 익스텐트를 모니터링한다.

-   Process Monitor(PMON) : 이상이 생긴 프로세스가 사용하던 리소스를 복구한다.

-   Database Writers(DWWn) : 버퍼캐시에 있는 Dirty 버퍼를 데이터 파일에 기록한다.

-   Log Writer(LGWR) : 로그 버퍼 엔트리를 Redo 로그파일에 기록한다.

-   Archiver(ARCn) : 꽉 찬 Redo 로그가 덮어 쓰여지기 전에 Acrchive 로그 디렉토리로 백업한다.

-   Checkpoint(CKPT) : Checkpoing 프로세스는 이전에 Checkpoint가 있어 났던 마지막 시점 이후의 데이터 베이스 변경사항을 데이터파일에 기록하도록 트리거링하고 기록이 완료되면 현재 어디까지 기록했는지를 컨트롤 파일과 데이터파일 헤더에 저장한다.

-   Recovercer(RECO) : 분산 트랜잭션 과정에 발생한 문제를 해결한다.

로그 버퍼에 로그를 기록하는 것은 백그라운드 프로세스가 아니라 DML을 수행하는 각 사용자 프로세스다.

사용자 프로세스가 로그 버퍼에 로그를 기록하고 데이터 블록을 변경한 이후 Log Writer가 주기적으로 로그 버퍼 엔트리를 Redo 로그 파일에 기록한다.

## 3 데이터 저장 구조

-   블록(페이지) : 대부분 DBMS는 블록단위로 I/O한다 이는 하나의 레코드를 읽더라도 블록을 통째로 읽게 됨을 뜻한다.

-   익스텐트 : 공간을 확장하는 단위, 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지만 추가적인 공간을 할당받는데 이때 정해진 인스텐트 크기의 연속된 블록을 할당받는다.

-   세그먼트 : 데이터 저장공간을 사용하는 오브젝트(테이블, 인덱스, 파티션, 클러스터, LOB등)를 저장공간을 사용하지 않는 오브젝트(뷰, 시너님, 시퀀스, 함수, 프로시저, 트리거 등)와 구분해서 세그먼트라고 부른다.

    -   저장공간을 사용한다는 것은 테이블 스페이스로부터 한 개 이상의 익스텐트를 할당받음을 뜻한다.

    -   세그먼트는 익스텐트의 집합이라고 말할 수 있다. 익스텐트 내 블록이 논리적으로 서로 인접한 반면 익스텐트끼리 서로 인접하지는 않는다.

-   테이블스페이스 : 세그먼트를 담는 컨테이너로서, 여러 데이터파일로 구성된다. 각 세그먼트는 정확히 한 테이블스페이스에만 속하지만, 한 테이블스페이스에는 여러 세그먼트가 존재할 수 있다.

    -   한 세그먼트는 여러 데이터파일에 걸쳐 저장된다. 한 테이블 스페이스가 여러 데이터파일로 구성되기 때문이다.

## 4 데이터 저장 구조

여러 오브젝트 유형 중 저장 공간을 필요로 하는 오브젝트를 세그먼트라고 한다. 세그먼트는 익스텐트의 집합이다. 한 세그먼트는 정확히 한 테이블 스페이스에 속하지만 여러 데이터파일에 걸쳐 저장된다.

한 테이블 스페이스가 여러 데이터파일로 구성되기 떄문이다. 한 테이블 스페이스는 당연히 여러 세그먼트가 존재한다.

익스텐트는 세그먼트가 공간을 확장하는 단위이자, 연속된 블록의 집합이다. 한 익스텐트에 속한 블록은 서로 인접해 있지만, 익스텐트끼리 서로 인접하지는 않는다. 어떤 세그먼트에 할당된 두 익스텐트가 데이터파일 내에서 서로 멀리 떨어져 있을 수 있다는 뜻이다.

-   한 테이블 스페이스에는 여러 세그먼트가 존재한다 1:M
-   인스텐트는 블록의 집합이므로 익스텐트와 블록은 1:M
-   세그먼트는 익스텐트의 집합이르모 세그먼트와 익스텐트는 1:M

뷰는 쿼리분장을 담고 있는 가상의 테이블이므로 물리적인 저장공간을 필요로 하지 않는다

뷰를 조회할 때 데이터 딕셔너리에 미리 저장해 둔 쿼리 문장을 실행함으로써 결과 집합을 반환한다.

## 5

Undo를 사용하는 목적은 다음과 같다.

-   Transaction Rollback
-   Transaction Recovery
-   Read Consistency

## 6 Redo 로그

Redo 로그는 아래 3가지 목적을 위해 사용된다.

-   Database Recovery : 물리적으로 결함이 생기는등 Media Fail시 데이터베이스를 복구하기 위해 사용 이때 Archive Redo 로그를 이용하게 된다.

-   Cache Recovery(Instance Recovery) : 모든 데이터 베이스 시스템이 I/O성능을위해 버퍼 캐시를 사용하지만 이는 휘발성이다. 비정상 종료시 데이터 유실에 대비
-   Fast Commit : 변경된 메모리 버퍼 블록을 데이터 파일에 기록하는 작업은 Random 액세스 방식이르모 느리다. 반면 로그는 append 방식으로 기록하므로 훨씬 빠르다. 우선 append 방식으로 로그를 기록하고 추후에 동기화한다.

동시에 많은 트랜잭셔이 몰려 로그 스위치가 너무 자주 발생하면 자칫 백업을 완료하지 못한 Online Redo 로그로 스위칭이 일어나면서 DB Hang이 발생할 수 있다. 그런 현상이 발생하지 않도록 적절한 크기와 개수의 Redo 파일을 할당해야 한다

## 7 Redo 메커니즘

-   Log Force at commit : DML을 수행하는 사용자 프로세스가 로그 버퍼에 로그를 기록하고 데이터 블록을 변경한다. 이후 LGWR가 주기적으로 로그 버퍼 엔트리를 Redo 로그 파일에 기록하는데 메모리상의 로그 버퍼는 언제든 유실 가능성이 있다. 따라서 트랜잭션 영속성을 보장하려면 최소한 커밋 시점에는 메모리가 아닌 데이터파이엘 로그를 기록해야 한다.

-   Fast Commit

-   Write Ahead Logging : 버퍼 캐시 블록을 갱신하기 전에 먼저 Redo 엔트리를 로그 버퍼에 기록해야 하며, DBWR가 버퍼캐시의 Dirty 블록들을 데이터 파일에 기록하기 전에 먼저 LGWR가 해당 Redo 엔트리를 모두 Redo 로그 파일에 기록했음이 보장되어야 한다.

오라클은 데이터를 읽는 도중에 다른 트랜잭션에 의해 변경되었거나 변경이 진행 중인 블록을 만나면 과거 시점으로 되돌린 CR Copy 블록을 만들어서 읽는다.

이때 Undo 정보를 이용하는데 필요한 Undo블록이 다른 트랜잭션에 의해 재사용된 상태면 CR Copy를 생성할 수 없다. 이때 Snapshot Too Old에러가 발생

## 8

Sort Area는 SGA가 아니라 PGA에 할당된다.

## 9

SQL은 라이브러리 캐시에 캐싱된다.

## 10 버퍼 블록의 상태

모든 버퍼캐시 블록은 아래 세 가지중 하나의 상태에 놓인다.

-   Free 버퍼 : 인스턴스 기동 후 아직 데이터가 읽히지 않아 비어있는 상태이거나 데이터가 담겼지만 데이터 파일과 서로 동기화돼 있는 상태여서 언제든 덮어 써도 무방한 블록을 말한다. 새로운 데이터 블록을 로딩하려면 Free 버퍼를 확보해야 한다.

-   Dirty 버퍼 : 버퍼캐시에 적재된 후 변경이 발생했지만 아직 데이터 파일에 기록하지 않아 동기화가 빌표한 버퍼 블록을 말한다.

-   Pinned 버퍼 : 읽기 또는 쓰기 작업을 위해 현재 액세스되고 있는 버퍼 블록을 말한다.

## 11 SQL 언어의 특징

SQL Structured Query Language의 줄인말이다. 구조적 질의 언어

절차적 프로그래밍 기능을 구현할 수 있는 확장언어(PL/SQL)도 지원하지만 기본적으로 구조적이고 집합적이고 선언적인 질의 언어다.

## 12 SQL 처리과정

-   SQL 파싱 : 사용로부터 SQL을 전달받으면 가장 먼저 SQL 파서가 파싱을 진행한다. SQL 파싱을 요약하면 다음과 같다.

    -   파싱 트리 생성 : SQL문을 이루는 개별 구성요소를 분석해서 파싱 트리 생성
    -   Syntax 체크 : 문법적 오류가 없는지 확인
    -   Semantic 체크 : 의미상 오류가 없는지 확인

-   SQL 최적화 : 옵티마이저의 역할

-   로우 소수 생성 : 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅 하는 단계

## 13 SQL 최적화

SQL 옵티마이저는 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 선택해 주는 DBMS 핵심 엔진이다.

최적화 단계를 요약하면 아래와 같다.

-   사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 도출한다.

-   데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용을 산정한다.

-   최저 비용을 나타내느 실행계획을 선택한다.

## 14 비용기반 옵티마이저

비용기반 옵티마이저는 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아내서 각각의 예상비용을 산정한 후 최저 비용을 나타내느 하나를 선택한다.

## 15 옵티마이저 힌트

옵티마이저 힌트는 명령어이므로 특별한 이유가 없는 한 그대로 실행된다. 힌트가 무시되는 경우는 아래와 같다.

-   문법적으로 맞지 않게 힌트를 기술
-   잘못된 참조 사용 : 없는 테이블이나 별칭을 사용 한경우 등.
-   논리적으로 불가능한 액세스 경로 (=없는 Hash)

-   의미적으로 맞지 않게 힌트를 기술 (unnest와 push_subq를 함께기술)
-   옵티마이저에 의해 내부적으로 쿼리가 변환된 경우
-   버그

## 16

index 힌트에 인덱스명을 지정하지 않으면 옵티마이저가 알아서 인덱스를 결정한다.

## 17 옵티마이저 힌트

옵티마이저 힌트를 사용할 때 유의점은 아래와 같다.

-   힌트 안에 인자를 나열할 땐 , 를 사용할 수 있지만 힌트와 힌트 사이에 사용면 안된다.
-   테이블을 지정할 때 스키마명까지 명시하면 안된다.
-   FROM절 테이블 명에 alias를 지정했다면, 힌트에도 반드시 사용해야 한다.

## 18 [자주사용하는 힌트 목록](../../친절한%20SQL%20튜닝/1.%20SQL%20처리%20과정과%20IO.md)

## 19 블록 단위 I/O

오라클을 포함한 모든 DBMS에서 I/O블록 단위로 이루어진다.

블록단위 I/O는 버퍼 캐시와 데이터파일 I/O 모두에 적용된다.

-   데이터 파일에서 DB 버퍼캐시로 블록을 적재할때
-   데이터 파일에서 블록을 직접 읽고 쓸때
-   버퍼캐시에서 블록을 읽고 쓸 떄
-   버퍼캐시에서 변경된 블록을 데이터파일에 쓸 떄

데이터 딕셔너리에 저장된 테이블 및 컬럼 정보를 딕셔너리 캐시에 적재할 때는 로우 단위로 I/O한다. 딕셔너리 캐시를 로우 캐시라고도 부르는 이유

## 20

## 21 버퍼캐시 탐색 메커니즘

Direct Path I/O를 제외한 모든 블록 I/O는 메모리 버퍼 캐시를 경유한다. 구체적으로 아래 오퍼레이션은 모두 버퍼 캐시 탐색 과정을 거친다.

-   인덱스 루트 블록을 읽을때
-   인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
-   인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을때
-   인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
-   테이블 블록을 Full Scan할때

## 22 버퍼 캐시 히트율

```
BCHR = (캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수 ) * 100
     = ((논리적 I/O - 물리적 I/O) / 논리적 I/O * 100)
     = (1 - (물리적 I/O) / (논리적 I/O) * 100 )
```

논리적 I/O는 SQL 수행 과정에 읽은 총 블록수를 말하며, query항목 + current을 더해서 구한다.

디스크에서 찾고 버퍼캐시에 적재후 읽으니 논리적 I/O 횟수에는 물리적 I/O 횟수가 포함되어 있다.

## 23 LRU알고리즘

LRU는 가장 오래 전에 마지막으로 사용했던 데이터 블록을 버퍼 캐시에서 밀어내는 알고리즘이다.

반대로 MRU는 최근에 사용한 블록을 버퍼 캐시에서 밀어내는 알고리즘이다.

## 24 시퀀셜 액세스 vs 랜덤 액세스

시퀀셜 액세스는 논리적 또는 물리적으로 연결된 순서에 따라 차례로 블록을 읽어나가는 방식이다

인덱스와 테이블을 스캔할 때 이 방식으로 사용한다.

랜덤 액세스는 논리적 물리적 순서를 따르지 않고 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식이다.

인덱스를 스캔하면서 얻은 rowid로 테이블 블록을 액세스할때 이방식을 사용한다.

## 25 Single Block I/O

인덱스를 이용할때는 기본적으로 인덱스와 테이블 블록 모두 Single Block I/O를 사용한다.

구체적으로 아래 목록이 Single Block I/O 대상 오퍼레이션이다 인덱스는 소량 데이터를 읽을 때 주로 사용하므로 이 방식이 효율적이다.

-   인덱스 루트 블록을 읽을 때
-   인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
-   인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
-   인덱스 리브 플록에서 얻은 주소 정보로 테이블 블록을 읽을 때

## 26 Multi Block I/O

Multi Block I/O는 캐시에서 찾지 못한 특정 블록을 읽으려고 I/O Call 할때 디스크상에 그 블록과 인접한 블록을 한꺼번에 읽어 캐시에 미리 적재하는 기능이다.

Multi Block I/O 단위는 db_file_multiblock_read_count 파라미터에 의해 결정된다.

인접한 블록이란 같은 익스텐트에 속한 블록을 말하며 그 경게를 뛰어넘을 수 없다.

db file sequential read 대기 이벤트는 Single Block I/O할때 나타난다.

db file scattered read는 Multi Block I/O 를 할때 나타난다.

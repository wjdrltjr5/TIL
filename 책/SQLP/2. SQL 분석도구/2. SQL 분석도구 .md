# SQL 분석도구

## 1

실행계획을 확인하는 방법은 여러 가지가 있다. 오라클이 기본적으로 제공한느 쿼리 툴 SQL\*Plus에서 아래 명령을 수행하면 실행계획이 PLAN_TABLE에 저장된다.

```
explain plan for
select * from emp where ename = :ename and deptno = :deptno;
```

PLAN_TABLE에 저장된 정보를 읽어 분석하기 쉬운 형태로 포맷팅하는 방법에 여러가지가 있지만 가장 쉬운 방법은 아래와 같이 dbms_xplan.display 함수를 사용하는 것이다.

select \* from table(dbms_xplan.display(null, null, 'typical'));

## 2

SQL Server에서 예상 실행계획을 출력하는 방법은 간단하다 'set showplan_text on' 명령을 실행한 후에 SQL을 실행하면 된다.

## 3

오라클 예상 실행계획에서 기본적으로 (dbms_xplan.display 함수 세 번째 인자에 'typical' 입력) 확인할 수 있는 정보는 Plan Hash Value, 오브젝트 액세 방식(Operation), 오브젝트명, 예상 카디널리티(=Rows), 예상 데이터 크기(Bytes), 예상 Cost, 예상 CPU Time, 조건절 정보(Predicate Information) 등이다.

dbms_xplan.display 함수 세 번째 인자에 alias, outline, advanced 등을 지정하면, Query Block 및 Object Alias 정보, Outline 정보, Column Projection 정보 등을 추가로 확인할 수 있다.

## 4

오라클 AuthTrace 에서 확인할 수 있는 정보는 아래와 같다.

```
set autotrace traceonly;
select empno, ename, deptno, from where ename = 'SCOTT'
```

통계정보 확인 가능

-   recursive calls
-   db block gets
-   consistent gets
-   physical reads -> 실제 디스크에서 읽은 블록 수
-   redo size -> 실제 기록한 Redo 크기
-   bytes sent via SQL\*Net to Client
-   Bytes received via SQL\*Net from client
-   SQL\*Net roundtrips to/from client
-   sorts (memory)
-   sorts (disk)
-   row processed

## 5

AutoTrace에서 사용할 수 있는 옵션은 아래와 같다.

-   set autotrace on : SQL을 실행하고 결과집합과 함께 예상 실행계획 및 실행통계를 출력한다.

-   set autotrace on explain : SQL을 실행하고 결과집합과 함께 예상 실행계획을 출력한다.

-   set autotrace on statistics : SQL을 실행하고 함께 실행통계를 출력ㄱ한다.

-   set autotrace traceonly : SQL을 실행하지만 결과를 출력하지 않고 예상 실행계획과 실행통계만 출력한다.

-   set autotrace traceonly explain : SQL을 실제로 실행하지 않고 예상 실행계획만 출력한다.

-   set autotrace traceonly statistics : SQL을 실행하지만 결과는 출력하지 않고 실행 통게만 출력한다.

## 6

statistics_level 파라미터를 all로 설정하면, SQL 트레이스가 메모리에 수집된다.

gather_plan_statistics는 파라미터가 아니라 옵티마이저 힌트다.


## 9

AutoTrace의 recursive calls 는 하드파싱 과정에 딕셔너리를 조회하거나 DB 저장형 함수에 내장된 SQL을 수행할 때 발생한 Call 횟수를 표시한다.

## 10

SQL에 gather_plan_statistics 힌트를 지정하면 SQL 트레이스 정보를 서버 파일이 아닌 SGA메모리에 기록한다.

SGA 메모리에 저장된 트레이스 정보를 V$SQL_PLAN_STATISTICS_ALL뷰에서 직접 조회할 수도 있지만.

dbms_xplan.display_cursor 함수를 이용하면 분석하기 쉬운 형태로 포맷팅 해준다.

## 11

SGA 메모리에 기록한 트레이스 정보를 읽어 분석하기 쉬운 형태로 포매팅 하고자 할 때 dbms_xplan.display_cursor함수를 사용하며,

첫 번째와 두 번째 인자에는 SQL 커서의 ID와 CHILD_NUMBER를 입력해야 한다.

SQL 커서 ID와 CHILD_NUMBER 정보는 SQL 문장의 앞쪽 일부 문자열로 V$SQL뷰의 SQL_TEXT 컬럼을 조회해서 얻은 SQL_ID와 CHILD_NUMBER 컬럼 값에서 얻는다

참고로 첫 번째와 두 번째 인자에 null, null을 입력하면 바로 직전에 수행한 SQL 커서 ID와 CHILD_NUMBER를 내부에서 자동 선택해 준다.

## 12

monitor 힌트는 실시간 SQL 모니터링을 위해 사용하는 힌트다. 실시간 SQL 모니터링을 위한 리포트는 dbms_sqltune.report_sql_monitor 함수로 출력한다.

## 13

DBMS_XPLAN.DISPLAY_CURSOR 함수를 통해 추출한 SQL 트레이스 정보는 아래와 같다.

-   Starts : 각 오퍼레이션 단계별 실행 횟수
-   E-Rows : 옵티마이저가 예상한 Rows
-   A-Rows : 각 오퍼레이션 단계에서 읽거나 갱신한 로우 수
-   A-Times : 각 오퍼레이션 단계별 소요시간
-   Buffers : 캐시에서 읽은 버퍼 블록 수
-   Reads : 디스크에서 읽은 블록 수

DBMS_XPLAN.DISPLAY_CURSOR 함수로 추출한 SQL 트레이스 항목과 전통적인 파일 방식의 SQL 트레이스 항목을 서로 매칭해 보면, 아래 표와 같다.

| DBMS_XPLAN | SQL트레이스         | 설명                           |
| ---------- | ------------------- | ------------------------------ |
| A-Rows     | rows                | 각 단계에서 읽거나 갱신한 건수 |
| A-Time     | time                | 각 단계별 소요시간             |
| Buffers    | cr(=query), current | 캐시에서 읽은 버퍼 블록 수     |
| Reads      | pr                  | 디스크로부터 읽은 블록 수      |

## 14

SQL 트레이스를 확인하고자 설정하는 옵션은 아래와 같다.

-   set statistics profile on : 각 쿼리가 일반 결과집합을 반환하고 그 뒤에는 쿼리 실행 프로필을 보여 주는 추가 결과집합을 반환한다. 출력에는 다양한 연산자에서 처리한 행수 및 연산자의 실행 횟수에 대한 정보도 포함된다.

-   set statistics io on : Transact-SQL문이 실행되고 나서 해당 문에서 만들어진 디스크 동작 양에 대한 정보를 표시한다.

-   set statistics time on : 각 Transact-SQL문을 구문 분석, 컴파일 및 실행하는 데 사용한 시간을 밀리초 단위로 표시한다.

## 15

SQL Server 트레이스에서 확인할 수 있는 정보는 아래와 같다.

SQL Server 구문 분석 및 컴파일 시간 : CPU 시간 = 0ms, 경과시간 = 1ms. (2155)

테이블 Order Details 검색 수 1, 논리적 읽기 수 6, 물리적 읽기 수 0, 미리읽기

테이블 Order, 검색 수 1, 논리적 읽기 수 22, 물리적 읽기 수 0, 미리 읽기 수 0,

## 16

프로세스가 공유 메모리의 버퍼캐시, 라이브러리 캐시에서 정보를 읽으려면 래치를 반드시 획득해야 한다, 래치를 획득하는 과정에 경합이 발생하면 대기 이벤트가 나타나지만, 경합없이 바로 읽으면 대기 이벤트가 나타나지 않는다.

대기 이벤트는 프로세스가 CPU를 OS에 반환하고 수면 상태로 진입하는 원인을 기록하기 위해 개발되었다.

프로세스가 CPU를 OS에 반환하고 수면 상태로 진입하는 원인은 아래와 같다.

-   프로세스가 필요로 하는 특정 리소스가 다른 프로세스에 의해 사용중일 때
-   다른 프로세스에게 작업을 요청하고 해당 작업이 완료되기를 기다릴 때
-   프로세스가 할 일이 없을 때

대기 이벤트가 나타나는 대표적인 예는 SGA 공유 메모리에서 특정 자원을 액세스하려고 래치를 획득하는 과정에 다른 프로세스와 경합이 발생하거나

디스크로부터 블록 I/O를 요청하거나 클라이언트로부터 다음 작업 요청이 오기를 기다리는 경우

## 17

-   Shared Pool 에서 특정 오브젝트 정보 또는 SQL 커설을 위한 Free Chunk를 할당받으려 할 때 shared pool 래치를 할당 받아야 한다.

    -   latch : shared pool 대기 이벤트는 shared pool래치를 할당받는 과정에서 발생하는 경합과 관련 있으며, 하드파싱을 동시에 심하게 일으킬 때 주로 나타난다.

-   library cache lock과 library cache pin 대기 이벤트는 주로 SQL 수행 도중 DDL을 수행할 때 나타난다.

-   free buffer wait대기 이벤트는 서버 프로세스가 버퍼 캐시에서 Free Buffer를 찾지 못해 DBWR에게 공간을 확보해 달라고 신호를 보낸 후 대기할 때 나타난다.

-   log file sync 대기 이벤트는 커밋 명령을 전송받은 서버 프로세스가 LGWR에게 로그 버퍼를 로그파일에 기록해 달라고 신호는 보낸 후 대기할 때 나타난다.

## 18

대기 이벤트를 기반으로 세션 또는 시스템 전체에 발생하는 병목 현상과 그 원인을 찾아 문제를 해결하는 방법 과정을 대기 이벤트 기반 또는 응답시간 분석 성능관리 방법론이라고 한다.

Ratio 기반 분석 방법론의 한계점을 극복하기 위해 대기 이벤트 기반 분석 방법론이 대두되었다.

OWI(Oracle Wait Interface)는 Response Time Analysis 방법론을 지원하려고 오라클이 제공하는 기능과 인터페이스를 통칭한다.

AWR(Automatic Workload Repository)는 성능 관련 데이터를 주기적으로 수집합으로써 Ratio 기반 분석과 대기 이벤트 기반 분석을 모두 지원하는 오라클 성능 관리 표준 도구다.

## 19

Response Time Analysis 성능관리 방법론은 세션 또는 시스템 전체에 발생하는 병목현상과 그 원인을 찾아 문제를 해결하는 방법과 과정을 다루며, 데이터베이스 서버의 응답시간을 아래와 같이 정의한다.

```
Response Time = Service Time + Wait Time
              = CPU Time + Queue Time

```

서비스 시간은 프로세스가 정상적으로 동작하며 일을 수행한 시간

대기 시간은 CPU를 OS에 반환하고 수면 상태에서 대기한 시간을 의미한다.

## 20

오라클은 전통적으로 사용하던 Ratio기반 성능 분석 방법론에 응답시간 분석 방법론을 더해 Statspack을 개발하였고, 이를 확장 및 업그레이드 하면서 만든것이 AWR이다.

AWR 보고서를 활용해 성능 이슈를 해결하려면 peak 시간대 또는 장애 발생 시점을 전후해 가능한 한 짧은 스냅샷 구간을 선택해야 한다.

특정 시점에 시스템에 큰 부하가 발생했어도 하루 또는 일주일 보고서로 출력해서 보면 초당 부하 발생량과 대기 시간에 전혀 문제가 없는 것처럼 평균 수치가 나타나기 때문이다.

사용자 인터뷰를 통해 성능 저하 현상을 경험했던 시간대를 파악하거나 sar, topas, vmstat, osstat등 OS 모니터링 도구를 이용해 CPU, 메모리, I/O 사용량 정보를 수집하고 이를 통해 peak 시간대를 파악할 수 있다.

과거에 사용하던 Statspack은 SQL로 딕셔너리를 조회해서 성능 정보를 수집했기 때문에 그 자체가 시스템에 부하를 주는 요소로 작용했고

따라서 스냅샷 주기를 짧게 설정하기가 곤란했다.

반면 AWR은 뷰를 조회하지 않곻 DMA(Direct Memory Access)방식으로 SGA 공유 메모리를 직접 액세스해서 성능 정보를 수집하기 때문에 좀 더 빠르게 정보를 수집할 수 있다.

부하가 적기 때문에 Statspack보다 더 자주 더 많은 정보를 수집할 수 있게 되었다.

AWR 보고서에 출력되는 항목들은 dba*hist*로 시작하는 각종 뷰를 이용해 사용자가 직접 조회할 수도 있다.

## 21

버전마다 조금씩 다르지만 AWR 보고서 맨 앞쪽의 보고서 요약에는 아래와 같은 내용을 포함한다.

-   캐시 크기(Cache Sizes)
-   부하 프로파일(Load profile)
-   인스턴스 효율성(Instance Efficiency)
-   최상위 대기 이벤트(Top N Events)
-   Shared Pool 통게(Shared Pool Statistics)
-   I/O 프로파일(IO Profile)
-   메모리 통계(Memory Statistics)

## 22

Soft Parse % : 실행계획이 라이브러리 캐시에서 찾아져 하드파싱을 일으키지 않고 SQL을 수행한 비율이다.

(전체 parse call 횟수 - 하드파싱 횟수) / ( 전체 parse call 횟수) \* 100

Execute to Parse % : Parse Call 없이 곧바로 SQL을 수행한 비율 즉 커서를 애플리케이션에서 캐싱한 채 반복 수행한 비율이다.

Parse CPU to Parse Elapsd % : 파싱 총 소요 시간 중 CPU time이 차지한 비율이다. 파싱에 소요된 시간 중 실제 일을 수행한 시간 비율을 마하며, 이 값이 낮다면 파싱 도중 대기가 많이 발생했음을 의미한다.

## 23

시스템에 문제가 생겼을 때 Ratio 기반 분석 방법으로 원인을 찾아 문제를 해결하려면 많은 시간이 걸린다.

대기 이벤트 기반 분석 방법론을 사용해도 마찬가지다 대기 이벤트 분석을 통해 문제의 원인을 금방 알 수는 있지만, 실제 문제를 해결하려면 구체적으로 어떤 프로그램, 어떤 세션에서 성능 문제를 야게했는지 확인할 수 있어야 한다.

실시간 모니터링을 통해 문제를 빠르게 해결하려면 세션 레벨 성능 분석이 필요한데, 오라클 9i까지 제공하던 세션 레벨 동적 뷰만으로는 한계가 많았다.

SQL 트레이스를 통해 가장 상세한 세션 레벨 분석이 가능하지만, 시스템에 주는 부하가 크고, 파일 단위로 정보가 수집되기 때문에 통계적 접근이 어려우며, 분석을 완료하는 데까지 시간이 오래걸린다.

게다가 수동으로 활성화해야 해서 SQL 트레이스를 걸어 확인하려는 순간 이미 상황이 종료돼 버리는 경험을 DB관리자라면 누구나 한다.

문제가 발생하기 직전 상황에 대한 분석은 아예 불가능하다. DB 성능 관리상의 이런 어려움을 해소하기 위해 오라클 10g에서 ASH(Active Session History)기능을 도입했다.

오라클은 현재 접속해서 활동 중인 Active 세션 정보를 1초에 한 번씩 샘플링해서 ASH 버퍼에 저장한다.

SGA Shared Pool에서 CPU당 2MB의 버퍼를 할당받아 세션 정보를 기록하며, 1시간 혹은 버퍼의 2/3가 팔 때마다 디스크에 기록한다.

즉 AWR에 저장하는 것이다.

ASH 버퍼에 저장된 세션 히스토리 정보는 v$active_session_history 뷰를 통해 조회할 수 있다.

ASH 기능을 이용하면 현재뿐 아니라 과거 시점에 발생한 장애 및 성능 저하 원인까지 세션 레벨로 분석할 수 있게 도와준다.

AWR로 옮겨진 좀 더 오래된 과거의 세션 히스토리 정보는 dba_hist_active_sess_history 뷰를 통해 조회할 수 있다

RAT(Real Application Testing)는 DB 구조 변경, 버전 업그레이드, 솔루션 도입, OS/하드웨어/스토리지 변경 등이 시스템에 미치는 영향을 사전에 파악하고 평가할 수 있게 도와주는 오라클 솔루션이다.

SPA(SQL Performance Analyzer)는 데이터베이스 변경 작업이 구체적으로 SQL 실행계획에 어떤 영향을 미치는지를 분석할 수 있게 도와주는 기능으로 오라클 RAT 옵션 중 하나다.

## 24

v$session_wait 뷰를 통해 문제의 대기 이벤트를 가장 많이 발생시키는 세션 목록을 확인할 수 있다.

v$active_session_history 뷰를 통해 문제의 세션들이 어떤 SQL을 수행하고 있는지 확인할 수 있다.

v$sql 뷰를 통해 문제 SQL의 전체 문장과 수행 통계(실행횟수, 평균 소요시간, 평균 블록 I/O등)를 확인할 수 있다.

dba_hist_active_sess_history를 통해서는 AWR로 옮겨진 오래된 과거의 세션 히스토리 정보를 확인할 수 있다.

## 25

db file sequential read가 가장 높은 비율을 차지하고 있는데, 이는 인덱스를 이용한 테이블 액세스 과정에 디스크 블록을 요청할 때 나타나는 대기 이벤트다.

이 대기 이벤트가 높게 나타나는 원인은 다양하므로 단순히 그 수치가 높게 나왔다고 해서 Full Scan으로 유도하는 것은 올바른 접근방법이 아니다 특히 OLTP라면

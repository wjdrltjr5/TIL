# 서술형 모음

## 15

![alt text](<서술형 이미지/15.png>)

메인쿼리 집합(MV)건수만큼 스칼라 서브쿼리를 37243번 수행하였다 서비스별 할부를 먼저 액세스해서 얻은 28953 로우만큼 할부 계획과 조인하였고 그 과정에 11만 5천 개 블록을 읽었다.

할부계획과 조인하는 이유는 할부 개월수 값을 읽기 위해서인데, 할부 개월수는 일할 계산여부가 Y가 아닐 떄만 필요하다. 따라서 할부 계획은 서비스별할부의 일할 계산여부가 Y가 아닐 때만 조인하도록 조치하는 것이 좋다.

### 문제점

할부계획의 할부개월수는 서비스별할부의 일할계산여부가 Y가 아닐 때만 필요한데 일할 계산여부가 Y일 때도 조인을 수행하고 있다.

### 개선

```sql
SELECT ...
     , (SELECT CAST WHEN A.일할계산여부 = 'Y'
                    THEN NVL(A.총청구건수, 0) - NVL(A.청구횟수, 0)
                    ELSE B.할부개월수 - NVL(A.청구횟수, 0)
               END
          FROM 서비스별할부 A, 할부계획 B
         WHERE A.서비스별계약번호 = MV.서비스계약번호
           AND A.할부상태코드 = 'XR'
           AND B.할부계획ID = (CASE WHEN A.일할계산여부 = 'Y'
                                    THEN NULL
                                    ELSE A.할부계획ID
                               END)
           AND ROWNUM <= 1) AS 청구횟수 ...
   FROM .. MV
  WHERE ...
```

## 32

![alt text](<서술형 이미지/32.jpeg>)

> /\*\*\+ leading(a b c) use_hash\*(b) use_hash(c) swap_join_inputs(c)\*/

## 33

![alt text](<서술형 이미지/33.jpeg>)

> /\*+ leading(a b c) use_hash(b) use_hash(c) no_swap_join_inputs(c) \*/

## 34

![alt text](<서술형 이미지/34.jpeg>)

> /\*+ leading(c b a) use_hash(b) use_hash(a) swap_join_inputs(a) \*/

## 35

![alt text](<서술형 이미지/35.jpg>)

> /\*+ leading(c b a) use_hash(b) use_hash(a) no_swap_join_inputs(a)\*/

## 36

![alt text](<서술형 이미지/36.jpg>)

> /\*+ leading(b a c d) use_hash(a) use_nl(c) use_hash(d) index(b 가입상품\_X1) index(a 계약\_X1) index(c) index(d) swap_join_inputs(d)\*/

## 37

![alt text](<서술형 이미지/37.jpg>)

```sql
/*+ leading(b a c d) use_hash(a) use_nl(c) use_hash(d) index(b 가입상품_X1)
    index(a 계약_X1) index(c) index(d) no_swap_join_inputs(d)*/
```

## 43

![alt text](<서술형 이미지/43.jpg>)

```sql
select /*+ ordered use_nl(t)*/
  from 고객 c
     , (select /*+ no_merge push_pred*/
               고객번호
             , avg(거래금액) 평균거래
             , min(거래금액) 최소거래
             , max(거래금액) 최대거래
          from 거래
         where 거래일시 >= trunc(sysdate, 'mm')
         group by 고객번호) t
  where c.가입일시 >= trunc(add_months(sysdate, -1), 'mm')
    and t.고객번호 = c.고객번호

```

## 44

![alt text](<서술형 이미지/44.jpg>)

```sql
select c.고객번호, c.고객명
    , (select /*+ no_unnest */ round(avg(거래금액),2) 평균거래금액
         from 거래
        where 거래일시 >= trunc(sysdate, 'mm')
          and 고객번호 = c.고객번호)
  from 고객 c
 where c.가입일시 >= trunc(add_months(sysdate, -1), 'mm')
```

## 47

![alt text](<서술형 이미지/47.jpg>)

## 48

![alt text](<서술형 이미지/48.jpg>)

한 달 주문상품 100만건중 할인 유형 코드 = 'K890' 조건을 만족하는 데이터는 20만건이다.

주문 상품은 월 단위 파티션이므로 20만건을 랜덤액세스하는 것 보다 Full Scan이 유리하다.

2만 개 상품을 한 달에 한 개 이상 주문하므로 GROUPBY 결과 집합은 2만여 건이다. 상품코드당 주문상품은 평균 10건이므로 모범답안처럼 GROUP BY 후 조인하면 조인 횟수를 1/10를 줄일 수 있다.

조인횟수가 줄고 같은 상품코드로 여러번 조인하지도 않으므로 NL조인의 부담이 줄지만 해시 조인이 더 빠르고 효과적이다. 상품 데이터를 PGA에 충분히 담을 수 있을 뿐만 아니라 2만개 상품을 고르게 주문하므로 불필요한 상품을 PGA에 적재하는 비효율도 없기 떄문이다

해시 조인을 출력 순서를 보장하지 않으므로 ORDER BY는 맨 마지막에 기술해야 한다. ORDER BY가 없는 인라인 뷰는 옵티마이저에 의해 Merging 될 수 있으므로 정확한 실행계획이 나오게 하려면 NO_MERGE힌트가 필요하다.

## 49

![alt text](<서술형 이미지/49.jpg>)

## 50

![alt text](<서술형 이미지/50.jpg>)

## 51

![alt text](<서술형 이미지/51.jpg>)

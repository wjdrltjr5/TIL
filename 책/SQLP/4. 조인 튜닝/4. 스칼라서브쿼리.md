# 스칼라 서브쿼리

## 40 스칼라 서브쿼리의 캐싱효과

스칼라 서브쿼리로 조인하면 오라클은 조인 횟수를 최소화하려고 입력값과 출력 밧을 내부 캐시에 저장해둔다. 조인할 떄마다 일단 캐시에서 입력 값을 찾아보고 찾으면 저장된 출력값을 반홚나다.

캐시에서 찾지 못할때만 조인을 수행하며, 결과는 버리지 않고 캐시에 저장해둔다.

이런 캐싱 메커니즘은 조인 성능을 높이는 데 큰 도움이 된다. 메인쿼리 집합이 아무리 커도 조인할 데이터를 대부분 캐시에서 찾는다면, 조인 수행횟수를 최소화할 수 있기 때문이다.

## 43 조인조건 Pushdown

옵티마이저는 쿼리 블록단위로 최적화한다. 문제의 쿼리에서 뷰를 변환하지 않고 그대로 두면, 뷰 쿼리 블록을 독립적으로 최적화한다.

그러면 당월 거래 전체를 읽어 고객번호 수준으로 Group By한 후에 고객 테이블과 조인하므로 부분범위 처리가 불가능하다. 더큰 문제는 고객 테이블에서 전월 이후 가입한 고객을 필터링하는 조건이 인라인 뷰 바깥에 있다는 사실이다. 이 조건이 있는데오 인라인 뷰 안에서는 당월에 거래한 모든 고객의 거래 데이터를 읽어야 한다.

뷰 바깥에 있는 조건절을 활용하기 위해 옵티마이저는 뷰를 메인 쿼리와 머징할 수 있다.

문제에서 제시한 실행계획이 바로 그것 여기서는 뷰 머징한 거래 테이블을 고객과 해시 조인한 후에 Group by 했지만 NL조인으로 처리할 수도 있다.

고객을 기준으로 거래 테이블과 NL조인하도록 유도하고 그 순서에 최적화된 인덱스를 구성해 주면, 가입일시 조건을 만족하는 고객의 거래 중 거래일시 조건을 만족하는 데이터만 읽도록 구혀낳ㄹ 수 있다.

그러나 여전히 부분범위 처리는 불가능하다. 조인에 성공한 전체 집합을 Group By 하고서야 데이터를 출력할 수 있기 때문이다.

11g에 도입된 조인조건 Pushdown 쿼리 변환을 이용하면 지금까지 설명한 비효율을 일소에 해결할 수 있다.

이는 메인 쿼리를 실행하면서 조인 조건절 값을 건건이 뷰 안으로 밀어넣는 기능이다.

이 기능이 작동하면 실행계획에 VIEW PUSHED PREDICATE 오퍼레이션이 나타난다.

## 44 스칼라 서브쿼리 Unnesting

스칼라 서브쿼리도 NL 방식으로 조인하므로 캐싱 효과가 크지 않으면 랜덤 I/O에 따른 부담이 클 수 있다.

그래서 NL이아닌 다른 조인 방식을 선택하기 위해 스칼라 서브쿼리를 조인문으로 변환해야 하는 경우가 있다.

오라클 12c부터는 스칼라 서브쿼리도 Unnesting이 가능해졌다. 옵티마이저가 사용자를 대신해 자동으로 쿼리를 변환해 주는것이다.

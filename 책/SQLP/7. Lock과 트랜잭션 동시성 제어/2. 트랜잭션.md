# 트랜잭션
## 16 트랜잭션의 4가지 특징 (ACID)
- 원자성 (Atomicity) : 트랜잭션은 분해가 불가능한 업무의 최소단위이므로, 전부 처리되거나 아예 하나도 처리되지 않아야 한다.

- 일관성 (Consistency) : 일관된 상태의 데이터베이스에서 하나의 트랜잭션을 성공적으로 완료하고 나면 그 데이터베이스는 여전히 일관된 상태여야 한다. 즉 트랜잭션 실행의 결과로 데이터베이스 상태가 모순되지 않아야 한다.

- 격리성(Isolation) : 실행 중인 트랜잭션의 중간결과를 다른 트랜잭션이 접근할 수 없다.

- 영속성(Durability) : 트랜잭션이 일단 그 실행을 성공적으로 완료하고 나면 그 결과는 데이터베이스에 영속적으로 저장된다.

## 17 동시 트랜잭션에 의해 나타날 수 있는 이상현상
다중 트랜잭션 환경에서 동시성 제어를 제대로 하지 않으면, 아래와 같은 이상현상이 나타날 수 있다.
- Dirty Read : 다른 트랜잭션이 변경 중인 데이터를 읽었는데 그 트랜잭션이 최종 롤백됨으로써 비일관성 상태에 놓이는 현상
- Non-Repeatable Read : 한 트랜잭션 내에서 같은 데이터를 두 번 이상 읽을 때, 다른 트랜잭션이 값을 수정 또는 삭제함으로 인해 읽은 값이 서로 달라지는 현상
- Phantom Read : 한 트랜잭션 내에서 일정 범위의 데이터를 두 번 이상 읽을 때, 다른 트랜잭션이 새로운 데이터를 추가함으로 인해 첫 번째 읽을 떄 없던 데이터가 나타나는 현상

## 19 격리성 수준별 비일관성 현상
- Read Uncommitted : Dirty Read, Non-Repeatable Read, Phantom Read
- Read Committed : Non-Repeatable Read, Phantom Read
- Repeatable Read : Phantom Read
- Serializable : 없음

## 26 갱신 대상 식별
두 트랜잭션이 동일한 행을 갱신하고자 할 때 후행 트랜잭션은 선행 트랜잭션이 설정한 Lock이 해제되기를 기다리며 블로킹 된다. 갱신을 마친 선행 트랜잭션이 Commit을 완료하고 나면 비로서 후행 트랜잭션은 Lock을 획득하고 갱신을 시작한다. 이때 update를 처리하는 방식이 DBMS 마다 다르다.

오라클처럼 MVCC(Multi-Version Concurrency Control) 모델을 사용하는 DBMS는 Update 문이 시작된 시점을 기준으로 갱신 대상을 식별한다.

만약 대상으로 식별된 레코드 중 Update 문 시작 이후에 조건절 값이 변경된 레코드가 발견되면, 일관성 확보를 위해 Update문을 재시작한다.

조건절 값이 변경된 레코드가 발견되지 않으면 그대로 Update를 진행한다.

SQL Server 처럼 MVCC 모델을 사용하지 않는 DBMS는(Update 문 시작 시점이 아니라) 레코드에 도달한 시점을 기준으로 갱신 대상을 식별한다.

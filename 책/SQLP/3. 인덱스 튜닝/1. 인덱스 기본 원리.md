# 인덱스 기본 원리

## 1 B\*Tree 구조

B\*Tree 인덱스 구조를 요약하면 다음과 같다.

-   브랜치 블록의 각 로우는 하위 블록에 대한 주소값을 가진다.
-   브랜치 블록 각 로우의 키 값은 하위블록이 갖는 값의 범위를 의미한다.
-   리프 블록의 각 로우는 테이블 로우에 대한 주소값을 갖는다.
-   리프 블록 각 로우의 키 값과 테이블 로우의 키 값은 서로 일치한다.
-   리프 블록의 각 로우와 테이블 로우 간에는 1:1 관계다.
-   리프 블록끼리는 이중연결리스트 구조다.

## 2 인덱스 ROWID

오라클 초기 버전부터 사용하전 제한 ROWID 포맷은 ROWID가 데이터파일 번호 + 블록 번호 + 블록 내 로우번호로 구성된다.

오라클 8버전부터 사용하기 시작한 확장 ROWID 포맷은 ROWID가 오브젝트 번호 + 데이터파일 번호 + 블록 번호 + 블록 내 로우번호로 구성된다.

## 3 인덱스 탐색

B\*Tree 인덱스를 탐색할 때는 우선 루트에서 리프 블록까지 수직적 탐색을 통해 스캔 시작지점을 찾는다.

수직적 탐색을 통해 조건을 만족하는 첫 번째 레코드를 찾았으면, 인덱스 리프 블록을 스캔하면서 찾고자 하는 데이터가 더 안나타날 때까지 수평적 탐색을 진행한다.

## 4

## 5

## 6

## 7

## 8 INDEX FULL SCAN

Index Full Scan은 인덱스 리프 블록을 처음부터 끝까지 모두 스캔하는방식이며 인덱스 선두 컬럼이 조건절에 없을 때 사용된다.

인덱스 선두 컬럼이 조건절에 없으면 Index Range Scan이 불가능하므로 테이블을 Full Scan 해야 하는데, 컬럼이 많은 큰 테이블을 스캔하려면 블록 I/O가 많이 발생하므로 성능이 느리다.

그럴 때 컬럼이 적은 인덱스를 스캔하면 I/O발생량을 줄일 수 있다.

단 인덱스 필터 조건을 만족하는 데이터가 적어야 한다. 필터 조건을 만족하는 데이터가 많으면 테이블 랜덤 액세스도 그만큼 많이 발생하므로 테이블 전체 스캔보다 성능이 훨씬 더 느려진다.

필터 조건을 만족하는 데이터가 많더라도 결과집합 중 앞쪽 일부만 스캔하고 멈춘다면, 즉 부분범위 처리를 활용할 수 있다면, Index Full Scan이 효과적일 수 있다.

인덱스 앞쪽에서 조건을 만족하는 데이터를 빨리 찾을 수 있기 때문이다.

오라클은 index_fs 힌트를 제공하지 않는다.

## 9

PK 인덱스는 Unique 하다. Unique 인덱스 구성 컬럼을 모두 = 조건으로 검색하면 Index Unique Scan이 선택되지만 전체가 아닌 일부 컬럼으로 검색할 때는 Range Scan이 선택된다.

## 10

인덱스 리프 블록들은 물리적으로 여러 익스텐트에 흩어진 상태로 저장된다. 하지만 정렬 순서에 따라 이중 연결 리스트 방식으로 서로 연결돼 있으므로 순서대로 스캔하면 결과 집합의 순서를 보장한다.

Index Fast Full Scan은 인덱스 리프 블록끼리의 논리적인 연결 순서를 따르지 않고 Table Full Scan 처럼 HWM 아래 익스텐트 전체를 MultiBlock I/O 방식으로 Full Scan 하므로 결과집합의 순서를 보장하지 않는다.

## 11

## 12

## 13

## 14

## 15 Index Fragmentation

Index Skew는 인덱스 엔트리가 왼쪽 또는 오른쪽에 치우치는 현상을 말한다.

Index Sparse는 인덱스 블록 전반에 걸쳐 밀도가 떨어지는 현상을 말한다.

## 16 비트맵 인덱스

비트맵 인덱스는 성별처럼 Distinct Value개수가 적을 때 저장효율이 매우 좋다. 그런 컬럼이라면 B\*Tree 인덱스보다 훨씬 적은 용량을 차지하므로 인덱스가 여러 개 필요한 대용량 테이블에 유용하다.

주로 다양한 분석관점을 가진 팩트 테이블이 여기에 속한다.

비트맵 인덱스는 여러 인덱스를 동시에 사용할 수 있다. 여러 개 비트맵 인덱스로 Bitwise 연산을 수행함으로써 테이블 액세스량을 크게 줄일 수 있다면 극적인 성능 향상을 가져다 준다.

따라서 다양한 조건절이 사용되는 특히 정형화되지 않은 임의 질의가 많은 대용량 DW/OLAP환경에 적합하다.

다만 비트맵 인덱스는Lock에 의한 DML 부하가 심한 것이 단점이다. 레코드 하나만 변경되더라도 해당 비트맵 범위에 속한 모든 레코드에 lock이걸린다.

OTLP성 환경에 비트맵 인덱스를 쓸 수 없는 이유가 여기에 있다.

## 17 함수기반 인덱스

조건절에서 인덱스 컬럼에 함수를 적용하면 정상적인 index range scan이 불가능하다

인덱스에는 가공하지 않은 값을 기준으로 정렬해서 저장하는데, 가공한 값으로 검색하면 수직적 탐색을 통해 스캔 시작점과 끝 지점을 찾을 수 없기 떄문이다.

그럴 때 인덱스에도 함수를 적용한 상태로 값을 저장하면 정상적인 Index Range Scan이 가능한데 이를 함수기반 인덱스라고한다.

## 18 리버스 키 인덱스

일련번호, 입력일시, 변경일시 등 오름차순 한 방향으로만 값이 증가하는 컬럼에 인덱스를 생성하면, 동시에 INSERT하려는 다중 트랜잭션에 의해 맨 우측(마지막) 리프 블록에 경합이 발생할 수 있다.

그럴 때 인덱스 키 값을 역으로 변환해서 저장하면 신규로 Insert하는 값들이 여러 리프 블록에 흩어지므로 경합도 자연스럽게 줄어든다.

## 19

## 20

## 21

## 22 Index Range Scan 불가 조건

인덱스를 정상적으로 Range Scan할 수 없는 이유는 인덱스 스캔 시작점을 찾을 수 없기 떄문이다.

Index Range Scan에서 Range는 범위를 의미한다. 즉 Index Range Scan은 인덱스 에서 일정 범위를 스캔한다는 뜻이다.

하지 못하는 대표적인 조건은 인덱스 컬럼 가공

## 23 is null 조건에 대한 Index Range Scan

오라클은 구성컬럼이 모두 null인 레코드는 인덱스에 저장하지 않는다.

따라서 단일 컬럼 인덱스에 is null조건으로는 범위 스캔이 불가능하다.

2개 이상 컬럼으로 구성된 결합인덱스에 대해서는 is null 조건에 대한 Index Range Scan이 가능할 수 있다. 구성 컬럼 중 하나라도 null이 아닌 레코드는 인덱스에 저장하기 떄문이다.

## 24

## 25 Index Range Scan 가능조건

Index Range Scan하려면 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있어야 한다.

반대로 말해 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 range scan은 무조건 가능하다.

## 26 OR 조건에 대한 Index Range Scan

OR 조건은 기본적으로 Index Range Scan을 위한 액세스 조건으로 사용할 수 없다.

다만 옵티마이저에 의한 쿼리변환으로 분기 되었을 때 각각 수직 탐색을 위한 액세스 조건으로 사용할 인덱스가 있다면 가능하다.

## 27

## 28

## 29

## 30

## 31

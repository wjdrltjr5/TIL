# 테이블 액세스 최소화

## 32

인덱스 ROWID는 테이블 레코드와 직접 연결된 구조가 아니다. 데이터 파일상에서 테이블 레코드를 찾가가기 위한 논리적인 주소 정보다.

인덱스 ROWID에 포함된 데이터 블록 주소(데이터 파일번호 + 블록번호)는 디스크 상의 블록 주소지만, 블록을 매번 데이퍼파일에서 읽는다면 성능은 이루 말할 수 없이 느리다.

I/O성능을 위한 버퍼 캐시 활용이 필수인 이유다. ROWID가 가리키는 블록을 버퍼캐시에서 먼저 찾아보고 못 찾을 떄만 데이터파일에서 읽는다. 물론 버퍼캐시에 적재한 후에 읽는다.

캐시에서 블록을 읽을 떄는 읽고자 하는 데이터 블록 주소를 해시 함수에 입력해서 해시체인을 찾고 거기서 버퍼 헤더를 찾는다.

캐시에 적재할 때와 같은 해시 함수를 사용하므로 버퍼 헤더는 항상 같은 해시 체인에 연결된다. 반면 실제 데이터가 담긴 버퍼 블록은 매번 다른 위치에 캐싱되는데, 그 메모리 주소값을 버퍼 헤더가 가지고 있다.

버퍼 캐시는 시스템 공유 메모리에 위치하므로 액세스를 직렬화하기 위한 LOCK 메커니즘이 작동한다.

따라서 버퍼 캐시에서 블록을 읽을 때마다 Latch Buffer Lock을 획득해야 한다.

동시 액세스가 심할 때는 Latch와 Buffer Lock에 대한 경합까지 발생하므로 인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조다.

## 33

인덱스를 아무리 재생성 클러스터링 팩터는 좋아지지 않는다. 클러스터링 팩터를 좋게 하려면 인덱스 컬럼 순으로 정렬되도록 테이블을 재생성해야 한다.

## 34

-   인덱스 클러스터링 팩터가 좋으면 테이블 액세스 과정에 발생하는 블록 I/O가 감소하므로 같은 양의 데이터를 추출하더라도 CF가 나쁠 떄보다 소요시간이 줄어든다.

    -   따라서 그래프에서 인덱스 ROWID를 이요한 테이블 액세스의 경사가 완만해지면서 인덱스 손익분기점이 올라간다.

    -   반대로 CF가 나쁘면 인덱스 ROWID를 이용한 테이블 액세스의 경사가 가팔라지면서 인덱스 손익분기점은 내려간다.

-   Multiblock I/O 단위를 늘릴수록 디스크 I/O Call 횟수가 줄고 테이블 전체 스캔 비용이 낮아지므로 소요시간이 줄어든다 따라서 인덱스 손익분기점이 내려간다.

-   테이블 스캔 비용은 데이터양이 느는 만큼 선형적으로 증가하지만, 인덱스를 이용한 테이블 액세스 비용은 데이터양이 늘고 추출 건수가 많아질수록 기하급수적으로 증가한다.
    -   첫 번째 이유는 데이터양이 늘수록 인덱스 CF가 점점 나빠지기 때문이다.
    -   두 번째 이유는 버퍼캐시 히트율이 점점 낮아지기 때문이다.
    -   Multiblock I/O 효과까지 고려하면, 데이터가 늘 떄의 Full Scan 비용 상승보다 방금 설명한 두 가지 요소에 의한 테이블 랜덤 액세스 비용 상승이 일반적으로 더 크다.
    -   따라서 데이터양이 늘수록 인덱스 손익분기점은 내려갈 가능성이 높다.
    -   단순하게 생각하면 데이터양이 늘면 Full Scan 비용이 상승하므로 인덱스 손익분기점이 올라갈 것으로 생각하기 쉽지만, 그 반대
    -   클러스터링 팩터가 나빠지고 버퍼캐시 히트율이 낮아지면서 늘어나는 디스크 I/O Call 부하가 그만큼 크다.

## 35 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝

온라인 프로그램은 보통 소량 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는 것이 무엇보다 중요하다.

조인도 대부분 NL 방식을 사용한다. 인덱스를 이용해 소트 연산을 생략함으로써 부분범위 처리 방식으로 구현할 수 있다면, 온라인 환경에서 대량 데이터를 조회할 때도 아주 빠른 응답속도를 낼 수 있다.

반면 대량 데이터를 읽고 갱신하는 배치 프로그램은 항상 전체범위 처리 기준으로 튜닝해야 한다. 즉 처리 대상 집합 중 일부를 빠르게 처리하는 것이 아니라 전체를 빠르게 처리하는 것을 목표로 삼아야 한다.

대량 데이터를 빠르게 처리하려면, 인덱스와 NL조인보다 Full Scan과 해시 조인이 유리하다.

## 36

## 37

-   테이블 랜덤 액세스가 많을 때는 인덱스 컬럼 추가를 가장 우선해서 검토한다.
-   IOT가 테이블 랜덤 액세스를 없애는 데는 가장 효과적이다 다만 테이블 구조 변경에 따른 부담과 IOT 자체가 갖는 부작용이 적지 않으므로 운영 중에 적용하고자 할 때는 신중하게 검토해야 한다.
-   인덱스를 재구성하면 인덱스 스캔 비효율을 줄이는 데는 도움이 되지만, 테이블 액세스를 줄이는 데는 전혀 도움이 되지 않는다.
-   인덱스 순으로 정렬되도록 테이블을 재생성한다면, 클러스터링 팩터가 좋아져 테이블 랜덤 액세스를 줄이는 데 상당한 도움을 준다.

## 38

인덱스에 컬럼을 추가하면 인덱스 사이즈가 증가한다. 한 블록에 담을 수 있는 로우 수가 줄면 리프 블록수가 증가하고 인덱스 높이도 증가하기 때문이다.

리프 블록 수가 증가하면 스캔 과정에 읽는 블록 I/O가 다소 증가하므로 스캔 효율이 약간 나빠진다.

값이 같은 인덱스 레코드는 ROWID 순으로 정렬하므로 선두 컬럼의 NDV가 적다면 클러스터링 팩터는 비교적 좋은 상태일 것이다.

이때 뒤쪽에 컬럼을 추가하면 새로운 정렬 순서(기존 컬럼 + 신규 컬럼 + ROWID)를 갖게 되므로 클러스터링 팩터가 나빠진다.

선두 컬럼의 NDV가 많은 상황에서 컬럼을 추가하더라도 클러스터링 팩터가 좋아지지는 않는다.

## 39 배치 I/O

인덱스 ROWID를 이용한 테이블 랜덤 액세스는 생각보다 고비용 구조다 인덱스를 이용해 대량 데이터를 조회하면, 디스크I/O 발생량이 증가하고 그만큼 성능이 나빠진다.

디스크 랜덤 I/O 성능을 높이려고 DBMS 업체들이 계속 노력을 기울이는 가운데, 오라클에서 최근 가장 눈에 띄는 개선은 배치I/O 기능에서 찾을 수 있다.

배치 I/O는 읽는 블록마다 건건히 I/O Call을 발생시키는 비효율을 줄이기 위해 고안한 기능이다.

인덱스를 이용해 테이블을 액세스하다가 버퍼 캐시에서 블록을 찾지 못하면 일반적으로 디스크 블록을 바로 읽는데 이 기능이 작동하면 테이블 블록에 대한 디스크 I/O Call을 미뤘다가 읽은 블록이 일정량 쌓이면 한꺼번에 처리한다.

배치 I/O 기능이 작동하면 인덱스를 이용해서 출력하는 데이터 정렬 순서가 매번 바를 수 있다는 사실에 주목해야 한다.

테이블 블록을 모두 버퍼 캐시에 찾을 때는 기존처럼 인덱스 키값 순으로 데이터가 출력되지만 그렇지 않을 때 즉, 실제 배치 I/O가 작동할 때는 데이터 출력 순서가 인덱스 정렬 순서와 다를 수 있다.

## 40

소트 연산을 생략할 수 있는 인덱스 구성이므로 배치 I/O가 작동하지 않는 한 변경 전 실행계획처럼 SORT ORDER BY 오퍼레이션이 자동으로 생략된다.

소트 연산을 생략할 수 있는 인덱스 구성이어도 배치 I/O가 작동할 수 있다면 변경 후 실행계획처럼 SORT ORDER BY 오퍼레이션이 나타난다.

배치 I/O가 실제로 작동하면 데이터 정렬 순서를 보장할 수 없게 되므로 옵티마이저가 정렬 연산을 추가한 것

배치 I/O가 작동하더라도 SQL에 ORDER BY를 명시했으므로 정렬 순서는 보장된다.

다만 부분범위 처리가 불가능해진다.

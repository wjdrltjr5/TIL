# SQL 옵티마이징 원리

## 1 비용기반 옵티마이저

비용 기반 옵티마이저는 사용자 쿼리를 위해 후보군이 될만한 실행계획들을 도출하고 데이터 딕셔너리에 미리 수집해 둔 통계정보를 이용해 각 실행계획의 예상 비용을 산정하고 그중 가장 낮은 비용의 실행계획 하나를 선택하는 옵티마이저다.

cbo가 사용하는 통계정보로는 데이터양 컬럼 값의 수 컬럼 값 분포 인덱스 높이 클러스터링 팩터 등이 있다.

## 2 규칙기반 옵티마이저

과거에는 각 액세스 경로에 대한 우선순위 규첵에 따라 실행계획을 만드는 옵티마이저를 사용했었다.

데이터 특성을 나타내는 통계정보를 전혀 활용하지 않고 단순 규칙에만 의존하기 때문에 대량 데이터를 처리하는 데 부적합 하다.

RBO 규칙도 어느 정도 보편타당하기 때문에 사용에 큰 무리가 없던 시절이 있었다 하지만 지금과 같은 대용량 데이터베이스 환경에서는 전혀 대안이 될 수 없다.

## 3 옵티마이저의 서브 엔진

옵티마이저가 최적화를 수행할 떄 세부적으로 아래 3개의 서브 엔진을 사용한다.

-   Query Transformer : 사용자로부터 전달받은 SQL을 그대로 최적화하지 않고 우선 최적화에 유리한 형태로 변환을 시도한다.

-   Estimator : 쿼리 오퍼레이션 각 단계의 선택도, 카디널리티, 비용을 계산하고, 궁극적으로 실행계획 전체에 대한 총 비용을 계산해 낸다.

-   Plan Generator : 하나의 쿼리를 수행하는 데 있어, 후보군이 될만한 실행계획들을 생성해 낸다.

## 6 통계정보

옵티마이저가 사용하는 통계정보로는 크게 오브젝트 통계와 시스템 통계가 있다.

오브젝트 통계로는 테이블 통계, 인덱스 통계, 컬럼 통계가 있다.

시스템 통계로는 CPU 속도, Single block I/O 속도, Multi block I/O 속도 평균적인 Multiblock I/O 개수 등을 관리한다.

## 8 옵티마이저 행동에 영향을 미치는 요소

-   옵티마이징 팩터 : 인덱스, IOT, 클러스터링, 파티셔닝 등 오브젝트 구성
-   DBMS 제약 설정 : PK, FK, Check, Not Null 등
-   통계정보
-   옵티마이저 힌트
-   옵티마이저 관련 파라미터

## 9 옵티마이저의 한계

옵티마이저가 항상 최적의 실행계획을 생성하지 못하는 데는 아래와 같은 이유가 있다.

-   부족한 옵티마이징 팩터 : 인덱스, IOT, 클러스터링, 파티셔닝 등 오브젝트 구성
-   부정확한 통계 : 정보 수집 및 보관 비용 측면의 한계
-   결합 선택도 산정의 어려움
-   바인드 변수 사용 시, 히스토그램 사용에 제약 : 균등 분포 가정
-   비현실적인 가정과 규칙에 의존
-   최적화 시간에 허용된 시간 제약

## 10 선택도와 카디널리티

선택도란 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율을 말한다.

연산자 종류에 따라 선택도를 구하는 방식이 다른데 가장 단순한 = 조건으로 검색하는 경우만 살펴보면 아래와 같다.

NDV는 컬럼 값 종류 개수를 의미한다.

-   선택도 = 1/NDV

카티널리티란 전체 레코드 중에서 조건절에 의해 선택되는 레코드 개수이며, 아래 공식으로 구한다.

-   카디널리티 = 총 로우수 \* 선택도 = 총 로우 수 / NDV

## 12 컬럼 통계

오라클이 수집하는 컬럼 통계 항목들

-   중복을 제거한 컬럼 값의 수
-   최소값
-   최대값
-   밀도
-   평균 컬럼 길이
-   NULL 값을 가진 레코드 수

## 13 시스템 통계

-   CPU 속도
-   평균적인 Single Block I/O 속도
-   평균적인 Multi Block I/O 속도
-   평균적인 Multi Block I/O 개수
-   I/O 서브시스템의 최대 처리량
-   병렬 Slave 의 평균적인 처리량

## 14 I/O 비용모델 vs CPU 비용모델

I/O 비용 모델의 비용은 예상되는 디스크 I/O Call 횟수를 의미한다.

실행계획상 100으로 표시 됐다면, 쿼리 수행 과적에 I/O Call이 100번 발생할 것으로 옵티마이저가 예상한다는 뜻이다.

CPU 비용 모델에서는 예상 I/O 시간과 예상 CPU 사용시간을 구한 후 Single Block I/O 시간으로 나눈 값을 비용값으로 사용한다.

즉 비용을 Single Block I/O소요되는 시간과 상대적인 시간 비용으로 표현한 것

즉 Cost 100은 Single Block I/O를 100번 하는 정도의 시간이 소요될 것으로 예상한다는 뜻

## 15 히스토그램 유형

-   도수분포 : 값별로 빈도수 저장
-   높이 균형 : 각 버킷의 높이가 동일하도록 데이터 분포 관리
-   상위 도수 분포 : 많은 레코드를 가진 상위 n개 값의 빈도수 저장
-   하이브리드 : 도수 분포와 높이 균형 히스토그램의 특성을 결합

## 16 인덱스를 이용한 테이블 액세스 비용

인덱스를 이용한 테이블 액세스 비용은 아래와 같이 구한다.

```
비용 = 브랜치 레벨
     + (리브 블록 수 * 유효 인덱스 선택도)
     + (클러스터링 팩터 * 유효 테이블 선택도)
```

유효 인덱스 선택도는 인덱스 총 레코드 중에서 조건절을 만족할 것으로 예상되는 레코드 비율을 의미한다.

유효 테이블 선택도는 전체 인덱스 레코드 중에서 인덱스 스캔을 완료하고서 테이블을 방문할 것으로 예상되는 레코드 비율을 의미한다.

## 16

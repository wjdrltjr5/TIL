# 쿼리 변환

## 26 쿼리 변환

쿼리 변환은 옵티마이저가 SQL분석해 의미적으로 동일하면서도 더 나은 성능이 기대되는 형태로 재작성하는 것을 말한다.

결과만 보장된다면 무조건 쿼리 변환 수행하는 것을 휴리스틱 쿼리 변환이라고 한다.

예상 비용이 낮을 때만 변환된 쿼리를 사용하는 것을 비용기반 쿼리 변환이라고 한다.

## 27 서브쿼리 Unnesting

서브쿼리는 하나의 SQL문장 내에서 괄호로 묶은 별도의 쿼리 블록을 말한다.

인라인 뷰, 중첩된 서브쿼리, 스칼라 서브쿼리가 여기에 속한다. 옵티마이저는 쿼리 블록 단위로 최적화를 수행하므로 서브쿼리를 그대로 두면 최적화를 위해 선택할 수 있는 대안이 줄어든다.

중첩된 서브쿼리를 unnesting 하지 않으면 메인 쿼리를 기준으로 서브쿼리를 반복 실행하는 필터 방식으로 처리할 수밖에 없다.

이는 NL조인과 같은 방식이므로 대용량 데이터를 처리할 때 매우 불리하다.

다만 내부적으로 서브쿼리 캐싱기능을 적용하므로 서브쿼리에서 리턴할 수 있는 값의 종류가 적을 떄는 성능이 크게 나쁘지 않을 수 있다.

중첩된 서브쿼리를 Unnesting 하면 조인 순서를 자유롭게 결정할 수 있고 NL조인뿐 아니라 해시 조인, 소트 머지 조인으로도 처리할 수 있어 성능 최적화에 큰 도움이 된다.

## 34 뷰 Merging과 조인 조건 Pushdown

최적화 단위가 쿼리 블록이므로 옵티마이저가 뷰 쿼리를 변환하지 않음녀 뷰 쿼리 블록을 독립적으로 최적화한다.

문제의 쿼리를 예로 들어 뷰를 독립적으로 최적화 하려면 당월 거래 전체를 읽어 고객번호 수준으로 Group By 한 후 고객 테이블과 조인해야 한다.

문제는 고객 테이블에서 전월 이후 가입한 고객을 필터링하는 조건이 인라인 뷰 바깥에 있다는 사실

이 조건을 만족하는 데이터가 대다수라면 상관 없지만, 대게는 극 고수일 것이다. 그런데도 인라인 뷰 안에서 당월에 거래한 모든 고객의 거래 데이터를 읽어야 하므로 비효율적이다.

그럴 때 뷰를 merging해서 고객을 기주능로 거래와 조인한 후에 Group By 한다면 전월 이후 가입한 고객이 당월에 일으킨 거래 데이터만 읽을 수 있어 효과적이다. 단 이 경우 부분범위 처리는 불가능하다. Group By 이후에 데이터를 출력해야 하기 때문이다.

부분범위 처리를 이용해서 빠른 응답속도를 내고 싶다면, 뷰를 Merging 하지 않은 상태에서 고객을 기준으로 인라인 뷰 집합과 NL방식으로 조인하면 된다.

그러면 전월 이후 가입한 고객만을 대상으로 고객번호를 건건히 뷰 안으로 밀어 넣으면서 각 고객별 당월 거래데이터만 읽어서 Group BY 결과를 출력할 수 있다.

이 기능을 조인 고전 Pushdown이라고 하며 이 기능의 특장점은 NL조인을 수행하는 도중에 멈출 수 있다는 데 있다. 즉 부분범위 처리가 가능하다

## 42 조건절 이행

조건절 이행(Transitive Predicate Generation, Transitive Closure)라고 불리는 쿼리 변환을 한마디로 요약하면 a=b, b=c, a=c라는 추론을 통해 새로운 조건절을 내부적으로 생성해 주는 쿼리 변환이다.

a테이블에 사용된 필터 조건이 조인 조건을 타고 반대편 b테이블에 대한 필터 조건으로 이행될 수 있다.

한 테이블 내에서 두 컬럼간 관계정보를 이용해 조건절이 이행되기도 한다

## 43 OR Expansion

OR Expansion은 OR조건을 분해해서 UNION ALL 형태로 변환해 주는 기능이다.

이 기능이 작동하도록 유도하는 힌트는 use_concat이며 반대로 이기능을 방지하는 힌트는 no_expand다

## 45 공통 표현식 제거

같은 조건식이 여러 곳에서 반복 재사용될 경우 해당 조건식이 각 로우당 한 번씩만 평가 되도록 변환하는 것을 공통 표현식 제거라고 한다.

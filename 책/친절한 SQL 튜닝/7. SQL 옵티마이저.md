# SQL 옵티마이저

## 7.1 통계정보와 비용 계산 원리

SQL 튜닝뿐 아니라 데이터베이스를 안정적으로 관리하기 위해서도 옵티마이저에 대한 이해가 필수다.

### 7.1.1 선택도와 카디널리티

선택도란, 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율을 말한다. 가장 단순한 = 조건으로 검색할 떄의 선택도만 살펴보면 컬럼 값 종류 개수 를 이용해 아래와 같이 구한다.

선택도 = 1/NDV

카디널리티란 전체 레코드 중에서 조건절의의한 선택되는 레코드 개수이며, 아래 공식으로 구한다.

카디널리티 = 총 로수수 \* 선택도 = 총 로우수 / NDV

`상품 분류 컬럼에 '가전', '의류', '식음료', '생활용품' 네 개의 값이 있을때 아래 조건절에 대한 선택도는 25%이다 1/4 만약 전체 레코드가 10만건이면, 카디널리티는 2만5천건이다.
`

```sql
where 상품분류 = '가전'
```

옵티마이저는 이렇게 카디널리티를 구하고, 그만큼의 데이터를 액세스하는 데 드는 비용을 계산해서 테이블 액세스 방식, 조인 순서, 조인 방식 등을 결정한다.

비용을 계산하는 출발점은 선택도다. 선택도를 잘못 계산하면 카디널리티와 비용도 잘못 계산하고 결과적으로 비효율적인 액새스 방식과 조인 방식을 선택하게 된다.

선택도를 계산할때 DNV를 사용하므로 통계정보 수집 과정에서 이 값을 정확히 구하는 것이 매우 중요하다.( 통계정보 수집주기, 샘플링 비율등을 잘 결정해야 하는 이유)

### 7.1.2 통계정보

통계정보

-   오브젝트 통계
    -   테이블 통계
    -   인덱스 통계
    -   컬럼 통계(히스토그램 포함)
-   시스템 통계

#### 1. 테이블 통계

테이블 통계를 수직하는 명령어

```sql
begin
  dbms_stats.gather_table_stats('scott', 'emp');
end;
/
```

수집한 테이블 통계정보 조회 방법

```sql
-- all_tab_statistic 뷰에서도 같은 정보를 확인할 수 있다.
select num_rows, blocks, avg_row_len, sample_size, last_analyzed
from all_tables
where owner = 'SCOTT'
and table_name = 'EMP';
```

주요 테이블 통계 항목

-   NUM_ROWS : 테이블에 저장된 총 레코드 개수
-   BLOCKS : 테이블 블록 수 = 사용된 인스텐트에 속한 총 블록 수
    -   테이블에 할당된 총 블록 수는 dba_segments 또는 user_segments 뷰에서 확인가능
-   AVG_ROW_LEN : 레코드당 평균 길이
-   SAMPLE_SIZE : 샘플링한 레코드 수
-   LAST_ANALYZED : 통계정보 수집일시

#### 2. 인덱스 통계

인덱스 통계를 수집하는 명령어는 다음과 같다

```sql
-- 인덱스 통계만 수집
begin
  dbms_stats.gather_index_stats(ownname => 'scott', indname => 'emp_x01');
end;
/

-- 테이블 통계를 수집하면서 인덱스 통계도 같이 수집
begin
  dbms_stats.gather_table_stats('scott', 'emp', cascade=>true);
end;
/
```

수집된 인덱스 통계정보 확인방법

```sql
-- all_ind_statistic 뷰에서도 같은 정보를 확인할 수 있다.
select blevel, leaf_blocks, num_rows, distinct_keys
     , avg_leaf_blocks_per_key, avg_data_blocks_per_key, clustering_factor
     , sample_size, last_analyzed
from all_indexes
where owner = 'SCOTT'
and table_name = 'EMP'
and index_name = 'EMP_X01';
```

-   BLEVEL : 브랜치 레벨의 약자 인덱스 루트에서 리프 블록에 도달하기 직전짜기 읽는 블록 수
-   LEAF_BLOCKS : 인덱스 리프 블록 총 개수
-   NUM_ROWS : 인덱스에 저장된 레코드 개수
-   DISTINCT_KEYS : 인덱스 키값의 조합으로 만들어지는 값의 종류 개수
    -   예. c1 + c2 로 구성한 인덱스에서 c1 컬럼에 3개, c2 컬럼에 4개 값이 있을때
    -   최대 12개 종류가 만들어 질텐데, 인덱스에 저장된 데이터 기준으로 실제 입력된 값의 종류 개수를 구해 놓은 수치
    -   인덱스 키값을 모두 = 조건으로 조회할 떄의 선택도를 계산하는데 사용
-   AVG_LEAF_BLOCKS_PER_KEY : 인덱스 키값을 모두 = 조건으로 조회할 때 읽게 될 리프 블록 개수
-   AVG_DATA_BLOCKS_PER_KEY : 인덱스 키값을 모두 = 조건으로 조회할 때 읽게 될 테이블 블록 개수
-   CLUSTERING_FACTOR : 인덱스 키값 기준으로 테이블 데이터가 모여 있는 정도. 인덱스 전체 레코드를 스캔하면서 테이블 레코드를 찾아갈 때 읽게 될 테이블 블록 개수를 미리 계산해 놓은 수

#### 3. 컬럼 통계

컬럼 통계는 테이블 통계 수집할 때 함께 수집된다.

```sql
-- all_tab_col_statistics 뷰에서도 같은 정보를 확인할 수 있다.
select num_distinct, density, avg_col_len, low_value, high_value, num_nulls
      , last_analyzed, sample_size
from all_tab_columns
where owenr = 'SCOTT'
and table_name = 'EMP'
and column_name = 'DEPTNO';
```

-   NUM_DISTINCT : 컬럼 값의 종류 개수(NDV, Number of Distinct Values).
    -   예를 들어 성별 컬럼이변 2
-   DENSITY : = 조건으로 검색할 때의 선택도를 미리 구해 놓은 값. - 히스토그램이 없거나, 있더라도 100% 균일한 분포를 갖는다면, 1 / NUM_DISTINCT 값과 일치
-   AVG_COL_LEN : 컬럼 평균 길이(Bytest)
-   LOW_VALUE : 최소 값
-   HIGHT_VALUE : 최대 값
-   NUM_NULLS : 값이 NULL인 레코드 수

#### 컬럼 히스토그램

= 조건에 대한 선택도는 1/NUM_DISTINCT 공식으로 구하거나 미리 구해 놓은 DENSITY값을 이용하면 된다.

일반적인 컬럼에는 이 공식이 비교적 잘 들어맞지만, 데이터 분포가 균일하지 않은 컬럼에는

선택도를 잘못 구하면 데이터 액세스 비용을 잘못 산정하게 되고, 결국 최적이 아닌 실행계획으로 이어진다. 그래서 옵티마이저는 일반적인 컬럼 통께 외에 히스토그램을 추가로 활용한다.

오라클 12C에서 사용하는 히스토그램 유형

-   도수분포 : 값별로 빈도수 저장
-   높이균형 : 각 버킷의 높이가 동일하도록 데이터 분포 관리
-   상위도수분포 : 많은 레코드를 가진 상위 n개 값에 대한 빈도수 저장
-   하이브리드 : 도수분포와 높이균형 히스토그램의 특성 결합

히스토그램을 수집하려면, 테이블 통계 수집할 때 아래와 같이 method_opt 파라미터를 지정하면 된다.

```sql
begin
  dbms_stats.gather_table_stats('scott', 'emp' , cascade=>false, method_opt=>'for columns ename size 10, deptno size 4');
end ;
/

begin
  dbms_stats.gather_table_stats('scott', 'emp'
        , cascade=>false, method_opt=>'for all columns size 75');
end;
/

begin
  dbms_stats.gather_table_stats('scott', 'emp'
        , cascade=>false, method_opt=>'for all columns size auto');
end;
/
```

```sql
--  all_tab_histograms 뷰에서도 같은 정보를 확인할 수 있다.
select endpoint_value, endpoint_number
from all_histograms
where owner = 'SCOTT'
and table_name = 'EMP'
and column_name = 'DEPTNO'
order by endpoint_value;

ENDPOINT_VALUE ENDPOINT_NUMBER
-------------- ---------------
            10               3
            20               8
            30              14
```

#### 4. 시스템 통계

시스템 통계는 애플리케이션 및 하드웨어 성능 특성을 측정한 것이며, 아래 항목들을 포함한다.

-   CPU 속도
-   평균적인 Single Block I/O 속도
-   평균적인 Multiblock I/O 속도
-   평균적인 Multiblock I/O 개수
-   I/O 서브시스템의 최대 처리량
-   병렬 Slave 평균적인 처리량

시스템 통계는 sys.aux_stats$ 뷰에서 조회할 수 있다.

```sql
select sname, pname, pval1, pval2 from sys.aux_stats$
```

### 7.1.3 비용 계산 원리

인덱스 키값을 모두 = 조건으로 검색할 때는 아래와 같이 인덱스 통게만으로도 쉽게 비용을 계산할 수 있다.

```
비용 =  BLEVEL  인덱스 수직적 탐색 비용
     +  AVG_LEAF_BLOCKS_PER_KEY  인덱스 수평적 탐색 비용
     +  AVG_DATA_BLOCKS_PER_KEY  테이블 랜덤 액세스 비용
```

인덱스 키값이 모두 = 조건이 아닐 때는 아래와 같이 컬럼 통계까지 활용한다.

```
비용 = BLEVEL 인덱스 수직적 탐색 비용
     + LEAF_BLOCKS x 유효 인덱스 선택도  인덱스 수평적 탐색비용
     + CLUSTERING_FACTOR x 유효 테이블 선택도 테이블 랜덤 액세스 비용
```

BLEVEL, LEAF_BLOCKS, CLUSTERING_FACTOR 는 인덱스 통계에서 얻을 수 있고, 유효 인덱스 선택도와 유효 테이블 선택도는 컬럼 통계 및 히스토그램을 이용해 계산한다.

유효 인덱스 선택도란, 전체 인덱스 레코드 중 액세스 조건에 의해 선택될 것으로 예상되는 레코드 비율을 의미한다.

## 7.2 옵티마이저에 대한 이해

### 7.2.1 옵티마이저 종류

비용기반 옵티마이저는 사용자 쿼리를 위해 후보군이 될만한 실행계획들을 도출하고, 데이터 딕셔너리에 미리 수집해 둔 통계정보를 이용해 예상 비용을 산정하고 그중 가장 낮은 비용의 실행계획 하나를 선택하는 옵티마이저다.

RBO(Rull Based) : 옵티마이저는 정해진 규칙만을 사용해서 비용을 산정하기 때문에 지금과 같은 대용량 데이터베이스 환경에서는 전혀 대안이 될 수 없다. (상황에 맞게 최선의 해결책을 제시 못함)

CBO는 ALL_ROWS와 FIRST_ROWS 두 가지 유형의 옵티마이저 모드를 두고 있다.

### 7.2.2 옵티마이저 모드

아래 세가지 옵티마이저 모드 중 하나를 선택하면 된다.

-   ALL_ROWS : 전체 처리속도 최적화
    -   쿼리 결과집합 전체를 읽는 것을 전체로 시스템 리소스를 가장 적게 사용하는 실행 계획 선택
    -   즉 전체 처리속도 최적화
-   FIRST_ROWS : 최초 응답속도 최적화 (Deprecated)
    -   앞쪽 일부만 읽다가 멈추는 것을 전제
-   FIRST_ROWS_N : 최초 N건 응답속도 최적화
    -   앞쪽 N개 로우만 읽고 멈추는 것을 전체로 가장 빠른 실행 게획을 선택한다
    -   alter system 또는 alter session 명령어로 옵티마이저 모드를 설정할때 N으로 지정할 수 있는 값은
        -   1
        -   10
        -   100
        -   1000

아래와 같이 FIRST_ROWS(n) 힌트로 설정할 때는 괄호 안에 0보다 큰 어떤 정수값이라도 입력할 수 있다.

```sql
select /*+ first_rows(30) */ col1, col2, col3, from t where..
```

FIRST_ROWS는 사용자가 데이터를 어느 정도 읽다가 멈출지 모르기때문에 비용산정이 어렵지만 FIRST_ROWS_N은 건수를 지정하였으므로 더 완벽한 CBO모드로 작동한다.

### 7.2.3 옵티마이저에 영향을 미치는 요소

#### 1 SQL과 연산자 형태

결과가 같더라도 SQL을 어떤 형태로 작성했는지 또는 어떤 연산자 (=, in, like, between, 부등호 등)를 사용했는지에 따라 옵티마이저가 다른 선택을 할 수 있고, 쿼리 성능에 영향을 미친다.

#### 2 인덱스, IOT, 클러스터, 파티션, MV등 옵티마이징 팩터

쿼리를 똑같이 작성해도, 인덱스, IOT, 클러스터, 파티션, MV등을 구성했는지, 그리고 어떤식으로 구성했는지에 따라 실행계획과 성능이 달라진다.

#### 3 제약설정

DBMS에 설정한 PK, FK, Check, Not Null 같은 제약들은 데이터 무결성을 보장해 줄뿐만 아니라 옵티마이저가 쿼리 성능을 최적화하는 데 매우 중요한 메타 정보로 활용된다.

#### 4 통계정보

잘 작동하던 프로그램이 어느 날 갑자기 느려졌다면 십중팔구는 통계정보가 원인이다.

-   특정 테이블 통계정보를 갑자기 삭제한다.
-   대량 데이터를 지웠다가 다시 입력하기 직전, 데이터가 없는 상태에서 자동으로 (스케줄링 된 통계수집 패키지에 의해) 통계정보가 수집된다.
-   3년간 갱신하지 않던 특정 테이블 통계정보를 어느 날 갑자기 재수집한다.
-   통계정보 없이 관리하던 테이블에 인덱스를 재생성한다.(오라클 10g 이후 인덱스를 생성하면 인덱스 통계가 자동 수집)
-   테이블이나 인덱스를 재생성하면서 파티션 단위로만 통계정보를 수집한다.(바인드 변수를 사용하면 파티션 통계가 아닌 Global통계가 사용됨)

#### 5 옵티마이저 힌트

가장 절대적인 영향을 미치는 요소는 힌트다. 옵티마이저는 힌트를 명령어로 인식하고 그대로 따른다

만약 힌트가 잘 작동하지 않는다면 아래 경우에 해당할 가능성이 높다.

-   문법적으로 맞지 않게 힌트를 기술
-   잘못된 참조 사용
-   의미적으로 맞지 않게 힌트를 기술
-   논리적으로 불가능한 액세스 경로
-   버그

#### 6. 옵티마이저 관련 파라미터

SQL, 데이터, 통계정보, 하드웨어 등 모든 환경이 같은데도 오라블 버전을 업그레이드하면 옵티마이저가 다르게 작동하는 경험을 흔히 한다.

그런 행동변화는 파라미터 추가 또는 기본값 변경에 기인한다.

```sql
-- 옵티마이저 행동에 영향을 미치는 파라미터 목록 조회 쿼라
select name, value, isdefault, default_value
from v$sys_optimizer_env
```

이 뷰를 통해 확인 가능한 목록은 극히 일부에 지나지 않는다. 종종 변경이 필요한 공식 파라미터 위주로 보여주며 Hidden파라미터 중에는 관리자가 기본값을 변경한 것만 보여준다.

### 7.2.4 옵티마이저의 한계

사람이 실수도 할 수 있고 DBMS 버전별로 다른 실행계획을 생성할 수도 있고 바인드 변수를 사용한 SQL에 컬럼 히스토그램을 활용할 수 없다는 단점도 있다.(OLTP 시스템에서 동작하는 SQL에는 대부분 바인드 변수를 사용)

여러가지 한계와 제약으로 인해 앞으로도 옵티마이저는 불오나전할 수밖에 없다.

### 7.2.5 개발자의 역할

DB세게에서도 불완전한 옵티마이저에만 의존할 것이 아니라 개발자 스스로 옵티마이저가 되어야 한다.

능력이 없어서 맡기는게 아니라 바빠서 맡긴다고 생각

-   필요한 최소 블록만 읽도록 쿼리를 작성한다.
    -   DB 성능은 I/O 효율을 달려있으므로
    -   필요한 컬럼만 조회하고 최종 결과 집합에서간 조인을 수행하게
-   최적의 옵티머이징 팩터를 제공한다.
    -   전략적인 인덱스 구성
    -   DBMS가 제공하는 다양한 기능 활용 (파티션, 클러스터, IOT..)
    -   옵티마이저 모드 설정
-   필요하다면 힌트를 사용해 최적의 액세스 경로로 유도한다.

### 7.2.6 튜닝 전문가가 되는 공부방법

#### 데이터베이스 튜닝이란?

SQL이 병목이나 지연없이 빠르고 안정적으로 수행되도록 조치하는 모든 활동

-   SQL 튜닝 : I/O효율화, DB Call 최소화, SQL 파싱 최소화등
-   DB 설계 : 논리적 데이터 구조 설계, 물리적 저장 구조 설계 등
-   인스턴스튜닝 : Lock/Latch 모니터링 및 해소, 메모리 설정, 프로세스 설정 등

#### 공부해야할 목록

-   옵티마이저가 SQL을 파싱하고 통계정보를 활용해 실행 계획을 생성하는 원리
-   옵티마이저가 쿼리변환 원리를 바탕으로 실행계획을 분석하는 방법
-   옵티마이저가 힌트를 이용해 실행계획을 제어하는 방법
-   옵티마이저가 좋은 실행계획을 생성하도록 유도하기 위한 효과적인 SQL 작성법
-   애플리케이션에서 SQL을 실행할 때 사용하는 프로그래밍 인터페이스
-   SQL을 빠르게 처리할 수 있는 좋은 데이터 구조와 파티션/인덱스 설계
-   정확성과 안정성을 확보할 수 있는 통계정보 수집 정책

SQL이 뷰와 서브쿼리로 복잡하게 얽혀 있다면 튜닝하는 과정도 어렵다. `(힌트로만 해결되면 다행이지만 안된다면 말이 튜닝이지 프로그램 개발에 가깝다.)`

#### SQL 튜닝이 곧 데이터베이스 튜닝

SQL과 좋은 데이터 구조를 설계하는 방법에 관심을 두고 많은 시간과 노력에 기울인다.

# SQL 처리과정과 I/O

## 1.1 SQL 파싱과 최적화

### 1.1.1 구조적, 집합적, 선언적 질의 언어

SQL은 Structured Query Language의 줄임말이다.

원하는 결과집합을 구조적, 집합적으로 선언하지만, 그 결과집합을 만드는 과정은 절차적일 수 밖에 없다.

즉, 프로시저가 필요한데 프로시저를 만들어내는 DBMS 내부 시스템이 SQL 옵티다이저이다.

### 1.1.2 SQL최적화

SQL을 실행하기 전 최적화 과정을 세분화하면 아래와 같다.

-   SQL 파싱 : 사용자로부터 SQL을 전달받으면 SQL파서가 파싱을 진행한다.

    -   파싱 트리 생성 : SQL문을 이루는 개별 구성요소를 분석해서 파싱트리 생성
    -   Syntax 체크 : 문법적 오류가 없는지 확인
    -   Semantic 체크 : 의미상 오류가 없는지 확인(존재하지 않는 테이블 또는 컬럼을 사용했는지, 권한 여부)

-   SQL 최적화 : 옵티마이저가 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성해서 가장 효율적인 하나를 선택 (성능을 결정하는 가장 핵심적인 엔진)

-   로우 소스 생성 : SQL 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅 하는 단계 (로우 소스 생성기가 담당)

### 1.1.3 SQL 옵티마이저

옵티마이저의 최적화 단계

-   사용자 로부터 전달받은 쿼리를 수행하는데 후보군이 될만한 실행계획들을 찾아낸다

-   데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용을 산정

-   최저 비용을 나타내는 실행계획을 선택한다.

### 1.1.4 실행계획과 비용

DBMS에도 SQL 실행경로 미리보기 기능이 있다. `실행 계획 (Execution Plan)`

미리보기 기능을 통해 자신이 작성한 SQL 테이블을 스캔하는지 인덱스를 스캔하는지 인덱스를 스캔한다면 어떤 인덱스인지 확인할 수 있다.

실행계획을 선택하는 근거는 `예상 비용`중 가장 낮은걸 선택한다.

### 1.1.5 옵티마이저 힌트

옵티마이저 힌트를 이용해 데이터 액세스 경로를 바꿀 수 있다.

```sql
-- 주석 기호에 '+'를 붙이면 된다.
SELECT /*+ INDEX(A 고객_PK)*/ 고객명, 연락처, 주소, 가입일시
FROM 고객 A
WHERE 고객ID = '00000008'

-- 권장하지 않는 방식 줄바꿈 오류 발생할 수 있음
SELECT --+ INDEX(A 고객_PK)
고객명, 연락처, 주소, 가입일시
FROM 고객 A
WHERE 고객ID = '00000008'
```

#### 주의사항

힌트 안에 인자를 나열할 땐 ','를 사용할 수 있지만 힌트와 힌트 사이에 사용하면 안된다.

```sql
/*+ INDEX(A A_X01) INDEX(B, B_X03)*/ -> 모두 유효
/*+ INDEX(C), FULL(D)*/ -> 첫 번째 힌트만 유효
```

테이블을 지정할때 스키마명까지 명시하면 안 된다.

```sql
SELECT /*+ FULL(SCOTT.EMP) */ -> 무효
FROM EMP
```

FROM절에 ALIAS를 지정했다면 힌트에도 반드시 ALIAS를 사용해야 한다.

```sql
SELECT /*+ FULL(EMP)*/ -> 무효
FROM EMP E
```

주요 경로만 힌트로 지정하고 나머지는 옵티마이저에게 맡길 수 있다.

```SQL
-- 고객테이블은 옵티마이저가 알아서 판단
SELECT /*+ INDEX(A (주문일자))*/
A.주문번호, A.주문금액, B.고객명, B.연락처, B.주소
FROM 주문 A, 고객 B
WHERE A.주문일자 = :ORD_DT
AND A.고객ID = B.고객ID

-- 옵티마이저가 다른 선택 못하도록 빈틈없이 힌트 지정
SELECT /*+ LENDING(A) USE_NL(B) INDEX(A (주문일자)) INDEX(B 고객_PK)*/
A.주문번호, A.주문금액, B.고객명, B.연락처, B.주소
FROM 주문 A, 고객 B
WHERE A.주문일자 = :ORD_DT
AND A.고객ID = B.고객ID
```

중대한 시스템이라면 후자적용

#### 자주 사용하는 힌트 목록

| 분류            | 힌트             | 설명                                                                                                                |
| --------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------- |
| 최적화 목표     | ALL_ROWS         | 전체 처리속도 최적화                                                                                                |
|                 | FIRST_ROWS(N)    | 최초 N건 응답속도 최적화                                                                                            |
| 액세스 방식     | FULL             | Table Full Scan으로 유도                                                                                            |
|                 | INDEX            | Index Scan으로 유도                                                                                                 |
|                 | INDEX_DESC       | Index 역선으로 스캔하도록 유도                                                                                      |
|                 | INDEX_FFS        | Index Fast Full Scan으로 유도                                                                                       |
|                 | INDEX_SS         | Index Skip Scan으로 유도                                                                                            |
| 조인순서        | ORDERED          | FROM 절에 나영된 순서대로 조인                                                                                      |
|                 | LEADING          | LEADING 힌트 괄호에 기술한 순서대로 조인 ex LEADING(T1 T2)                                                          |
|                 | SWAP_JOIN_INPUTS | 해시 조인 시, BUILD INPUT을 명시적으로 선택 ex.SWAP_JOIN_INPUTS(T1)                                                 |
| 조인 방식       | USE_NL           | NL 조인으로 유도                                                                                                    |
|                 | USE_MERGE        | 소트 머지 조인으로 유도                                                                                             |
|                 | USE_HASH         | 해시 조인으로 유도                                                                                                  |
|                 | NL_SJ            | NL 세미조인으로 유도                                                                                                |
|                 | MERGE_SJ         | 소트 머지 세미조인으로 유도                                                                                         |
|                 | HASH_SJ          | 해시 세미조인으로 유도                                                                                              |
| 서브쿼리 팩토링 | MATERIALIZE      | WITH 문으로 정의한 집합을 물리적으로 생성하도록 유도 ex. WITH /\*_+ MATERIALIZE_\*/ T AS (SELECT...)                |
|                 | INLINE           | WITH문으로 정의한 집합을 물리적으로 생성하지 않고 INLINE 처리하도록 유도 ex. WITH /\*_+ INLINE_\*/ T AS (SELECT...) |
| 쿼리 변환       | MERGE            | 뷰 머징 유도                                                                                                        |
|                 | NO_MERGE         | 뷰 머징 방지                                                                                                        |
|                 | UNNEST           | 서브쿼리 Unnesting 유도                                                                                             |
|                 | NO_UNNEST        | 서브쿼리 Unnesting 방지                                                                                             |
|                 | PUSH_PRED        | 조인조건 Pushdown 유도                                                                                              |
|                 | NO_PUSH_PRED     | 조인조건 Pushdown 방지                                                                                              |
|                 | USE_CONCAT       | OR 또는 IN-List 조건을 OR-Expansion으로 유도                                                                        |
|                 | NO_EXPAND        | OR 또는 IN-List 조건에 대한 OR-Expansion 방지                                                                       |
| 병렬 처리       | PARALLEL         | 테이블 스캔 또는 DML을 병렬 방식으로 처리하도록 유도 ex. PARALLEL(T1 2)                                             |
|                 | PARALLEL_INDEX   | 인덱스 스캔을 병렬방식으로 처리하도록 유도                                                                          |
|                 | PQ_DISTRIBUTE    | 병렬 수행 시 데이터 분배 방식 결정                                                                                  |
| 기타            | APPEND           | Direct-Path Insert 로 유도                                                                                          |
|                 | DRIVING_SITE     | DB Link Remote 쿼리에 대한 최적화 및 실행 주체 지정 (local or remote)                                               |
|                 | PUSH_SUBQ        | 서브쿼리를 가급적 빨리 필터링하도록 유도                                                                            |
|                 | NO_PUSH_SUBQ     | 서브쿼리를 가급적 늦게 필터링 하도록 유도                                                                           |

## 1.2 SQL 공유 및 재사용

### 1.2.1 소프트 파싱 vs 하드 파싱

소프트 파싱 : SGA (System Global Area)의 라이브러리 캐시에 존재하여 곧바로 실행 단게로 넘어가는 것.

하드 파싱 : 찾는 데 실패해 최적화 및 로우소스 구성 단계까지 모두 거치는 것

#### 하드파싱인 이유

옵티마이저가 사용하는 정보

-   테이블, 컬럼, 인덱스 구조에 관한 기본 정보
-   오브젝트 통계 : 테이블 통계, 인덱스 통계, (히스토그램을 포함한) 컬럼 통계
-   시스템 통계 : CPU속도, Single Block I/O 속도, MultiBlock I/O 속도 등
-   옵티마이저 관련 파라미터

하드 파싱은 CPU를 많이 소비하는 정보중 하나. 라이브러리 캐시가 필요한 이유

### 1.2.2 바인드 변수의 중요성

사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 떄부터 이름을 갖는다.

컴파일한 상태로 딕셔너리에 저장되며, 사용자가 삭제하지 않는 한 영구적으로 보관된다.

SQL은 이름이 따로 없고 전체 SQL 텍스트가 이름 역할을한다. 딕셔너리에 저장하지도 않는다.

처음 실행할 때 최적화 과정을 거쳐 동적으로 생성한 내부 프로시저를 라이브러리 캐시에 적재함으로써 재사용한다. (공간 부족시 버렸다가 다시 반복)

#### 공유 가능 SQL

```sql
-- 라이브러리 캐시에서 SQL문 그자체를 이름으로 가지므로 아래는 모두 다른 SQL
SELECT * FROM emp WHERE empno = 7900;
select * from EMP where EMPNO = 7900;
select * from emp where empno = 7900;
SELECT * FROM emp WHERE empno = 7900 ;
SELECT * FROM emp WHERE empno = 7900  ;
select * from scott.emp where empno = 7900;
select /* comment*/ * from emp where empno = 7900;
select /*+ first_rows*/ * from emp where empno = 7900;
```

```java
// 이코드는 statement 방식이라 위 예제처럼 id별 라이브러리 캐시 저장
// id 갯수만큼 하드파싱
String SQLStmt = "SELECT * FROM CUSTOMER WHERE LOGIN_ID = '" + login_id + "'";

// 파라미터 바인딩 방식 사용시 최초 한번 하드파싱
String SQLStmt = "SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?";

// SELECT * FROM CUSTOMER WHERE LOGIN_ID = :1 -> 이렇게 라이브러리 캐시 저장
```

## 1.3 데이터 저장 구조 및 I/O 메커니즘

### 1.3.1 SQL이 느린이유

SQL이 느린이유는 디스크 I/O 때문이다.

### 1.3.2 데이터베이스 저장 구조

테이플스페이스 > 세그먼트 > 익스텐트 > 블록

모든 데이터 블록은 디스크 상에서 몇 데이터파일의 몇번째 블록인지를 나타내느 자신의 고유 주소값을 갖는다 DBA (Data Block Address)

-   블록 : 데이터를 읽고 쓰는 단위
-   익스텐트 : 공간을 확장하는 단위, 연속된 블록 집합
-   세그먼트 : 데이터 저장공간이 필요한 오브젝트(테이블, 인덱션, 파티션, LOB등)
-   테이블스페이스 : 세그먼트를 담는 컨테이너
-   데이터 파일 : 디스크 상의 물리적인 OS파일

### 1.3.3 블록 단위 I/O

데이터 I/O 단위가 블록이므로 특정 레코드 하나를 읽고 싶어도 해당 블록을 통째로 읽는다.

오라클은 기본적으로 8KB크기의 블록을 사용하므로 1Byte를 읽기 위해 8KB를 읽는 셈

테이블 뿐 아니라 인덱스도 블록단위로 데이터를 읽고 쓴다.

### 1.3.4 시퀀셜 액세스 VS 랜덤 엑세스

-   시퀀셜 액세스 : 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식 (리프노드 순차 스캔)

-   각 익스텐트의 첫 번째 블록 뒤에 연속해서 저장된 블록을 순서대로 읽으면 Full Table Scan

-   랜덤 액세스 : 논리적, 물리적 순서를 따르지 않고 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식 (인덱스 타서 리프노드에서 해당 블록으로 접근)

### 1.3.5 논리적 I/O vs 물리적 I/O

#### DB 버퍼 캐시

디스크 I/O가 성능을 결정한다. 매번 디스크에서 블록을 읽는 것은 비효율적으로 자주 읽는 블록은 캐싱함

SGA 구성요소에서 라이브러리 캐시와 마찬가지로 DB 버퍼캐시도 가장 중요한 구성요소 중 하나

SQL 실행 계획, DB 저장형 함수/프로시저 등을 캐싱이 `코드 캐시` 라면 DB 버퍼캐시는 `데이터 캐시`

버퍼캐시에 데이터가 있으면 프로세스가 대기 하지 않음 없으면 버퍼캐시에 탑재후 작업

#### 논리적 I/O vs 물리적 I/O

-   논리적 블록 I/O : SQL을 처리하는 과정에 발생한 총 블록 I/O

-   물리적 블록 I/O : 디스크에서 발생한 총 블록 I/O (버퍼 캐시에서 못찾은 경우)

#### 버퍼캐시 히트율

BCHR(Buffer Cache Hit Ratio) : (캐시에서 곧바록 찾은 블록 수 / 총 읽은 블록 수 ) _ 100
= ((논리적 I/O - 물리적 I/O) / 논리적 I/O) _ 100
= ( 1- (물리적 I/O) / (논리적 I/O)) \* 100

물리적 I/O가 성능을 결정하지만, 실제 SQL성능을 향상하려면 논리적 I/O를 줄여야 한다.

```
물리적 I/O = 논리적 I/O * (100 % - BCHR)
물리적 I/O = 논리적 I/O * (100 - 70)%  = 10000 * 30 % = 3000

-- 논리적 I/O를 1000개로 줄이면?
물리적 I/O = 논리적 I/O * (100 - 30)%  = 1000 * 30 % = 300
```

`논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 곧 SQL 튜닝`

물리적 I/O는 통제 불가능한 외생변수(메모리 증설해서 버퍼 캐시 크기 늘리는것 말고는) 논리적 I/O는 통제 가능한 내생 변수

SQL 트레이스에서 Query + Current가 논리적 I/O

```
ex. Query = 1351677 , Current = 12367, Disk = 601458
BCHR = (1 - (Disk / (Query + Current))) * 100
= (1 - (601458 / (1351677 + 12367))) * 100
= 55.9%
```

BCHR이 높다고 해서 효율적인 SQL은 아님 같은 블록을 비효율적으로 반복해서 읽으면 비율을 높일 수 있기 떄문

### 1.3.6 Single Block I/O vs MultiBlock I/O

-   Single Block I/O : 한 반에 한 블록씩 요청해서 메모리에 적재하는 방식
-   MultiBlock I/O : 한 번에 여러 블록씩 요청해서 메모리에 적재하는 방식

인덱스 이용시 Single Block I/O 사용 소량의 데이터를 읽을 떄 주로 사용하기 떄문

-   인덱스 루트 블록을 읽을때
-   인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
-   인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
-   인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때

많은 데이터 블록을 읽을때 예로 테이블 전체 스캔시 MultiBlock I/O 방식이 효율적

MultiBlock I/O는 캐시에서 찾지 못한 특정 블록을 읽으려고 I/O call할때 디스크 상이 해당 블록과 인접한 블록(같은 익스텐트에 속한 블록)들을 한꺼번에 캐시에 미리 적재하는 방식

멀티블록 중간에도 싱글블록 사용함

### 1.3.7 Table Full Scan vs Index Range Scan

한번에 많은 데이터를 처리하는 집계용 SQL과 배치 프로그램같이 대용량의 경우 Table Full Scan의 효율적

큰 테이블에서 소량 데이터를 검색할때는 Index Range Scan 같이 인덱스를 사용하는 것이 효율적 (많은 데이터를 읽을 때는 Table Full Scan보다 불리함)

인덱스가 항상 옳은 것은 아니며, Table Full Scan이 항상 나쁜것도 아니다.

인덱스는 큰 테이블에서 아주 적은 일부 데이터를 빨리 찾기 위한 도구

예상 카디널리티가 일정량을 넘어서는데도 인덱스로 테이블을 액세스 하지마쇼

### 1.3.8 캐시 탐색 메커니즘

Direct Path I/O (버퍼캐시 사용하지 않고 바로 데이터블록 접근 대량 데이터 사용시 버퍼캐시에 블록을 찾을 경우가 적기 때문 캐시에 적재하는 부담도 크고)를 제외한 모든 블록 I/O는 메모리 버퍼캐시를 경유한다.

-   인덱스 루트 블록을 읽을 때
-   인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
-   인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
-   인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
-   테이블 블록을 Full Scan할때

버퍼캐시에서 블록을 찾을 때 해시 알고리즘으로 버퍼 헤더를 찾고 거기서 얻은 포인터로 버퍼 블록을 액세스

-   같은 입력 값은 항상 동일한 해시 체인에 연결됨 (해시 체이닝)
-   다른 입력 값이 동일한 해시 체인에 연결될 수 있음
-   해시 체인 내에서는 정렬이 보장되지 않음

##### 메모리 공유자원에 대한 엑세스 직렬화

버퍼캐시는 SGA의 구성요소이므로 버퍼캐시에 캐싱된 버퍼블록은 모두 공유 자원이다.

두 개 이상 프로세스가 동시에 접근하려고 할때 줄서기가 가능하도록 지원하는 메커니즘이 `래치(Latch)`다

SGA를 구성하는 서브 캐시마다 별도의 래치가 존재하는데 버퍼캐시에는 캐시버퍼 체인 래치, 캐시버퍼 LRU 체인 래치등이 있다.

캐시버퍼 체인뿐만 아니라 버퍼블록 자체에도 직렬화 메커니즘이 존재한다.(버퍼 Lock)

직렬화 메커니즘에 의한 캐시 경합을 줄이려면 SQL튜닝을 통해 쿼리 일량(논리적I/O) 자체를 줄여야 한다.

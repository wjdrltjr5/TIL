# Result 캐시

Result 캐시는 버퍼 캐시에 위치하지 않고 Shared Pool에 위치하지만 시스템 I/O발생량을 최소화하는데 도움이 되는 기능

오라클은 한번 수행한 쿼리 또는 PL/SQL 함수의 결과값을 Result 캐시에 저장해 두는 기능을 11g 버전부터 제공하기 시작했다.

DML이 거의 발생하지 않는 테이블을 참조하면서 반복 수행 요청이 많은 쿼리에 사용하면 I/O 발생량을 현격히 감소시킬 수 있다.

Result 캐시 메모리는 다음 두가지 캐시 영역으로 구성된다.

-   SQL Query Result 캐시 : SQL 쿼리 결과를 저장
-   PL/SQL 함수 Result 캐시 : PL/SQL 함수 결과값을 저장

result_cache_max_size를 DB관리자가 직접 지정하지 않으면 아래 규칙에 따라 오라클이 자동으로 값을 할당한다.

-   SGA와 PGA를 통합 관리하는 11g방식으로 SGA메모리를 관리하면 memory_target으로 설정된 값의 0.25%를 Result 캐시를 위해 사용한다.

-   sga_target 파라미터를 사용하는 10g방식으로 SGA메모리를 관리하면, 그 값의 0.5%를 Result 캐시를 위해 사용한다.
-   과거처럼 shared_pool_size를 수동으로 설정하면 그 값의 1%를 Result 캐시를 위해 사용한다.

-   어떤 방식을 사용하던 Result 캐시가 사용할 수 있는 최대 크기는 Shared Pool의 75%를 넘지 않도록 오라클이 관리한다.

Result캐시는 SGA의 Shared Pool에 저장된다 SGA영역이므로 모든 세션에서 공유할 수 있고 인스턴스를 재기동하면 초기화된다.

공유 영역에 위치하므로 래치가 필요하다.

```sql
SELECT /*+ RESULT_CACHE */ *
  FROM DUAL;
```

오라클 서버 프로세스는 Result 캐시 메모리를 먼저 찾아보고 캐싱돼있다면 사용 아니면 쿼리를 수행해 결과를 반환하고 캐시에도 저장해둔다.

Result 캐시에서 결과 집합을 찾았을때는 실제 쿼리를 수행하지 않기 때문에 블록 I/O가 전혀 발생하지 않는다.

아래 경우에는 쿼리 결과 집합을 캐싱하지 못한다.

-   Dictionary 오브젝트를 참조할때
-   Temporary 테이블을 참조할 때
-   시퀀스로부터 CURRVAL, NEXTVAL, Pseudo 컬럼을 호출할 때
-   쿼리에서 아래 SQL 함수를 사용할 떄
    -   CURRENT_DATE
    -   CURRENT_TIMESTAMP
    -   LOCAL_TIMESTAMP
    -   SYS-CONTEXT
    -   SYS_GUID
    -   SYSDATE
    -   SYSTIMESTAMP
    -   USERENV

애플리케이션에서는 대부분 바인드 변수를 사용하는데 이때는 각 바인드 변수 값에 따라 개별적으로 결과를 저장한다.

그리고 사용 빈도가 높은 캐시 엔트리들을 보호하고 Result 캐시효율성을 위해 LRU 알고리즘을 사용해 관리한다.

`오라클은 캐싱된 쿼리가 참조하는 테이블에 변경이 발생하면 해당 캐시 엔트리를 무효화시킴으로써 쿼리 결과에 대한 정합성을 보장한다.`

`여러 테이블을 사용한 결과집합일경우 둘 중 하나에 DML이 발생한 순간 캐싱 결과 집합이 무효화 된다`

파티션 테이블을 사용할 경우 변경이 발생한 파티션과 무관한 파티션을 참조하는 쿼리 결과집합까지 무효화 시킨다. (ex. 2월 파티션 DML시 1월도 무효화)

DML이 자주 발생하는 테이블을 참조하는 쿼리나 함수를 캐싱하도록 하는 것은 시스템 부하를 오히려 가중시킬 수도 있다.

DML이 발생할 떄마다 캐시를 관리하는 비용이 추가되고 그 과정에서 래치 경합도 많이 발생하기 때문

-   인라인뷰 캐싱가능
-   With 캐싱 가능
-   union all 사용시 하나의 쿼리만 캐싱 가능
-   where절 서브쿼리 캐싱 불가

Result 캐시는 DW뿐만 아니라 OLTP 환경에서도 잘 활용하면 반복적인 I/O 요청 횟수를 줄이는 데 기여한다.

-   작은 결과 집합을 얻으려고 대용량 데이터를 읽어야 할 때
-   읽기 전용의 작은 테이블을 반복적으로 읽어야 할 떄
-   읽기 전용 코드 테이블을 읽어 코드명칭을 반환하는 함수

사용 자제해야 하는 경우

-   DML이 자주발생하는 테이블
-   함수 또는 바인드 변수를 가진 쿼리에서 입력되는 값의 종류가 많고 그 값들이 골고루 입력될때

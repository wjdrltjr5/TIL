# RAC 캐시 퓨전

데이터베이스 동시 사용자가 많을 때 부하를 분산할 목적으로 시스템마다 다양한 데이터 분산 전략을 사용한다.

-   데이터베이스 서버 간 복제

    -   여러 대의 데이터베이스 서버를 두고 각 서버에서 발생한 트랜잭션 데이터를 상호 복제하는 방식
    -   실시간 동기화가 필요할 때는 복제 과정에서 발생하는 부하 때문에 실제 부하 분산 효과를 얻기 힘들다.

-   업무별 수직 분할

    -   업무영역별로 데이버테이스를 따로 두고 각각 다른 테이블을 관리하며 다른 영역의 데이터는 분산 쿼리를 이용해 조회하는 방식
    -   분산 쿼리로 자주 액세스되는 공통 영영의 범위에 따라 성패가 좌우된다.

-   데이터 구분에 따른 수평 분할
    -   스키마는 같지만 데이터 구분에 따라 데이터베이스르르 따로 가져가는 바잇ㄱ
    -   분할된 데이터 간 의존성이 낮을 때 성공적인 모델이지만 서버 간 데이터 이동이 발생할 때 어떻게 처리할지에 대한 모델관점에서의 방안 마련이 필요하다.

물리적으로 분산시킨 데이터를 논리적으로 다시 통합해 하나의 뷰를 통해 액세스할 수 있도록 데이터베이스를 클러스터링 하는 기법도 몇 가지 형태로 발전을 거듭해 왔다.

데이터베이스를 다시 하나로 통합하고 이를 액세스하는 인스턴스를 여러 개 두는 공유 디스크 방식의 데이터베이스 클러스터링 기법이 도입되기 시작했다.

그중 오라클 RAC 모델은 공유 디스크방식에 기반을 두면서 인스턴스 간에 버러 캐시까지 공유한느 캐피 퓨전 기술로 발전하였다.

RAC의 장점은 고가용성, 확장성, 부하 분산, 데이터를 하나의 데이터베이스에 통합 모델로 관리함으로써 높은 정합성을 유지할 수 있다는 것

단점으로는 튜닝이 잘 되지 않아서 많은 블록 I/O를 일으키는 애플리케이션에서 RAC를 도입한다면 부하 분산은 커녕 단일 인스턴스 환경에서보다 더욱 심각한 성능저하 현상을 겪게된다.

여러 인스턴스에 놓인 프로세스끼리 하나의 데이터를 동시에 읽고 쓰려는 경합이 심하게 발생하기 때문

따라서 RAC 모델 특성상 발생하는 성능 문제들을 해결하려면 캐시 퓨전 프로세싱원리를 이해할 필요가 있다.

RAC는 글로벌 캐시라는 개념을 사용한다 클러스터링 돼 있는 모든 인스턴스 노드의 버퍼 캐시를 하나의 버퍼 캐시로 간주한다.

따라서 필요한 데이터블록이 로컬캐시에 없더라도 다른 노드에 캐싱돼 있다면 디스크 I/O를 일으키지않고 가져와 읽거나 쓸 수 있다.

모든 데이터 블록에 대해 마스터 노드가 각각 정해져 있고, 그 노드를 통해 글로벌 캐시에 캐싱돼있는 블록의 상태와 lock 정보를 관리한다.

마스터 노드는 각 블록 주소의 해시 값에 의해 인스턴스가 기동되는 시점에 동적으로 정해진다.

캐시 퓨전 원리를 간단하게 보면 읽고자 하는 블록이 로컬 캐시에 없을 때 마스터 노드에 전송요청을 하고 마스터 노드는 해당 블록을 캐싱하고 있는 노드에 메시지를 보내 그 블록을 요청했던 노드에 전송하도록 지시하는 방식

만약 어느 노드에도 캐싱돼있지 않다면 직접 디스크에서 읽도록 권한을 부여한다.

RAC 환경에서의 Current 블록은 Shared 모드 Current와 Exclusive모드 Current로 나뉜다.

SCur 상태의 블록은 동시에 여러 노드에 캐싱될 수 있지만 XCur 상태의 블록은 단 하나의 노드에만 존재할 수 있다.

자주 읽히는 데이터 블록을 각 노드가 SCur 모드로 캐싱하고 있을 때 가장 효율적인 상태가 된다.

하지만 그 중 한 노드가 XCur 모드로 업그레이드를 요청하는 순간 다른 노드에 캐싱돼 있던 SCur 블록들은 모두 Null 모드로 다운그레이드된다. 더는 쓸 수 없는 PI블록이 되는것

RAC 노드간 버퍼 캐시를 공유하면서 블록을 서로 주고받는 전송 메커니즘은 아래 5가지로 나뉜다.

-   전송 없는 읽기 : Read with No Transfer
-   읽기/읽기 전송 : Read to Read Transfer
-   읽기/쓰기 전송 : Read to Write Transfer
-   쓰기/쓰기 전송 : Write to Write Transfer
-   쓰기/읽기 전송 : Write to Read Transfer

## 전송 없는 읽기 : Read with No Transfer

A노드에서 K블록을 읽으려고 하는데, 현재 어떤 노드에도 캐싱돼있지 않은 상태

K블록의 SCN은 123이라고 가정

-   K블록을 읽으려고 하는 A노드는 그 블록의 리소스 마스터인 B노드에게 전송 요청을 보낸다. 이때 gc cr request 이벤트에서 대기한다.

-   B노드는 현재 어떤 노드에도 K블록을 캐싱하고 있지 않음을 확인하고 A노드에게 데이터파일에서 직접 블록을 SCur모드로 읽도록 훤한을 부여한다.

-   A노드는 디스크에서 블록을 읽어 로컬 캐시에 캐싱한다.

## 읽기/읽기 전송 : Read to Read Transfer

A노드만 K블록을 SCur 모드로 캐싱한 상태에서 C노드가 같은 K블록을 SCur 모드로 읽으려고 한다.

-   C노드는 리소스 마스터인 B노드에게 k블록에 대한 전송요청을 보낸다. 이때 gc cr request 이벤트를 대기한다.

-   B노드는 현재 K블록을 A노드가 캐싱하고 있음을 확인하고. C노드에 블록을 전송해 주도록 A노드에게 지시한다.

-   A노드는 C노드에게 블록을 전송해 준다.

-   C노드는 블록을 성공적으로 전송받아 SCur모드로 캐싱하게 되었음을 알리려고 마스터 노드인 B에게 메시지를 보낸다.

## 읽기/쓰기 전송 : Read to Write Transfer

A와 C노드 모두 k블록을 SCur 모드로 캐싱하고 있다. 이제 C노드가 K블록을 XCur 모드로 업그레이드 하려고 한다. 해당블록 갱신을 위해

-   마스터 노드인 B에게 K블록을 XCur 모드로 업그레이드 하겠다고 요청한다.

-   B노드는 현재 K블록을 A노드도 캐싱하고 있음을 확인하고 Null 모드로 다운그레이드 하도록 지시한다.

-   A노드는 C노드에게 Null 모드로 다운그레이드 했음을 알린다.

-   C노드는 K블록을 XCur 모드로 업그레이드하고 그 결과를 마스터 노드 B에게 알린다. 이때 A노드에 캐싱돼 있던 블록이 Null 모드로 다운그레이드 된 사실까지 함께 알려준다.

K블록 SCN 123 -> 154로 증가

## 쓰기/쓰기 전송 : Write to Write Transfer

현재 A노드는 k블록을 Null 모드로 갖고 있고, C노드는 XCur 모드로 갖고 있다. C노드가 갖고 있는 Current버전의 SCN은 154로 증가

데이터파일에 있는 블록 SCN은 아직 123이므로 Dirty 버퍼 상태다. 이때 A노드가 K블록을 XCur 모드로 읽으려고 한다.

-   마스터 노드인 B에게 K블록을 XCur 모드로 요청한다.
-   B노드는 현재 K블록을 C노드가 XCur 모드로 캐싱하고 있음을 확인하고, A노드에게 보내 주도록 지시한다.
-   C노드는 A노드에게 블록을 전송하고 자신이 갖고 있던 블록은 Null 모드로 다운그레이드 한다. C노드가 갖고있던 XCur 블록은아직 커밋되지 않아 Lock이 걸린 상태일 수 있다.

-   A노드는 K블록을 XCur모드로 캐싱하게 됐음을 B노드에게 알린다.

`다른 인스턴스가 갱신 중인 블록을 읽고자 할 떄 로우 Lock이 해제될 때까지 기다리지 않고 로우 Lock이 설정된채 블록을 주고받는다.`

RAC에서는 디스크 동기화 없이 로우 Lock이 설정된 채로 버퍼 캐시간 블록 전송이 가능해진 것

A노드가 XCur 모드로 K블록을 얻고 변경을 가하므로 블록 SCN은 154 -> 168

## 쓰기/읽기 전송 : Write to Read Transfer

현재 A노드는 K블록을 XCur모드로 갖고 있고, C노드는 Null모드로 갖고 있다.

A노드가 갖고있는 Current 버전의 SCN은 168로 증가되었고, 데이터파일에 있는 블록 SCN은 여전히 123 이므로 Dirty 버퍼 상태다.

이때 C노드가 K블록을 SCur 모드로 읽으려고 한다.

-   마스터 노드인 B에게 K블록을 SCur 모드로 요청한다.

-   B노드는 현재 K블록을 A노드가 XCur 모드로 캐싱하고 있음을 확인하고 C노드에게 보내 주도록 지시한다.

-   A노드는 C노드에게 블록을 전송하고 자신이 갖고있던 블록은 SCur모드로 다운그레이드한다.

-   C노드는 K블록을 SCur 모드로 캐싱하게 됐음을 B노드에게 알려준다. 이때 A노드에 캐싱돼있던 블록이 SCur 모드로 다운그레이드 된 사실까지 함께 알려준다.

쓰기/읽기 캐시 퓨전에서는 3번과 4번 과정이 좀더 복잡하다. K블록의 커밋 여부에 따라 다르다

아직 커밋되지 않았다면 Current 블록을 전송하지 않고 계속 CR Copy를 만들어 전송한다.

C노드는 읽기 작업을 원하는 것이므로 굳이 Current 블록을 보낼 필요는 없다.

현재 A노드에서 갱신이 진행중이므로 Current 블록을 보내면 언젠가 다시 가져와야 하는 부담때문에 그렇게 처리하는 것

K블록이 커밋된 상태더라도 바로 Current 블록을 보내지 않는다. 처음에는 CR Copy만을 전송하다가 일정 횟수 이상 요청이 반복적으로 들어오면 그때 Current 블록을 보내준다.

Current 블록을 보내주려면 XCur모드를 SCur모드로 다운그레이드 해야한는데 곧바로 갱신이 발생한다면 다시 업그레이드 해야 하기 때문

그때는 SCur블록을 가져갔던 다른 노드도 모두 Null모두로 다운그레이드 해야 하므로 자주 발생한다면 RAC 부하가 증가한다.

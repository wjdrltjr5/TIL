# SQL 트레이스

SQL을 튜닝할때 가장 많이 사용되는 강력한 도구는 SQL 트레이스다.

앞서 살펴 본 사전 실행계획과 AutoTrace결과 만으로 부하원인을 찾을 수 없을때 SQL 트레이스를 통해 쉽게 찾아낼 수 있다.

SQL 트레이스를 설정하는 여러가지 방법

## 자기 세션에 트레이스 걸기

현재 자신이 접속해 있는 세션에만 트레이스를 설정하는 방법

```sql
alter session set sql_trace = true;
select * from emp where empno = 7900;
select * from dual;
alter session set sql_trace = false;

```

위와 같이 트레이스를 설정하고 SQL을 수행한 후 user_dump_dest 파라미터로 지정된 서버 디렉토리 밑에 트레이스 파일(.trc)이 생성된다. 가장 최근에 생성 또는 수정된 파일을 찾아 분석하면 되는데

파일찾기가 어렵다면 다음 쿼리를 활용 (P165)

## TKProf 유틸리티

트레이스 파일의 내용을 그래도 분석하기란 쉽지 않다.

TKProf 유틸리티를 사용하면 트레이스 파일을 보기 쉽게 포맷팅해 준다. 아래처럼 유닉스 쉘이나 도스 프롬프트 상에서 tkprof 를 치면 사용법을 확인할 수 있다

TKProf를 통해 생성된 report.prf 파일을 열고 결과를 확인하면 된다.

## 트레이스 결과 분석

```sql
SELECT * FROM emp WHERE empno = 7900;
```

| Call      | Count | CPU      | Elapsed  | Disk  | Query | Current | Rows  |
| --------- | ----- | -------- | -------- | ----- | ----- | ------- | ----- |
| Parse     | 1     | 0.00     | 0.00     | 0     | 0     | 0       | 0     |
| Execute   | 1     | 0.00     | 0.00     | 0     | 0     | 0       | 0     |
| Fetch     | 2     | 0.00     | 0.00     | 0     | 2     | 0       | 1     |
| **Total** | **4** | **0.00** | **0.00** | **0** | **2** | **0**   | **1** |

Misses in library cache during parse: 1

Optimizer mode: ALL_ROWS

Parsing user id: 61

-   Call : 커서 상태에 따라 Parse, Execute, Fetch 세 개의 Call로 나누어 각각의 대한 통계정보를 제공한다.

    -   Parse : 커서를 파싱하고 실행 계획을 생성하는 데 대한 통계
    -   Execute : 커서의 실행 단계에 대한 통계
    -   Fetch : 레코드를 실제로 Fetch하는 데 대한 통계

-   Count : Parse, Execute, Fetch 각 단계가 수행된 횟수
-   CPU : 현재 커서가 각 단계에서 사용한 cpu time
-   Elapsed : 현재 커서가 각 단계를 수행하는 데 소요된 시간
-   Disk : 디스크로부터 읽은 블록 수
-   Query : Consistent 모드에서 읽은 블록 수
-   Current : Current 모드에서 읽은 블록 수
-   Rows : 각 단계에서 읽거나 갱신한 처리 건수

| Step | Operation                       | Details                                      |
| ---- | ------------------------------- | -------------------------------------------- |
| 1    | TABLE ACCESS BY INDEX ROWID EMP | (cr=2 pr=0 pw=0 time=80 us)                  |
| 1    | INDEX UNIQUE SCAN EMP_PK        | (cr=1 pr=0 pw=0 time=44 us) (object id 5278) |

-   Rows : 각 수행 단계에서 출력된 로우 수를 의미한다.
-   cr : Consistent 모드 블록 읽기
-   pr : 디스크 블록 읽기
-   pw : 디스크 블록 쓰기
-   time : 소요시간

`중요한 점은 부모는 자식 노드의 값을 누적한 값을 갖는다는 점 위에서 emp테이블의 액세스 단계는 cr = 2이고 자식 노트인 emp_pk 인덱스 액세스 단계는 cr=1이므로 인덱스를 읽고 난 후 테이블을 액세스하는 단게에서 순수하게 일어난 cr 개수는 1이다.`

## 이벤트 트레이스

SQL 트레이스를 걸 수 있는데 방법은 다음과 같다.

```sql
alter session set events '10046 trace name context forever, level 1';

alter session set events' 10046 trace name context off';
```

이 방식을 사용하면 레벨 설정을 통해 바인드 변수와 대기 이벤트 발생 현황까지 수집할 수 있다.

설정할 수 있는 레벨 값은 1, 4, 8, 12 이며 레벨1은 지금까지 살펴본 일반적인 SQL 트레이드와 같다.

레벨 4 또는 12로 설정했을 때 트레이스 파일을 열어보면 아래처럼 바인드 변수에 대한 정보를 확인할 수 있다.

레벨을 8 또는 12로 설정하면 SQL 수행 도중 대기 이벤트가 발생할 때마다 트레이스 파일에 정보들이 로그처럼 계속 기록된다.

이를 TKProf로 포맷팅하면 각 이벤트 별로 집계된 정보를 볼 수 있다.

이벤트 분석을 통해 SQL이 빨리 수행되지 못ㄱ하게 한 병목 요인을 쉽게 파악할 수 있다.

10046 트레이스를 걸 떄 레벨을 4 이상으로 설정하면 트레이스 파일이 매우 급격하게 커지므로 주의가 필요하다.

계속 모니터링 하다가 적정시점에 정시시키는 것을 잊지 말아야 한다.

## Elapsed time = CPU time + Wait time

대기 이벤트 정보는 쿼리 병목 원인을 찾아내는데 결정적인 역할을 한다.

Elapsed Time 은 CPU time과 Wait time의 합으로 정의할 수 있다.

```
Elapsed Time = Cpu time + Wait time
             = Response 시점 - Call 시점
```

`Elapsed time 은 Call 단위로 측정`이 이루어진다. 사용자(App or Was)로부터 데이터베이스 Call을 받은 순간부터 Response를 보내는 순간까지의 소요시간을 말한다.

애플리케이션 커서 캐싱 기법을 사용하지 않는 한 하나의 select문을 수행하는 동안 최소 3번의 Call이 발생하고 DML 문은 단 2번의 Call이 발생한다.

-   SELECT 문 : Parse Call + Execute Call + Fetch Call(1회 이상)
-   DML 문 : Parse Call + Execute Call

SELECT 문에서 다량의 데이터를 사용자에게 전송할 때는 Fetch Call이 전송 레코드 건수 / Array Size 만큼 여러번 발생한다.

`하나의 SQL을 수행할 떄의 Total Elapsed time은 수행시 발생하는 모든 Call 의 Elapsed time을 더해서 구한다.`

```sql
set timing on
set arraysize 100
alter session set events '10046 trace name context forever, level 8',
select * from big_table where id <= 1000;

경과 : 8.71초
```

위 쿼리 총 소요시간은 8.71초 이지만 SQL 트레이스에서 Call 통계를 보면 DB구간에서의 총 소요시간은 0.07초에 불과하다.

| Call      | Count  | CPU      | Elapsed  | Disk   | Query  | Current | Rows     |
| --------- | ------ | -------- | -------- | ------ | ------ | ------- | -------- |
| Parse     | 1      | 0.00     | 0.02     | 0      | 0      | 0       | 0        |
| Execute   | 1      | 0.00     | 0.00     | 0      | 0      | 0       | 0        |
| Fetch     | 11     | 0.03     | 0.05     | 18     | 39     | 0       | 1000     |
| **Total** | **13** | **0.03** | **0.07** | **18** | **39** | **0**   | **1000** |

13번 발생한 Call 각각의 시간을 다 합쳐서 0.07초 이지만 나머지 시간은 애플리케이션으로 부터 추가 Call을 기다리면서 Idle 상태로 대기한 것

또한 CPU time과 Elapsed time 간 시간차는 0.07초간 일하는 동안에도 실제로 프로세스가 CPU를 점유하고 원할하게 일을 진행한 시간을 0.03초에 불과하다.

나머지 0.04초는 대기 상태에 빠졌던 것으로 이해하면 된다. SQL 수행전 이벤트 트레이스 레벨을 8로 설정하였으므로 트레이스 파일을 확인하면 총 소요시간과의 갭이 발생했던 이유를 볼 수 있다.

SQL\*Net message from client 대기 이벤트는 Idle 이벤트로서 오라클 서버 프로세스가 사용자에게 결과를 전송하고 다음 Fetch Call이 올 때 까지 대기한 시간을 더한 값이다.

## 다른 세션에 트레이스 걸기

성능 문제가 발생한 튜닝 대상 SQL 목록을 이미 확보했다면 앞에서처럼 자신의 세션에 트레이스를 걸어 문제 SQL의 트레이스 정보를 수집해 분석을 진행하면 된다.

하지만 아직 튜닝 대상 SQL이 수집되지 않은 상황이라면 커넥션 Pool에 놓인 세션 또는 시스템 레벨로 트레이스를 걸어 SQL 수행 정보를 수집해야 한다.

또는 특정 세션에서 심한 성능부하를 일으키고 있다면 이미 수행 중인 그 세션에 트레이스를 걸어야 하는데 그럴 때 사용할 수 있는 방법들이 제공되며 버전에 따라 다르다.

## Service, Module, Action 단위로 트레이스 걸기

n-Tier 구조의 애플리케이션은 WAS 에서 DB와 미리 맺어놓은 커넥션 Pool에서 세션을 할당 받기 때문에 특정 프로그램 모듈이 어떤 세션에서 실행될지 알 수 없고,

한 모듈 내에서 여러 SQL을 수행할 때 각각 다른 세션을 통해 처리될 수도 있다. 이런 환경에서 성능 문제가 발생한 특정 모듈이나 SQL에 대해서만 트레이스를 거는 것은 매우 어려운 작업이다.

하지만 10g 부터 service, module, action별로 틀레이스를 설정하고 해제할 수 있는 dbms_monitor 패키지가 소개되면서 불편함이 모두 사라졌다.

```sql
show parameter service_name
```

자세한 내용 177P

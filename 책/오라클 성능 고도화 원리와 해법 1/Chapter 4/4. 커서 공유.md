# 커서 공유

## 커서란?

커서는 상황에 따라 여러 의미로 사용된다.

-   공유커서(shared cursor) : 라이브러리 캐시에 공유돼있는 Shared SQL Area'

-   세션커서(session cursor) : Private SQL Area에 저장된 커서
-   애플리케이션 커서(application cursor) : 세션 커서를 가리키는 핸들

## 공유 커서 (shard cursor)

JAVA, PL/SQL 등에서 SQL을 수행하면 서버 프로세스는 SQL이 라이브러리 캐시에 공유돼있는지 확인하고 없다면 최적화 과정을 통해 실행계획을 만들고 라이브러리 캐시에 공유한다.

이렇게 라이브러리 캐시에 공유돼 있는 Shared SQL Area를 커서 라고 부른다.

## 세션 커서(session cursor)

라이브러리 캐시에 공유돼 있는 커서를 실행할 때는 우선 PGA 영역에 메로리를 할당한다. 이를 Private SQL Area 라고 한다.

Private SQL Area는 두개로 나뉜다.

-   Persistent Area
-   Runtime Area

Shared SQL Area를 읽어 커서를 실행하는 데 필요한 정보들을 Private SQL Area에 담고 공유 커서를 가리키는 포인터를 유지한다.

그리고 커서의 상태(open, bound, execute, close 등) 정보도 관리한다. 커서를 실행하기 위한 이런 준비과정을 커서를 오픈한다 라고 표현

PGA에 저장된 커서 정보를 또한 커서라고 부른다.

라이브러리 캐시에 공유돼 있는 커서는 SQL을 수행하는 데 필요한 루틴을 정의한 것 (즉 클래스 상태)

그 루틴을 정의하고 클래스를 디자인한 것은 옵티마이저다. 커서 오픈 즉 라이브러리 캐시에 공유돼 있는 커서를 PGA로 인스턴스화

오라클에서도 커서를 오픈하면 라이브러리 캐시에 공유돼있는 커서를 인스턴스화함으로써 PGA에 커서를 위한 메모리 공간을 할동한다.

## 애플리케이션 커서

PGA에 있는 커서를 핸들링하려면 JAVA와 같은 클라이언트 애플리케이션에도 리소스를 할당해야 한다. 이 또한 커서라는 용어를 사용한다.

## 커서 공유

오라클에서 커서를 공유한다는 표현을 자주 사용하는데 여기서 말하는 커서는 라이브러리 캐시의 공유커서를 말한다.

세션 커서, 애플리케이션 커서를 다른 프로세스와 공유할 수 없다. (PGA 영역이니까)

라이브러리 캐시에 공유돼 있는 커서의 수행 통계를 v$sql을 통해 조회해 볼수 있다.

v$Ssql 통계

-   parse_calls : 라이브러리 캐시에서 SQL 커서를 찾으려는 요청 횟수
-   loads : 하드파싱을 거친 SQL 실행 계획을 라이브러리 캐시에 적재한 횟수
-   executions : sql을 수행한 횟수
-   invalidations : 커서가 무효화된 횟수, 커서가 참조하고 있는 오브젝트에 중요한 변화가 일어났음을 의미함

하드파시은 단 한번 일어난다. (pares_call = 3 , loads = 1) Shared Pool을 모두 비우고 테스트를 시작했으므로 SQL을 첫 번째 수행할떄 하드파싱이 발생

공유돼 있던 커서는 어떤 이유에서건 무효화 될 수 있다. 커서가 참조하고있던 오브젝트에 컬럼이 추가/삭제되거나 새로운 인덱스 만들어지거나 오브젝트 통계를 새로 수집하는 등의 DDL문이 수행되는 경우

커서가 공유되려면 커서를 식별하는 키 값이 같아야 하는데 라이브러리 캐시에서 커서를 식별하기 위해 사용되는 키 값은 `SQL 문장 그 자체다`

따라서 SQL문 중간에 작은 공백문자 하나만 추가하더라도 서로 다른 SQL문장으로 인식해 sql_id를 발급받게 된다. 즉 커서가 공유되지 않는다

## Child 커서를 공유하지 못하는 경우

같은 테이블이 각각의 스키마에 생성돼 있다면 이를 참조하는 동일 쿼리를 각각 로그인 해서 수행할때 별도의 Child 커서를 생성한다.

Stored Object(테이블, 인덱스, 함수, 프로시저, 패키지)는 생성될 떄부터 유일하게 식별 가능한 이름이 부여되므로 Child 오브젝트를 사용할 필요가 없다.

SQL커서처럼 실행시점에 생성돼서 인스턴스가 떠있는 동안에만 존재하는 Transient Object는 이름을 따로 지정하지 않고 문장을 구성하는 전체 문자열 그대로가 LCO를 식별하는 이름 역할을 한다.

즉 Transient Object는 SQL마다 하나의 Parent 커서를 가지며 Child 커서는 여러 개일 수 있다. 실제 수행에 필요한 정보는 Child 커서에 담기므로 적어도 한 개의 Child 커서를 갖는다.

모든 SQL문에 e대해 많은 Child 커서를 갖는 구조는 라이브러리 캐시 효율이 나빠진다. (library cache 래치 경합 증가)

하나의 SQL문장이 여러개의 Child 커서를 가지는 경우

-   SQL에서 참조하는 오브젝트명이 같지만 SQL을 실행한 사용자에 따라 다른 오브젝트를 가리킬떄
-   참조 오브젝트가 변경돼 커서가 무효화 되면 이후 그 커서를 처음 사용하려는 세션에 의해 다시 하드파싱돼야 하는데, 특정 세션이 아직 기존 커서를 사용중일 때
-   옵티마이저 모드를 비롯해 옵티마이저 관련 파라미터가 다를 때
-   입력된 바인드 값의 길이가 크게 다를 때
-   NLS 파라미터를 다르게 설정했을때
-   SQL 트레이스를 활성화 했을때

## Parent 커서를 공유하지 못하는 경우

SQL 문장이 조금이라도 차이가있는경우

-   공백 문자 또는 줄바꿈
-   대소문자 구분
-   테이블 Owner 명시
-   주석
-   옵티마이저 힌트 사용
-   조건절 비교 값

개발 초기에 SQL 작성 표준을 정해 이를 준수하도록 해야 한다, 조건절에 바인드 변수를 사용하지 않고 서로 다른 Literal값으로 사용할경우 사용할 때마다 하드파싱 발생

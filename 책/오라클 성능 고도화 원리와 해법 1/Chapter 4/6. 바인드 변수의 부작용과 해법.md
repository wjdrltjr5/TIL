# 바인드 변수의 부작용과 해법

SQL 수행절차

-   Parser의 SQL Parsing

-   Optimizer의 최적화

-   Row-Source Generator 의 프로시저 만들기

-   SQL엔진의 실행

바인드 변수를 사용하면 최초 수행할 때 최적화를 거친 실행계획을 캐시에 적재하고 실행시점에는 그것을 그대로 가져와 값을 다르게 바인딩하면서 반복 재사용하게 된다.

변수를 바인딩하는 시점이 (최적화 시점보다 나중인) 실행시점이라는 사실을 아는 것이 중요하다. (SQL을 최적화하는 시점에 조건절 컬럼의 데이터 분포도를 활용하지 못하는 문제접을 갖는다.)

바인드 변수를 사용할 때는 정확한 컬럼 히스토그램에 근거하지 않고 카디널리티를 구하는 정해진 계산식에 기초해 비용을 계산하므로 최적이 아닌 실행계획을 수립할 가능성이 높다.

바인드 변수를 사용하면 컬럼 히스토그램을 제대로 활용하지 못할 뿐만 아니라 파티션 테이블을 쿼리할 때 파티션 레벨 통계정보를 이용하지 못하게 된다.

## 바인드 변수 Peeking

Peeking이라는 단어가 의미하듯 이 기능은 SQL이 첫번째 수행되면서 하드파싱될 때 함께 딸려 온 바인드 변수 값을 살짝 훔쳐보고 그 값에 대한 컬럼 분포를 이용해 실행계획을 결정하는 것(이러면 어제까지 잘돌던 프로그램이 어느날 갑자기 느려질 수 있는 위험한 기능)

선택도가 높은 데이터를 인덱스 경유해 액세스할 때면 성능이 오히려 느려진다.

-   인덱스를 통해 얻는 ROWID가 엄청 많아짐
-   결국 테이블 블록을 계속 랜덤하게 읽는 Random I/O가 발생
-   이럴 바엔 애초에 Table Full Scan이 더 빠름

여튼 이런저런 연유로 현재 대부분의 운영시스템에서는 실행계획기 자꾸 바뀌어 이 기능을 비활성화 시킨 상태에서 운영한다.

## 적응적 커서 공유

입력된 바인드 변수 값의 분포에 따라 다른 실행계획이 사용되도록 하는것

-   쿼리가 처음 수행되는 시점에 선택도가 매우 높은 서울시가 입력되면 테이블을 Full Scan 하는 실행계획을 수립한다

    -   이를 1번 커서라고하자 이후 '서울시'가 입력되면 1번 커서를 재활용한다.

-   선택도가 매우 낮은 제주도가 입력되면 컬럼 히스토그램을 본 후 인덱스를 이용하는 새로운 실행계획을 만든다. 2번 커서라고 하자.

    -   이제 캐시에는 두 개의 Child 커서가 동시에 캐싱돼있다.

-   서울시만큼 선택도가 높은 경기도가 입력되면 히스토그램을 확인 후 1번커서를 사용한다.

-   제주도와 비슷한 선택도를 갖는 강원도가 입력되면 히스토그램을 확인후 2번커서를 사용한다.

이 기능이 작동하려면 기본적으로 조건절 컬럼에 히스토그램이 생성돼 있어야 한다.

옵티마이저가 바인드 변수 값에 따라 실행계획을 달리 가져갈 필요가 있다고 판단되는 SQL 커서에 대해서 이 기능이 활성화된다.

오라클 11g에서는 기존에는 제주도가 입력되었을때 곧바로 새로운 실행계획을 만들었지만 지금은 일단 서울시를 기반으로 만들어지 기존 커서를 실행해보고 성능이 나쁘다고 판단되면 BindAware모드로 전환한다.

일단 실행해 보고 안좋으면 바꾼다의 접근은 안정적 운영과는 조금 거리가 멀다.

### ✅ 버전별 동작 차이

| 버전     | 동작 방식 요약                                                                                                                              |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| **11g**  | - 처음엔 Bind-Insensitive 커서로 실행<br>- 성능이 나쁘다고 판단되면 Bind-Aware로 전환<br>- 기존 커서 재사용 후 새 커서 생성                 |
| **12c**  | - 히스토그램과 SQL Plan Directive 기반으로 더 정교한 판단<br>- 히스토그램이 없더라도 플랜 변경 가능<br>- Bind-Aware 진입 시점 개선          |
| **19c+** | - 초기 실행 시점부터 Bind-Aware 진입 가능<br>- 옵티마이저가 **히스토그램, 선택도 등으로 실행계획 분기**<br>- 더 빠르고 안정적인 전환 구현됨 |

오라클은 적응적 커서 공유와 관련된 수행 통계를 관찰할 수 있도록 세 가지 뷰를 제공한다.

| 뷰 이름                | 설명                         |
| ---------------------- | ---------------------------- |
| `v$sql_cs_statistics`  | 커서별 Adaptive 공유 통계    |
| `v$sql_cs_selectivity` | 바인드 변수 값의 선택도 통계 |
| `v$sql_cs_histogram`   | 히스토그램 기반 커서 통계    |

## 입력 값에 따라 SQL 분리

인덱스 액세스 경로로서 중요하고 조건절 컬럼의 데이터 분포가 균일하지 않은 상황에서 바인드 변수 사용에 따른 부작용을 피하려면 바인딩 값에 따라 실행계획을 분리하는 방안을 고려해야 한다.

```sql
select /*+ FULL(a) */ *
  from 아파트매물 a
 where :CITY in ('서울시', '경기도')
   and 도시 = :CITY
union all
 select /* INDEX(a IDX01) */ *
  from 아파트매물 a
 where :CITY not in ('서울시', '경기도')
   and 도시 = :CITY
```

주의할점은 OLTP 시스템에서 union all을 이용해 SQL을 지나치게 길게 작성하면 오히려 라이브러리 캐시 효율을 떨어뜨리게 된다는 사실

union all을 사용해 많은 SQL을 결합했을 경우 처음 하드파싱 시점에 옵티마이저는 여러개의 SQL을 최적화 해야하고 그만큼 Shared Pool에서 많은 공간을 차지하게 된다.

그중 몇개만 주로 사용된다면 나머지는 불필요하게 공간만 낭비하는 결과를 초래한다.

매번 수행할 때마다 긴 테스트를 파싱하면서 Syntax를 체크하고 파싱트리를 만들어 Semantic을 체크하는 과정을 반복하면 Parse 단계에서 CPU를 과도하게 소비할 것임을 뻔하다.

CPU 사용률을 높이고 네트워크를 통한 메시지 전송량도 증가하므로 좋을 게 없다.

## 예외적으로 Literal 상수값 사용

조건절 컬럼 값 종류가 소수일 때는 바인드 변수보다 오히려 Literal 상수를 사용하는 게 나은 선택일 수 있다.

하지만 OLTP 환경이라면 특별한 몇몇 경우를 제외하고는 반드시 바인드 변수를 사용해야만 한다.

# PL/SQL 함수의 특징과 성능 부하

## PL/SQL 함수의 특징

PL/SQL은 인터프리터 언어이므로 그것으로 작성한 함수 실행 시 매번 SQL 실행엔진과 PL/SQL 가상머신 사이에 컨텍스트 스위칭이 일어난다.

C++, Java 와같은 일반 프로그래밍 언어에서는 될 수 있으면 함수/프로시저를 이용해 잘게 모듈화 공용화하는 것이 권장사항이지만 PL/SQL 함수와 프로시저를 그런식으로 활용하면 안되는 이유다.

## Recursive Call을 포함하지 않는 함수의 성능 부하

오라클 내장 함수 to_char와 사용자 정의 함수를 사용할때의 수행시간을 비교하면 사용자 정의 함수가 Recursive Call 없이 컨텍스트 스위칭 효과만으로 5~10배 정도 느려진다.

## Recursive Call을 포함하는 함수의 성능 부하

대개의 사용자 정의함수에는 Recursive Call을 포함한다. 네트워크 트래픽을 발생시키는 User Call에 비하면 비용이 적지만

Recursive Call도 매번 Execute Call과 Fetch Call을 발생시키기 때문에 대량의 데이터를 조회하면서 레코드 단위로 함수를 호출하도록 쿼리를 작성하면 성능이 극도로 나빠진다.

대용량 조회 쿼리에서 함수를 남용하면 읽는 레코드 수만큼 건건이 함수 호출이 발생해 성능이 극도로 나빠진다.

따라서 사용자 정의함수는 소량의 데이터 조회시에만 사용하거나, 대용량 조회 시에는 부분범위처리가 가능한 상황에서 제한적으로 사용해야 한다.

그리고 성능을 위해서라면 가급적 조인 또는 스칼라 서브쿼리 형태로 변환하려고 노력해야 한다.

## 함수를 필터 조건으로 사용할 때 주의사항

함수를 where절에서 필터 조건으로 사용할 떄도 각별한 주의가 필요하다 조건절과 인덱스 상황에 따라 함수 호출횟수가 달라지기 때문이다.

인덱스를 사용하지 않고 Full Scan할때는 스캔하면서 읽은 전체 건수만큼 하수 호출이 일어난다.

## 함수와 읽기 일관성

PL/SQL은 가장 기본적인 문장수준 읽기 일관성이 보장되지 않는 것으로서, `함수 내에서 수행되는 Recursive 쿼리는 메인 쿼리의 시작지점과 무관하게 그 쿼리가 수행되는 시점을 기준으로 블록을 읽기 때문에 생기는 현상`

일반 조인문 또는 스칼라 서브쿼리를 사용할 때만 완벽한 문장수준 읽기 일관성이 보장된다.

이런 읽기 일관성 문제는 프로시저, 패키지, 트리거를 사용할 때도 공통적으로 나타나는 현상이다.

함수/프로시저를 잘못 사용하면 성능을 떨어뜨릴 뿐 아니라 데이터 정합성까지 해칠 수 있으므로 주의해야 한다.

## 함수의 올바른 사용 기준

PL/SQL을 사용하면 오라클 Sequence 오브젝트를 사용하지 않는 한 Lock 경합을 최소화하면서 더 빠르게 채번하는 방법은 없다.

PL/SQL 함수를 사용하지 않으면 select, insert, update를 날리면서 채번했을 텐데 이는 User Call을 발생시키는 것이므로 Recursive Call보다 현저히 느리고 Lock경합시 대기 시간도 더 길어진다.

함수/프로시저를 사용하지 않았을때 결국 User Call을 발생시키도록 구현해야 한다면, 오라클 함수/프로시저를 사용하는 편이 더 나은 선택이다.

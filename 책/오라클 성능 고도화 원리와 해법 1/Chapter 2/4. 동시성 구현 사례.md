# 동시성 구현 사례

## 일련번호 채번 동시성 높이기

Locking을 최소화 하면서 채번 테이블로부터 일련번호를 채번하고자 할 때 사용할 수 있는 사례

일련번호를 채번하고자 할 때 가장 좋은 선택은 DBMS가 제공하는 Sequence를 이용하는 것

Sequence를 사용할 수 없는 경우의 사용방식

-   데이터가 삽입되는 시점의 실시간으로 현재의 MAX값 + 1
    -   동시에 진행되더라도 inset시 무결성 제약에서 위배되므로 예외처리를 이용하여 동시성 제어할 수 있음
-   MAX값을 관리하는 별도의 채번 테이블에서 값을 가져오기
    -   채번 후 다음 처리로 진행하기 전에 채번 테이블 값을 1만큼 증가시키는 갱신을 수행해야하는 어려움이 있다.
    -   롤백이 되는 경우 or 동시성
    -   커밋하지 않고 종료시 Lock 해제가 안되는 경우
    -   다행이 오라클은 메인 트랜잭션에 영향을 주지 않고 서브 트랜잭션만 따로 커밋하는 기능을 제공(autonomous 트랜잭션)

## 선분이력 정합성 유지

원장테이블이 선분이력으로 관리하던데

선분이력모델은 여러 측면에서 장점이 있지만 잘못하면 데이터 정합성이 쉽게 깨질 수 있다는 단점이 있다.

기존 선분이력을 끊고 새로운 이력 레코드를 추가할때 신규등록이면 update문에서 실패하고 insert문 처리

```sql
--1
  declare
    cur_dt varchar2(14)
  begin
    cur_de := to_char(sysdate, 'yyyymmddhh24miss')

--2
  update 부가서비스이력
  set 종료일시 = to_date(:cur_dt, 'yyyymmddhh24miss') - 1/24/60/60
  where 고객ID = 1
  and 부가서비스ID = 'A'
  and 종료일시 = to_date('99991231235959', 'yyyymmddhh24miss');

--3
  insert into 부가서비스이력(고객ID, 부가서비스ID, 시작일시, 종료일시)
  values(1, 'A', to_date(:cur_dt, 'yyyymmddhh24miss')
        , to_date('99991231235959', 'yyyymmddhh24miss'));

--4
  commit;
end;

```

1번을 수행하고 2로 진입하기 직전에 어떤 이유에서건 두 번째 트랜잭션이 동일 이력에 대해 1~4를 번저 진행한다면 선분이력이 깨지게 된다.

따라서 트랜잭션이 순차적으로 진행할 수 있도록 1번문장을 수행하기 전에 select for update문을 이용해 Lock 을 설정한다.

하지만 기존이력이 전혀 없던 고객일 경우 Lock이 걸리지 않는다. 그러면 동시에 두 개 트랜잭션이 3번 insert문으로 진입할 수 있고 시작일시는 같으면서 종료일시가 다른 두개의 이력 레코드가 생긴다.

```sql
-- 기존데이터가 없는 경우 LOCK이 걸리지 않음
select 고객ID from  부가서비스이력
where 고객ID = 1
and 부가서비스ID = 'A'
and 종료일시 = to_date('99991231235959', 'yyyymmddhh24miss')
FOR UPDATE NOWAIT;
```

`따라서 부가서비스이력의 상위 엔티티인 고객테이블에 Lock을 걸면 완벽하게 동시성 제어를 할 수 있다.`

```sql
select 고객ID from 고객 where 고객ID = 1
for update nowait;
```

비즈니스 정책으로 고객테이블 락을 얻은후 다음 로직 실행되게 하는것

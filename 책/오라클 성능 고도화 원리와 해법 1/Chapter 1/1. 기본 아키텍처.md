# 기본 아키텍처

오라클은 데이터베이스와 이를 액세스하는 프로세스 사이에 SGA라고하는 메모리 캐시 영역을 두고 있다.

디스크를 경유한 입출력은 물리적으로 액세스 암(arm)이 움직이면서 헤드를 통해 데이터를 읽고 쓰는 반면에 메모리 캐시를 통한 입출력은 전기적 신호에 불과하기 때문에 디스크 I/O에 비교할 수 없이 빠르다.

많은 프로세스가 동시에 데이터를 액세스 하기 때문에 사용자 데이터를 보호하는 Lock은 물론 공유 메모리 영역인 SGA 상에 위치한 데이터 구조에 대한 액세스를 직렬화 하기 위한 Lock 메커니즘 (latch)도 필요해진다.

오라클은 블록 단위로 읽고, 저장할 때도 변경이 발생한 블록만 찾아 블록 단위로 저장한다.

오라클도 백그라운드에서 DBWR와 CKPT 프로세스가 캐시와 데이터파일 간 동기화를 주기적으로 수행해준다.

DBMS마다 DB에 대한 정의가 조금씩 다른데 오라클에서는 디스크에 저장된 데이터 집합(Datafile, Redo log file, Control file 등)을 DB라고 부른다. 그리고 SGA 공유 메모리 영역과 이를 액세스하는 프로세스 집합을 합쳐서 인스턴스 라고 부른다.

프로세스 집합을 다시 서버 프로세스와 백그라운드 프로세스 집합으로 나눌 수 있다.

-   서버 프로세스는 전면에서 사용자가 던지는 명령을 처리
-   백그라운드 프로세스는 보이지 않ㅇ지만 뒤에서 묵묵히 주어진 역할을 수행

오라클에 접속하면 각 클라이언트를 위한 전용 서버 프로세스가 떠서 사용자에게 필요한 서비스를 제공한다. SQL을 파싱하고 필요하면 최적화를 수행하며, 커서를 열어 SQL을 실행하면서 블록을 읽고, 읽은 데이터를 정렬해서 클라이언트가 요청한 결과 집합을 만들어 네트워크를 통해 전송하는 일련의 작업들을 모두 서버 프로세스가 처리한다.

일하는 도중에 스스로 처리하지 못하는 일들(데이터파일로부터 DB 버퍼캐시로 블록을 적재하거나, Dirty 블록을 캐시에서 밀어냄으로써 free 블록을 확보하는 일, 그리고 Redo 로그파일을 비우는 일등)을 만나면 백그라운드 프로세스 등에 신호는 보내 대신 일을 처리하도록 요청한다.

오라클에서 리스너에 연결요청을 하는 순간 하나의 프로세스를 띄우고 PGA 메모리를 할당한다는 사실

이는 비용이 큰 작업이므로 애플리케이션을 구축할 때 반드시 커넥션 풀 기능이 필요한 이유

한번 커넥션을 맺으면 작업을 완료하더라도 이를 해제하지 않고 애플리케이션 서버에 pooling하고 있다가 반복 재사용한다.

소프트웨어 세계에서 가장 중요한 화두인 재사용성은 데이터베이스 성능 튜닝의 핵심 원리

기본적인 구성으로 오라클을 설치하면 하나의 데이터베이스에 접근하는 하나의 인스턴스(메모리와 프로세스 집합)가 생성되지만 RAC(Real Application Cluster)환경에서는 하나의 데이터베이스를 액세스하는 다중 인스턴스로 구성된다.

RAC 모델은 데이터파일만 공유하는 과거의 공유 디스크 방식에서 한층 더 진일보한 공유 캐시방식을 지원한다. 글로벌 캐시 개념을 사용하므로 로컬 캐시에 없는 데이터 블록을 이웃 노드에서 전송받아 서비스할 수 있다. 각 인스턴스를 고속의 전용 네트워크로 연결하기 때문에 가능한 일

심지어 다른 인스턴스에서 갱신하고 아직 커밋하지 않은 Active 상태의 블록까지도 디스크를 경유하지 않고 Dirty 버퍼(메모리와 디스크 간에 동기화 되지 않은 버퍼) 상태에서 네트워크를 통해 서로 주고받으며 갱신을 수행한다.

RAC 이전 OPS환경에서는 타 노드에 캐싱된 Dirty 버퍼를 읽고자 할 떄 디스크로의 쓰기 작업이 선행되어야 했고 이처럼 디스크를 거치는 동기화 과정을 핑이라고 불렀다.

여러 인스턴스가 하나의 데이터베이스를 액세스 하는 것은 가능하지만 어떤 상황에서도 하나의 인스턴스가 여러 개 데이터베이스를 액세스 하는 것은 불가능하다.

DBLink는 일반 클라이언트 세션과 동일하게 Oracle Net을 이용해 SQL 기반으로 데이터를 읽고 쓰는 구조이므로 인스턴스와 데이터 베이스 관계를 설명하는 아키텍처와는 별대로 이해해야 한다.

SQL을 튜닝할 때 가장 많이 사용하는 툴킷은 SQL 트레이스

| call    | count   | cpu   | elapsed | disk | `query` | `current` | rows    |
| ------- | ------- | ----- | ------- | ---- | ------- | --------- | ------- |
| parse   | 1       | 0.00  | 0.00    | 0    | 0       | 0         | 0       |
| Execute | 1000000 | 42.22 | 40.65   | 129  | 8381    | 4074523   | 1000000 |
| Fetch   | 0       | 0.00  | 0.00    | 0    | 0       | 0         | 0       |
| total   | 1000001 | 42.22 | 40.65   | 129  | 8381    | 4074523   | 1000000 |

위 표는 SQL 트레이스를 통해 수집된 SQL 수행정보를 TKProf 유틸리티를 이용해 포맷했을 때 볼 수 있는 Call 통계다

이 중 query와 current 항목의 의미와 차이점을 정확히 이해하는 개발자는 거의 없다.

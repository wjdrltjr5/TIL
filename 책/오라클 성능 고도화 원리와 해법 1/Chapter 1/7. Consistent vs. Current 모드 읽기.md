# Consistent vs. Current 모드 읽기

## Consistent 모드 읽기와 Current 모드 읽기의 차이점

Consistent 모드 읽기는 SCN 확인 과정을 거치며 쿼리가 시작된 시점을 기준으로 일관성 있는 상태로 블록을 액세스하는 것을 말한다.

SQL 트레이스 Call 통계에서 query 항목과 AutoTrace에서 consistent gets 항목이 Consistent모드에서 읽은 블록 수를 의미한다. (CR블록 생성하려고 Undo 세그먼트로부터 읽어들이는 블록 수 포함)

CR 블록이 필요없이 바로 Current 블록을 읽어도 Consistent모드에서 읽었다면 qurey 항목에 집계된다.

Current 모드 읽기는 SQL문이 시작된 시점이 아니라 데이터를 찾아간 바로 그 시점의 최종 값을 읽으려고 블록을 액세스 하는 것을 말한다. 주로 Select문에서 읽는 블록들

SQL트레이스 Call 통계 레포트를 통해 볼 수 있는 current항목과 AutoTrace 에서 db block gets 항목이 Current 모드에서 읽은 블록 수를 의미한다.

다음과 같은 상황에서 사용

-   DML문
-   select for update
-   디스크 소트가 필요할 정도로 대량의 데이터 정렬시

## Consistent 모드로 갱신할 때 생기는 현상

두개의 update문이 Consistent모드로 값을 읽고 갱신한다면 동시성이 발생하는 것처럼 lost update가 발생하는 결과를 초래한다.

이런 Lost Update 문제를 회피하려면 갱신 작업 만큼은 Current 모드를 사용해야 한다.

## Current 모드로 갱신할 때 생기는 현상

어떤 조건에 해당하는 데이터를 삭제하는 도중 새로 삽입되는 조건이 삭제하는 조건에 해당되면 삭제되버리는 현상이 발생할 수 있다.

## Consistent 모드로 읽고 Current 모드로 갱신할 떄 생기는 현상

위 문제들을 피하기 위해 오라클은 Consistent 모드로 읽고 Current 모드로 갱신한다.

> 오라클에서 update문을 수행하면, 대상 레코드를 읽을 때는 Consistent 모드로 읽고 실제값을 변경할 때는 Current 모드로 읽는다. 따라서 대상 레코드를 읽기 위한 블록 액세스는 SQL 트레이스에서 query 항목으로 계산되고 값을 변경하기 위한 블록 액세스는 current 항목으로 계산된다.

## Consistent 모드로 갱신대상을 식별하고 Current 모드로 갱신

이해를 돕기 위해 pseudo 코드로 표현

```
for c in(
  /* Consistent 영역
  select rowid, empno, sal from emp
  where empno = 7788 and sal = 1000
)
loop
  /* current 영역
  update emp set sal = sal + 200
  where empno = c.empno
  and sal = c.sal
  and rowid = c.rid
  */
end loop;
```

Consistent 모드에서 수행한 조건 체크를 Current 모드로 액세스 하는시점에 한번 더 수행

1단계 : where 절에 기술된 조건에 따라 수정/삭제할 대상 레코드의 rowid를 Consistent모드로 찾는다(DML문이 시작된 시점 기준)

2단계 : 앞에서 읽은 rowid가 가리키는 레코드를 찾아가 로우 Lock을 설정한 후에 Current모드로 실제 update/delete를 수행한다(값이 변경되는 기준)

-   이 단계에서 Current 모드로 다시 한번 조건을 체크하고, 갱신할 값을 읽어 수정 / 삭제한다.

`단계 1을 수행해 update/delete 대상건을 모두 추출하고 나서 단계 2를 수행하는 게 아니라 건건이 실행된다.`

단계 1이 필요한 이유는 갱신이 진행되는 동안 추가되거나 변경을 통해 범위 안에 새로 들어오는 레코드를 제외하고자 하는 것

이미 버위 안에 포함돼 있던 레코드는 단계 2에서 변경이 이루어지는 바로 그 시점 기준으로 값을 읽고 갱신한다.

> select는 Consistent 모드로 읽는다.

> insert, update, delete, merge 는 Current 모드로 읽고 쓴다. 다만 갱신할 대상 레코드를 식별하는 작업만큼은 Consistent 모드로 이루어진다.

갱신할때 Consistent 모드와 Current 모드에서 읽은 값이 다르면 (갱신 대상이였는데 아니게되면) 그떄까지의 갱신을 롤백하고 update를 처음부터 다시 실행한다. (Restart 메커니즘)

갱신 대상 레코드의 값이 중간이 바뀌었다고 항상 Restart 메커니즘이 작동하는 건 아니다 `where 절에 사용된 컬럼 값이 바뀌었을 때만 작동`

`Restart 시점이 일관성의 기준이 된다. ` 이후 update과정에서 restart가 또다시 발생하는 불상사를 막기 위해 오라클은 조건에 부합하는 레코드를 select for update 모드로 lock을 설정하고 나서 재시작한다. (처음부터 락걸면 대상 범뒤 두번 액세스하는 부하 및 동시성 저하가 발생하기 때문에 이렇게 진행)

## 오라클에서 일관성 없게 값을 갱신하는 사례

스칼라 서브쿼리는 특별한 이유가 없는 한 항상 Consistent모드로 읽기를 수행한다.

```sql
-- 1번쿼리
update 계좌2
   set 총잔고 = 계좌2.잔고 + (select 잔고
                                from 계좌1
                               where 계좌번호 = 계좌2.계좌번호)
 where 계좌번호 = 7788;

-- 2번쿼리
update 계좌2
   set 총잔고 = (select 계좌2.잔고 + 잔고
                   from 계좌1
                  where 계좌번호 = 계좌2.계좌번호)
 where 계좌번호 = 7788;
```

1번쿼리에서 계좌2.잔고는 Current 모드로 읽는 반면 계좌1.잔고는 Consistent 모드로 읽는다.

위 update문장이 진행되는 도중에 계좌1에서 변경이 발생했더라도 update문이 시작되는 시점의 값을 찾아 읽는다(delete가 발생해도 마찬가지)

2번쿼리는 Current모드로 읽어야 할 계좌2의 잔고 값을 스칼라 서브쿼리 내에서 참조하기 때문에 스칼라 서브쿼리까지도 Current 모드로 작동하게 된다. 따가서 계좌1변경이 발생한다면 새로운 값을 읽는다(delete가 발생하면 null값으로 )

따라서 update 문이 수행되는 동안 두 테이블로부터 잔고를 변경하는 트랜잭션이 동시에 진행할 수 있는 상황이라면 업무 특성에 맞게 SQL을 작성해야만 한다.

> tx1 > update 계좌1 set 잔고 = 잔고 + 100 where 계좌번호 = 7788;

> tx1 > update 계좌2 set 잔고 = 잔고 + 100 where 계좌번호 = 7788;

> tx2 > update 계좌2 set 총잔고 = 계좌2.잔고 + (select 잔고 from 계좌1 where 계좌번호 = 계좌2.계좌번호 ) where 계좌번호 = 7788;

> tx1 > commit;

> tx2 > commit;

계좌1 잔고 : 1100 / 계좌2 잔고 : 1200

총잔고 : 2200 / 총잔고2 2300

총잔고 구할때 계좌2는 current모드로 읽었지만 계좌1을 consistent 모드로 읽었기 떄문에(스칼라 서브쿼리 라서) 값 안맞음

> tx2 > update 계좌2 set 총잔고 = (select 계좌2.잔고 + 잔고 from 계좌1 where 계좌번호 = 계좌2.계좌번호 ) where 계좌번호 = 7788;

이렇게 하면 스칼라 서브쿼리도 current 모드로 읽어서 2300

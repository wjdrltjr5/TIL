# Undo

과거에는 롤백이라는 용어를 사용했지만 9i부터 공식문에서는 Undo라는 용어를 사용

Undo 세그먼트는 일반 세그먼트와 많이 다르다고 생각할 수 있지만 데이터를 저장하는 일반 테이블 세그먼트와 별반 다르지 않다.

테이블 세그먼트와 마찬가지로 익스텐트 단위로 저장하고 빠른 읽기/쓰기를 위해 Undo 블록들을 버퍼 캐시에 캐싱하며, 데이터 유실을 방지하기 위해 그 변경사항을 Redo로그에 로깅하는 점도 같다.

다른 점이라면 Undo 세그먼트에 저장하는 내용인데 각 트랜잭션 별로 Undo 세그먼트를 할당해 주고 그 트랜잭션이 발생시킨 테이블과 인덱스에 대한 변경사항들을 Undo 레코드 단위로 Undo 세그먼트 블록에 차곡차곡 기록한다.

Undo 세그먼트에 저장된 정보는 아래 3가지 목적을 위해 사용된다.

-   Transaction Rollback
    -   트랜잭션에 의한 변경사항을 최종 커밋하지 않고 롤백하고자 할때
-   Transaction Recovery(Instance Recovery시 rollback 단계)
    -   Instance Crash 발생 후 Redo를 이용해 Roll forward단계가 완료되면 최종 커밋되지 않은 변경사항 복구시 사용
    -   시스템이 셧다운된 시점에 아직 커밋되지 않았던 트랜잭션들을 모두 롤백해야 한다.
-   Read Consistency
    -   읽기 일관성을 위해 사용

## Undo 세그먼트 트랜잭션 데이터 슬롯

Undo 세그먼트 중 첫 번째 익스텐트 그중에서도 첫번째 블록에는 Undo 세그먼트 헤더 정보가 담긴다.

Undo 세그먼터 헤더에는 트랜잭션 테이블 슬롯이 위치하는데 각 슬롯에 기록되는 사항들은 아래와 같다.

-   트랜잭션 ID
    -   아래 3가지로 구성
    -   USN# (Undo Segment Number 의 약자)
    -   Slot#
    -   Wrap#
-   트랜잭션 상태 정보
-   커밋 SCN (트랜잭션이 커밋된 경우)
-   Last UBA(Undo Block Address)
-   기타

트랜잭션을 시작하려면 먼저 Undo 세그먼트에 있는 트랜잭션 테이블로부터 슬롯을 할당 받아야 하며, 할당받은 슬롯에 자신이 현재 Active 상태임을 표시하고서 갱신을 시작한다.

트랜잭션 슬롯을 곧바로 얻이 못해 이용가능한 슬롯이 생기기를 기다릴 때 발생하는 이벤트가 undo segment tx slot이다

트랜잭션이 발생시키는 데이터 또는 인덱스 블록에 대한 변경사항은 Undo 블록에 Undo 레코드로서 하나씩 차례대로 기록된다.

각 DML 오퍼레이션 별로 undo 레코드에 기록되는 내용은 아래와 같다.

-   Insert : 추가된 레코드의 rowid
-   Update : 변경되는 컬럼에 대한 before image
-   Delete : 지워지는 로우의 모든 컬럼에 대한 before image

Last UBA 는 트랜잭션의 기록사항들을 가장 마지막 undo 레코드에 뒤에 계속 추가해 나가려고 유지하는 일종의 포인터다.

그리고 각 Undo 레코드 간에는 체인 형태로 연결돼 있어 데이터를 롤백하고자 할 떄 이 체인을 따라 거슬러 올라가며 작업을 수행하게 된다.

하나의 Undo 블록에 쓰기가 완료되면 새로운 Undo 블록을 할당받아 쓰기 작업을 계속해 나간다

v$transaction 뷰에 있는 used_ublk 와 used_urec 컬럼을 통해 현재 사용 중인 Undo 블록 개수와 현재까지 기록한 Undo 레코드 양을 확인할 수 있다.

인덱스가 전혀 없는 테이블이라면 한 건을 갱신할 때마다 used_urec 값이 하나씩 증가하지만 인덱스가 딸려있다면 인덱스 엔트리에 대한 갱신 내용까지 값에 포함된다는 사실을 기억할 필요가 있다.

insert or delete시에는 인덱스 하나당 하나의 Undo 레코드가 추가되고 update시에는 인덱스 하나당 두 개의 Undo 레코드가 추가된다

`인덱스 엔트리를 update 할때는 내부적으로 delete & insert 방식으로 수행되기 때문`

아직 커밋되지 않은 Active 상태의 트랜잭션이 사용하는 Undo 블록과 트랜잭션 테이블 슬롯은 절대 다른 트랜잭션에 의해 재사용 되지 않는다.

사용자가 커밋해 트랜잭션이 완료되면 상태정보를 active -> committed 로 변경하고 그 시점의 커밋 SCN을 트랜잭션 슬롯에 저장 후 이 트랜잭션 슬롯과 Undo 블록들은 다른 트랜잭션에 의해 재사용될 수 있다.

하지만 가장 먼저 커밋된 트랜잭션 슬롯부터 순차적으로 재사용되기 때문에 Undo 데이터는 커밋 후에도 상당기간 남아있게 된다.

## 블록 헤더 ITL 슬롯

Undo 세그먼트 > 데이터 슬롯, 인덱스 블록

Undo 세그먼트 헤더에 트랜잭션 테이블 슬롯이 있다면 각 데이터 슬롯과 인덱스 블록 헤더에는 ITL(interested transaction list)슬롯이 있다.

ITL 슬롯에 기록되는 내용은 다음과 같다

-   ITL 슬롯 번호
-   트랜잭션 ID
-   UBA (Undo Block Address)
-   커밋 Flag
-   Locking 정보
-   커밋 SCN

트랜잭션을 시작하려면 Undo 세그먼트 트랜잭션 테이블로부터 슬롯을 먼저 확보하듯이 특정 블록에 속한 레코드를 갱신하려면 먼저 블록 헤더로부터 ITL 슬롯을 확보해야 한다.

거기에 트랜잭션 ID를 기록하고 현재 해당 트랜잭션이 Active 상태임을 표시한 후에야 블록 갱신이 가능하다.

ITL 슬롯을 할당받지 못하면 트랜잭션은 블로킹 되었다가 다른 트랜잭션이 커밋 또는 롤백 될때 ITL 슬롯을 얻어 작업을 계속 진행할 수 있다.

## Lock Byte

오라클은 레코드가 저장되는 로우마다 그 헤더에 LockByte를 할당해 해당 로우를 갱신 중인 트랜잭션의 ITL 슬롯 번호를 기록해 둔다.

이것이 로우 단위 Lock이며, 오라클은 로우 단위 Lock과 트랜잭션 Lock을 조합해서 로우 Lock을 구현하였다.

레코드를 갱신하려고 할 때 대상 레코드의 LockByte가 활성화 돼 있으면 ITL 슬롯을 찾아가고 다시 그 ITL 슬롯이 가리키는 트랜잭션 테이블 슬롯을 찾아가 그 트랜잭션이 아직 active 상태면 트랜잭션이 완료될 때까지 대기 한다. (트랜잭션 Lock)

다른 DBMS는 Lock 매니저를 통해 현재 갱신 중인 레코드 정보를 관리하는데 Lock 매니저가 사용할 수 있는 리소스가 유한하기 떄문에

대량의 갱신이 발생할 떄는 로우 단위 Lock 정보를 모두 관리할 수 없어 블록 단위 또는 테이블 단위로 lock 에스컬레이션이 발생하기도 하며 그 순간 동시성이 현저히 저하된다.

하지만 오라클은 로우 단위 Lock을 별도의 Lock 리소스 사용없이 레코드의 속성으로 관리하기 때문에 Lock 에스컬레이션 메커니즘이 전혀 불필요하다.

ITL 슬롯에 기록되는 내용중 UBA가 있었는데 이는 트랜잭션에 의해 발생한 변경 이전 데이터가 저장된 Undo 블록 주소를 가리키는 포인터 정보다.

읽기 일관성을 위해 CR Copy를 생성해서 과거 버전으로 되돌리려 할 떄 사용한다.

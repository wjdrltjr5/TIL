# 옵티마이저

## 옵티마이저란

옵티마이저는 사용자가 요청한 SQL을 가장 효율적이고 빠르게 수행할 수 있는 최적의 처리경로를 선택해 주는 DBMS의 핵심엔진이다.

구조화된 질의언어로 사용자가 원하는 결과집합을 정의하면 이를 얻는데 필요한 처리절차(프로시저)는 DBMS에 내장된 옵티마이저가 자동으로 생성해준다.

옵티마이저에는 크게 두 가지가 있다.

-   규칙기반 옵티마이저(RBO)
-   비용기반 옵티마이저(CBO 10g부터 비용기만만 사용)

## 규칙기간 옵티마이저 (RBO)

규칙기반 옵티마이저는 다른 말로 휴리스틱 옵티마이저라고 불리며,미리 정해놓은 우선숭위에 따라 액세스 경로를 평가하고 실행계획을 선택한다.

OLTP 환경의 중소형 데이터베이스 시스템이라면 RBO 규칙이 어느 정도 보편 타당성을 갖는다.

하지만 데이터량, 값의 수, 컬럼 값 분포, 인덱스 높이, 클러스터링 팩터 같은 데이터 특성을 고려하지 않기 때문에 RBO는 대용량 데이터를 처리하는 데 있어 합리적이지 못할 때가 많다.

예로 조건절 컬럼에 인덱스가 있으면 무조건 인덱스를 사용한다 항상 인덱스를 신뢰하며 Full Scan과의 손익을 따지지 않는다.

부분범위처리가 불가능한 상황이라면 Full Table Scan하고 나서 정렬하는 편이 나은 데도 RBO 우선순위로는 인덱스 컬럼에 의한 order by가 Full Table Scan보다 한단계 높아서 그런 선택을 하는 것

데이터와 시스템특성에 맞는 통계정보 수집 정책을 수립함으로써 옵티마이저가 스스로 최적의 결정을 할 수 있도록 돕는 쪽에 역량을 집중하는 것이 바람직하다.

## 비용기반 옵티마이저 (CBO)

비용기반 옵티마이저는 말 그래도 비용을 기반으로 최적화를 수행한다. 여기서 비용이란 쿼리를 수행하는데 소요되는 일량 또는 시간을 뜻한다.

CBO가 실행계획을 수립할 때 판단 기준이 되는 비용은 어디까지나 예상치다.

미리 구해놓은 테이블과 인덱스에 대한 여러 통계정보를 기초로 각 오퍼레이션 단계별 예상 비용을 산정하고, 이를 합산한 총 비용이 가장 낮은 실행계획 하나를 선택한다.

비용을 산정할 때 사용되는 오브젝트 통게 항목에는 레코드 개수, 블록 개수, 평균 행 길이, 컬럼 값의 수, 컬럼 값 분포, 인덱스 높이, 클러스터링 팩터 같은 것들이 있다.

최근에는 하드웨어적 특성을 반영한 시스템 통계정보(CPU 속도 , 디스크 I/O 속도)까지 이용한다.

옵티마이저의 최적화 수행단계를 요약하면 다음과 같다.

-   사용자가 던진 쿼리수행을 위해, 후보군이 될만한 실행게획을 찾는다.
-   데이터 닉셔너리에 미리 수집해 놓은 오브젝트 통게 및 시스템 통계정보를 이용해 각 실행계획의 예상비용을 산정한다.
-   각 실행계획의 비용을 비교해서 최저비용을 갖는 하나를 선택한다.

`쿼리를 최적화할 때 미리 구해놓은 통계정보를 이용한다고 했는데 만약 테이블과 인덱스에 대한 통계정보가 없거나 너무 오래돼 신뢰할 수 없는 경우 옵티마이저가 동적으로 샘플링을 수행하도록 할 수 있다.`

optimizer_dynamic_sampling 파라미터로 동적 샘플링 레벨을 설정할 수 있다.

값이 1인경우 아래 조건을 모두 만족할때만 동적 샘플링이 일어난다.

-   통계정보가 수집되지 않은 테이블이 적어도 하나 이상 있고
-   그 테이블이 다른 테이블과 조인되거나 서브쿼리 또는 Non-mergeable View에 포함되고
-   그 테이블에 인덱스가 하나도 없고
-   그 테이블에 할당된 블록 수가 32개(동적 샘플링을 위한 표본 블록 수의 기본 값) 보다 많을때

레벨 설정은 최대 10까지 가능하다. 레벨이 높을수록 옵티마이저는 더 적극적인 동적 샘플링을 수행하며 샘플링에 사용되는 표본 블록 개수도 증가한다.

동적 샘플링으로 얻은 통계정보는 데이터 딕셔너리에 영구 저장되지 않는다. 통계정보가 올바르지 않은 테이블을 참조하는 쿼리는 '하드 파싱할 때마다' 동적 샘플링을 위한 Recursive SQL이 추가로 수행되므로 성능에 안좋다.

따라서 DB관리자는 이런 현상이 발생하지 않도록 통계정보를 관리해 주어야 한다.

CBO를 기준으로 SQL 처리 절차 요약 (옵티마이저만)

-   Query Transformer : 사용자가 던진 SQL을 그대로 최적화하는 것이 아니라 우선 최적화 하기 쉬운 형태로 변환을 시도한다.

    -   쿼리 변환 전후 결과가 동일함이 보장될때만

-   Estimator : 쿼리 오퍼레이션 각 단계의 선택도, 카디널리티, 비용을 계산하고, 궁극적으로는 실행계획 전체에 대한 총 비용을 계산해 낸다.

    -   각 단게를 수행하는데 필요한 I/O, CPU, 메모리 사용량 등을 예측하기 위해 데이터베이스 오브젝트 통계정보와 하드웨어적인 시스템 성능 통계정보를 이용한다. (CPU 속도, Single Block Read Time, Multiblock Read Time등)

-   Plan Generator : 하나의 쿼리를 수행하는 데 있어, 후보군이 될만한 실행계획들을 생성해내는 역할을 한다.

통계정보 중요

## 옵티마이저 모드

옵티마이저 모드로 선택할 수 있는 값으로는 아래 5가지가 있고 시스템레벨, 세션레벨, 쿼리레벨에서 바꿀 수 있다.

```sql
alter system set optimizer_mode = all_rows; -- 시스템 레벨
alter session set optimizer_mode = all_rows; -- 세션 레벨
select /*+ all_rows */ * from t where ...;  -- 쿼리 레벨
```

-   RULE : RBO모드를 선택하고자 할 떄 사용
-   ALL_ROWS : 쿼리 최종 결과집합을 끝까지 Fetch하는 것을 전제로, 시스템 리소스를 가장 적게 사용하는 실행계획을 선택

    -   DML 문장은 일부 데이터만 가공하고 멈출 수 없으므로 항상 all_rows 모드로 작동
    -   select 문장도 union, minus 같은 집합 연산자나 for update절을 사용하면 all_rows 모드로 작동한다.
    -   PL/SQL 내에서 수행되는 SQL도 힌트를 사용하거나 기본 모드가 rule인 경우를 제외하면 항상 all_rows모드로 작동한다.

-   FIRST_ROWS : 전체 결과집합 중 일부 로우만 Fetch 하다가 멈추는 것을 전제로, 가장 빠른 응답속도를 낼 수 있는 실행계획을 선택한다.

    -   만약 사용자가 끝까지 Fetch 한다면 오히려 더 많은 리소스를 사용하고 전체 수행속도도 느려질 수있다.
    -   비용과 규칙을 혼합한 형태의 옵티마이저 모드 (얼마만큼 fetch할지 지정하지 않았으므로 비용산정이 쉽지 않기 때문)

-   FIRST_ROWS_N : 사용자가 처음 n개 로우만 Fetch하는 것을 전제로 가장 빠른 응답속도를 낼 수 있는 실행계획을 선택한다.

    -   n의 종류는 1, 10, 100, 1000 4가지 지정한 n개 이상을 fetch한다면 오히려 더 많은 리소스 사용과 함께 느려질 수 있음

    -   힌트를 사용히 0 보다 큰 어떤 정수값이라도 입력 가능하므로 파라미터를 이용할 때보다 더 정밀하게 제어가능

    ```sql
    select /*+ first_rows(100)*/ * from t where...;
    ```

-   CHOOSE : 액세스되는 테이블 중 적어도 하나의 통계정보가 있다면 CBO, 그중에서도 all_rows모드를 선택한다
    -   어느 테이블에도 통계정보가 없으면 RBO를 사용
    -   10g 부터는 RBO를 지원하지 않기 때문에 통계정보가 없다면 무조건 동적 샘플링

### 옵티마이저 모드 선택

웹 애플리케이션 환경에서는 OLTP이더라도 대게 all_rows가 올바른 선택이다.

왜냐하면 애플리케이션에서 수행되는 쿼리 자체가 전체 범위 처리를 요구하기 때문

first_rows 모드가 효과적인 애플리케이션 아키텍처는 주로 2-Tier 환경의 클라이언트/서버 구조

`반면 OLTP성 애플리케이션이더라도 3-Tier 구조는 클라이언트와 서버간 연결을 지속하지 않는 환경이므로 오픈 커서를 계속 유지할 수 없어 페이지 처리 기법을 주로 사용한다.`

이를위해 rownum으로 결과집합을 10건 내지 20건으로 제한하는 쿼리를 주로 사용한다. 요지는 대량의 데이터에서 일부만 Fetch하다 멈추는 것이 아니라 집합 자체를 소량으로 정의한다는 것

# 비용

오라클 옵티마이저가 사용하는 비용 모델이는 I/O 비용 모델과 CPU 비용 모델 두 가지가 있다.

I/O 비용 모델은 에상되는 I/O 요청 횟수을 쿼리 수행 비용으로 간주해 실행 계획을 평가하는 반면 CPU 비용 모델은 여기에 시간 개념을 더해 비용을 산정한다.

비용 모델을 선택할 때 사용되는 파라미터는 \_optimizer_cost_model이고, 아래 세가지 옵션이 제공된다.

-   IO : I/O 비용모델
-   CPU : CPU 비용 모델
-   CHOOSE : 시스템 통계가 있으면 CPU 비용모델, 없으면 I/O 비용 모델 (기본값)

아래 두 힌트를 이용하면 쿼리 레벨로도 비용 모델은 선택할 수 있다.

-   cpu_costing
-   no_cou_costing

## I/O 비용 모델

I/O 비용 모델에서의 비용은 디스크 I/O Call 횟수(논리적/물리적으로 읽은 블록 개수가 아닌 I/O 횟수)를 의미한다.

### 인덱스를 경유한 테이블 액세스 비용

인덱스를 경유한 테이블 액세스 시에는 Single Block I/O방식이 사용된다.

이는 디스크 한블록을 읽을 떄마다 I/O Call을 일으키는 방식이므로 읽게 될 물리적 블록 개수가 액세스 비용과 일치한다.

인덱스 단계에서 Rows가 2385이므로 그만큼 테이블 Random 액세스가 발생할 텐데 I/O Call Cost가 64번 뿐인 이유는 클러스터링 팩터가 비용 계산식에 고려되었기 떄문이다.

```
비용 = blevel +  -- 인덱스 수직적 탐색 비용
       (리브 블록수 * 유표 인덱스 선택도 ) + -- 인덱스 수평적 탐색 비용
       (클러스터링 팩터 * 유효 테이블 선택도) -- 테이블 Random 액세스 비용
```

-   blevel : 브랜치 레벨을 의미, 리프 블록에 도달하기 까지 읽게될 브랜치 블록 개수

-   유효 인덱스 선택도 : 전체 인덱스 레코드 중에서 조건절을 만족하는 레코드를 찾기위해 스캔할 것으로 예상되는 비율

    -   리프 블록에는 인덱스 레코드가 정렬된 상태로 저장되므로 이 비율이 곧, 방문할 리프 블록 비율

-   유효 테이블 선택도 : 전레 레코드 중에서 인덱스 스캔을 완료하고서 최종적으로 테이블을 방문할 것으로 예상되는 비율

    -   클러스터링 팩터는 인덱스를 경유해 전체 로우를 액세스할 때 읽힐 것으로 예상되는 테이블 블록 개수이므로 여기에 유효 테이블 선택도를 곱합으로써 조건절에 대해 읽힐 것으로 예상되는 테이블 블록 개수를 구할 수 있음

-   유효 인덱스 선택도 : 인덱스 Access Predicate에 의해 결정
-   유효 테이블 선택도 : 인덱스 Access Predicate와 Filter Predicate에 의해 결정

(인덱스 filter도 access에 아마 포함이였던거 같은데)

테이블 액세스 후 최종 선택도는 테이블 Filter Predicate 까지 포함한 모든 조건절에 의해 결정된다.

-   (최종)테이블 선택도 : 테이블 Filter Predicate까지 포함한 모든 조건절에 의해 결정

조건절이 아래와 같은 형태가 아니라면, 인덱스 컬럼에대한 조건절은 모두 인덱스 Access Predicate에 포함된다.

바꿔 말하면 아래 경우에만 인덱스 Access Predicate와 인덱스 Filter Predicate가 다르다.

-   좌변 컬럼을 가공한 조건절
-   왼쪽 % 또는 양쪽 % 기호를 사용한 like 조건절
-   같은 컬럼에 대한 조건절이 두 개 이상일때 인덱스 액세스 조건으로 선택되지 못한 다른 조건절

선택도는 각 조건절 컬럼의 선택도를 곱해서 구하므로 결론적으로 SQL이 위 조건절을 포함하는 경우를 제외하면 유효 인덱스 선택도와 유효 테이블 선택도는 항상 같다.

선택도는 num_distinct 컬럼 통계를 이용해 구한다. 그리고 브랜치 레벨과 리프 블록 수 , 클러스터링 팩터는 모두 인덱스 통계에서 얻을 수 있다.

### Full Scan에 의한 테이블 액세스 비용

테이블을 Full Scan 할 때는 HWM 아래쪽 블록을 순차적으로 읽어 들이는 과정에서 발생하는 I/O Call 횟수로 비용을 계산한다.

Full Scan할때는 한 번의 I/O Call 로써 여러 블록을 읽어 들이는 Multiblock I/O 방식을 사용하므로 이론적으로는 총 블록 수를 db_file_multiblock_read_count 파라미터로 나눈 만큼 I/O Call이 발생해야 한다.

하지만 내부적으로 조정된 값으로 비용을 계산하기 때문에 예상치와 정확히 일치하지는 않는다.

### I/O 비용 모델의 비현실적인 과정

디스크 I/O Call 횟수로써 테이블 액세스 비용을 평가한다는 데이는 아래 두 가지 중요한 의미가 내포돼있다.

-   SingleBlock I/O와 MultiBlock I/O는 비용이 같다.
-   캐싱 효과를 전혀 고려하지 않는다.

한 번에 한 블록씩 읽는 비용과 여러 블록을 읽는 비용이 같다거나 모든 블록을 디스크에서 읽는 다는 것은 매우 비현식적인 가정이다.

이를 보정하기 위해 아래 두 파라미터가 오라클 8버전부터 제공되기 시작했다.

-   optimizer_index_cost_adj : 인덱스 탐색 비용 조정 (1~1000 까지)

    -   기본값으로 설정된 100이란 수치는 한 번의 I/O Call 로써 Single Block 과 Multi Block의 비용을 같게 하라는 것
    -   25로 설정하면 Single가 Multi의 25%수준의 비용으로 책정한다.
    -   이값을 낮게 설정할 수록 테이블 스캔보다 인덱스를 이용한 테이블 액세스를 선호하게 된다.

-   optimizer_index_caching : 옵티마이저는 NL조인시 Inner 테이블 쪽 인덱스 블록을 매번 디스크에서 읽는다고 가정하지만 이는 비현실적 ( 값 0일떄)
    -   특히 작은 테이블일때는 대부분 캐싱된 블록을 읽게 된다.
    -   NL 조인에서 inner 인덱스 블록이 캐싱돼 있을 가능성을 알려주는 파라미터
    -   0~100 이값을 높게 설절할수록 옵티마이저는 인덱스를 이용한 NL조인을 선호하게 된다.

## CPU 비용 모델

모든 데이터베이스 오퍼레이션은 CPU를 사용하며, 경우에 따라서는 I/O보다 성능에 더 큰 영향을 끼지치도 한다.

아래는 블록 I/O가 소량인데도 쿼리 수행 시간이 상당이 오래 걸리는 경우

-   해시 조인할 때, 해시 체인에 달린 레코드가 많아 해시 체인을 스캔하는 부하가 심할 떄
-   캐싱된 블록을 반복적으로 읽는데, 한 블록 내에서 매번 비효율적으로 많은 레코드를 스캔할 때 (예로 inner 쪽 인덱스 선두 컬럼이 between조건일때)
-   버퍼를 Pin한 상태에서 같은 블록을 반복 액세스할 떄
-   대량의 레코드를 읽으면서 건건히 여러개의 사용자 정의 함수를 반복 호출할 때
-   메모리 소트를 반복할 때

아래와 같은 경우에도 CPU 사용량이 다소 증가한다.

-   조건절 개수가 아주 많을 때
-   조건절이나 select-list에 연산 집약적인 작업을 많이 포함할 때

CPU 비용모델에서의 비용 계산식은 다음과 같다.

```
COST = ( #SRds * sreadtim +
         #MRds * mreadtim +
         #CPOCycles / cpuspeed
       ) / sreadtim
```

-   #SRds : Single Block I/O 요청횟수
-   #MRds : Multiblock I/O 요청횟수
-   #CPUCycles : 쿼리 수행에 필요한 CPU 사이클 수
-   sreadtim : Single Block I/O에 소요되는 시간 (ms)
-   mreadtim : Multiblock I/O에 소요되는 시간(mx)
-   cpuspeed : 초당 처리할 수 있는 CPU 사이클 수

sreadtim, mreadtim, cpuspeed는 mbrc와 함께 시스템 통계 수집 시 미리 측정해 둔 값이다.

### I/O 비용

공식에서 알 수 있는 것처럼 Single Block I/O 요청 횟수와 Multiblock I/O 요청 횟수에 미리 측정해 놓은 평균 소요시간을 각각 곱합으로 써 I/O 일랴을 시간으로 표현해였다.

그럼으로써 인덱스 스캔과 테이블 스캔 비용간의 상대적인 시간차이를 계산식에 포함시켰다.

### CPU비용

CPU 비용은 예상 CPU 사이클 수 를 초당 처리할 수 있는 CPU 사이클 수로 나눈 값으로 계산한다.

예상 CPU 사이클 수 에는 순수한 CPU 연산 비용과 버퍼 캐시에서 데이터를 읽는 CPU 비용까지를 포함한다.

이처럼 I/O 시간과 CPU 연산 시간을 더한 시간 개념을 빌어 쿼리 수행 비용을 평가한다는 것이 CPU 비용 모델의 핵심

결론적으로 CPU 비용 모델에서 말하는 비용은 쿼리의 예상 총 수행 시간을 Single Block I/O시간 단위로 표현한 것

비용이 10으로 계산됬다면 10번의 Single Block I/O를 수행하는 만큼의 시간이 걸릴 것임을 의미한다.

시간 개념을 더한 것에 그치지 않고 오라클은 캐싱 효과를 비용 계산식에 포함하려는 움직임을 보이고 있다.

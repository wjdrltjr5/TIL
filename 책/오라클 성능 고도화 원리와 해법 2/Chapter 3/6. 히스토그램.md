# 히스토그램

## 히스토그램 유형

히스토그램이 있으면 더 정확한 카디널리티를 구할 수 있다. 특히, 분포가 균일하지 않은 컬럼으로 조회할 때 효과를 발휘한다.

오라클이 사용하는 히스토그램으로는 아래 두 가지 유형이 있다.

-   높이 균형(Height-Balanced) 히스토그램
-   도수 분포(Frequency) 히스토그램

히스토그램을 생성하려면 컬럼 통계 수집 시 버킷 개수를 2 이상으로 지정하면 된다. (ex. for columns SIZE 10 col1, col2, col3)

히스토그램 정보는 dba_histograms 또는 dba_tab_histograms 뷰를 통해 확인할 수 있다.

특히 10g에선느 dba_tab_columns 뷰에 histogram 컬럼이 추가되면서 히스토그램 유형을 쉽게 파악할 수 있게 되었다.

해당 컬럼에 표시되는 값들

-   FREQUNECY : 값별로 빈도수를 저장하는 도수분포 히스토그램(값의 수 = 버킷 개수)

-   HEIGHT-BALANCED : 각 버킷의 높이가 동일한 높이 균형 히스토그램 (값의 수 > 버킷 개수)

-   NONE : 히스토그램을 생성하지 않은 경우

## 도수 분포 히스토그램

value-based 히스토그램으로도 불리며, 값별로 빈도수(frequency number)를 저장하는 히스토그램을 말한다.

도수분포(frequency)히스토그램은 컬럼 값마다 하나의 버킷을 할당(값의 수 = 버킷 개수)한ㄷ,

사용자가 요청한 버킷 개수가 컬럼이 가진 값의 수보다 많거나 같을 때 사용되며, 최대 254버킷만 허용하므로 값의 수가 254개를 넘는 컬럼에는 이 히스토그램을 사용할 수 없다.

도수 분포 히스토르갬에서는 컬럼 값의 수(NDV, number of distinct value)와 버킷 개수가 항상 일치한다. 컬럼 값마다 단일 버킷을 할당하기 떄문

254개를 요청하더라도 값의 수만큼만 버킷을 할당하므로 정확한 히스토그램을 위해서라면 항상 254개를 요청하는 것이 좋다.

히스토그램 정보를 조회할 수 있는 dba/all/user_histograms 뷰에는 아래 두 컬럼이 있다.

-   endpoint_value : 버킷에 할당된 컬럼 값
-   endpoint_number : endpoint_value로 정렬했을때, 최소 값부터 현재 값까지의 누적 수량

endpoint_number가 누적 수량을 의미하므로 바로 앞 endpoint_value까지의 누적수량을 차감함으로써 해당 버킷의 값 빈도수를 알 수 있다.

도수분포 히스토그램은 값별로 빈도수를 미리 계산해 두는 방식이기 때문에 조건절을 만족하는 카디널리티를 쉽고 정확하게 구할 수 있다.

하지만 시스템 자원에 한계가 있으므로 (254개 최대) 컬럼 값의 빈도수를 모두 이런식으로 저장할 수는 없다.

그래서 값의 수가 많을 떄는 높이 균형 히스토그램을 사용한다.

## 높이균형 히스토그램

equi-depth 히스토그램으로도 불린다. 컬럼의 가진 값의 수보다 적은 버킷을 요청할때 만들어진다.

높이 균형 히스토그램에서는 버킷 개수보다 값의 수가 많기 떄문에 하나의 버킷이 여러 개 값을 담당한다.

값의 수가 100개인데 10개의 버킷을 요청하면 하나의 버킷이 평균적으로 10개의 값을 대표한다. 요청할 수 있는 최대 버킷 개수는 254개이므로 값의 수가 254개를 넘으면 무조건 이 히스토그램이 만들어진다.

높이 균형 히스토그램에서는 말 그대로 버킷의 높이가 같다. 각 버킷은 {1/(버킷 개수) \* 100}%의 데이터 분포를 갖는다.

따라서 각 버킷(값이 아니라 버킷)이 갖는 빈도수는 {(총 레코드 개수) / 버킷 개수}로써 구할 수 있다.

빈도 수가 많은 값을 포함할 때는 두 개 이상의 버킷이 할당된다.

오라클은 popular value를 압축해서 저장한다.

높이 균형 히스토그램일때의 컬럼

-   endpoint_number : 버킷 번호
-   endpoint_value : 버킷이 담당하는 가장 큰 값

endpoint_number는 버킷 번호이므로 1씩 증가하지만 2칸 이상을 건너 뛰는 버킷은 popular_value를 포함함을 의미하며 많이 건너뛸수록 해당 값의 비중이 크다.

오라클은 popular value에 대한 카디널리티를 구할 때만 버킷에 의한 계산식을 사용하고 나머지 (non-popular value)는 미리 구해놓은 density 값을 이용한다.

### popular value에 대한 선택도 / 카디널리티 계산

조건절 값이 두 개 이상 버킷을 가진 popular value이면 아래 공식을 따른다.

> 선택도 = (조건절 값의 버킷 개수) / (총 버킷 개수)

즉 조건절 값의 버킷 개수가 총 버킷 개수(endpoint_number가 가장 큰 값)에 서 차지하는 비중을 가지고 선택도를 구한다.

popular value가 총 10개 버킷을 사용(endpoint_number 가 6 -> 16으로 점프)할때 (압축된거) 총 20이면
10/20 = 50%이다.

> 카디널리티 = 총 로우수 \* 선택도

### non-popular value에 대한 선택도 / 카디널리티 계산

non-popular_value일때는 미리 구해 놓은 density 값을 이용한다.

> 카디널리티 = 총 로우 수 _ 선택도 = 총 로우 수 _ density

컬럼 통계로서 미리 구해놓은 density를 사용

### density

컬럼 통계를 보면 density 값을 볼 수 있는데 해당 컬럼을 = 조건으로 검색할 때의 선택도를 미리 구해놓은 값

`히스토그램이 없거나 있더라도 100% 균일한 분포를 갖는다면 density 값은 항상 1/num_distinct와 일치하지만 그렇지 않은 상황에서는 다른 값을 가질 수도 있다.`

`= 조건 조회시 옵티마이저가 어떤 때는 1/num_distinct를 이용하고 어떤때는 미리 구해놓은 density값을 이용한다는 사실은 기억하자`

## 바인드 변수 사용시 카디널리티 계산

바인드 변수를 사용하면, 최초 수행할 떄 최적화를 거친 실행계획을 캐시에 적재하고 실행히점에는 그것을 그대로 가져와 값만 다르게 바인딩하면서 반복 재사용하게 된다.

`변수를 바인딩하는 시점이 (최적화 시점보다 나중인) 실행시점.` SQL을 최적화하는 시점에 조건절 컬럼의 데이터 분포를 활용하지 못하는 문제점을 갖는다. (컬럼 히스토그램만)

따라서 바인드 변수를 사용할 때 옵티마이저는 평균 분포를 가정한 실행 계획을 생성한다. 컬럼 분포가 균일할때는 문제가 되지 않지만 그렇지 않을때는 최적의 실행계획이 아닐 수 있다.

### = 조건일때

-   히스토그램이 없을 때 : 1/num_distinct 사용
-   도수분포 히스토그램일 때: 1/num_distinct 사용
-   높이 균형 히스토그램일 때 : density 사용

### 범위 검색 조건일 때

범위 검색 조건이 사용되면 옵티마이저는 고정된 규칙으로 선택도를 추정하는데, 운이 좋아 그값이 맞을 수 있지만 십중팔구 틀릴 가능성이 크다.

바인드 변수를 사용하면 정확한 컬럼 히스토그램에 근거하지 않고 카디널리티를 구하는 정재힌 계산식에 기초해 비용을 계산하므로 최적이 아닌 실행계획을 수립할 가능성이 커진다.

좋은 실행계획을 위해서라면 DW, OLAP, 배치 프로그램 에서 수행되는 쿼리는 바인드 변수보다 상수를 사용하는 것이 좋고,

날짜 컬럼처럼 부등호 , between 같은 범위 조건으로 자주 검색되는 컬럼일때 특히 그렇다.

OLTP성 쿼리이더라도 값의 종류가 적고 분포가 균일하지 않을 때는 상수 조건을 쓰는 것이 유용할 수 있다.

## 결합 선택도

히스토그램을 많이 만들어 두어도 두 개 이상의 컬럼에 대한 결합 선택도를 구할 때는 정확성이 떨어진다.

### 동적 샘플링

오라클은 동적 샘플링을 통해 이 문제를 해결하려고 시도하고 있다.

소량의 데이터 샘플링을 통해 where 조건절에 사용된 두 개 이상 컬럼의 결합 분포를 구하는 기능으로서, 동적 샘플링 레벨을 4 이상으로 설정할 때만 작동한다.

### 다중 컬럼 통계(Multi-column Statistics)

11g 부터는 확장형 토계(extended statistics)라고 불리는 기능을 통해 다중 컬럼에 대한 히스토그램도 생성할 수 있게 되었다.

dbms_stats 패키지의 gather_table_stats 프로시저 method_opt 인자를 통해서 확장형 통계를 수집할 수 있다.

# 옵티마이저의 한계

옵티마이저는 완벽하지 않다.

기술적으로 도저히 극복할 수 없는 한계점들이 있는가 하면, 정보를 저장할 공간과 시간 제약 떄문에 아직 적용하지 못하는 최적화 기법들도 있다.

자동 튜닝 옵티마저라 불리는 오프라인 옵티아미저가 이런 사실을 잘 말해주는데

튜닝모드에서 작동하는 이 옵티마이저는 시간에 구애받지 않고 충분한 시간 동안 동적 샘플링을 포함한 여러 기법을 활용해 튜닝을 실시하고 사용자에게 권고안을 제시한다.

자동 튜닝 옵티마이저는 통계를 분석하고, SQL 프로파일링을 실시하며, 액세스 경로 및 SQL 구조 분석을 통해 SQL 튜닝을 실시한다.

자동 튜닝 옵티마이저 기능을 활용하려면 SQL Tuning Advisor 라 불리는 서버 유틸리티를 이용하면된다.

SQL Tuning Advisor에 SQL문을 입력하면 내부적으로 자동 튜닝 옵티마이저를 호출해 SQL 분석을 실시한다. 분석이 완료되면 SQL 성능을 높이기 위해 사용자가 취해야할 조치사항들을 보고서 형태로 출력해준다.

옵티마이저는 우리가 경험하고 있는 것보다 이미 높은 수준의 테크닉을 갖고 있지만 현실적인 제약 떄문에 실 운영환경에 적용하지 못하고 있다는 뜻

주로 시간과 수집해야할 정보량이 문제

## 부족한 옵티마이징 팩터

옵티마이저는 주어진 환경에서 최선을 다할 뿐 옵티마이징 팩터를 제공하는 것은 결국 사람의 몫이다.

## 부정확한 통계

현실적으로 100% 정확한 통계를 유지하기는 어렵다. 이런 현실적인 제약 떄문에 샘플링 방식으로 통계를 수집하다 보니 실제 데이터와 불일치가 발생하기 마련

샘플링 방식으로 통계를 수집할 때는 정확성 문제와 더불어 안정성 측면에도 관심을 기울여야 한다.

분포가 균등하지 않은 컬럼이라면 수집할 때마다 통계치가 바뀔 수 있어 실행계획을 불안정하게 만든다.

통계 수집 구지도 매우 중요하다. 특히, 어느 날 갑자기 데이터가 아주 많이 변경되거나 새로 입력됐을 때 곧바로 통계를 재수집해 주지 않는다면 옵티마이저가 잘못된 선택을 하더라도 나무랄 수 없다.

## 히스토그램의 한계

부정확한 통계의 연장선으로 볼 수 있는데 히스토그램 버킷 개수로 254개까지만 허용된다는 점도 옵티마이저에겐 중요한 제약사항이다.

컬럼의 Distinct Value 개수가 그 이상이면 모든값 별로 빈도수를 기록해 둘 수 없고, 이때는 뒤에서 설명하겠지만 높이 균형 히스토그램을 사용하게 되므로 발생 빈도가 낮은 값들에 대한 정확한 분포를 반영할 수 없다.

버킷 개수를 무한정 많이 가져갈 수 있으면 더 정확한 카디널리티를 구하는 데 도움이 되겠지만, 정보를 수집하는 데 소요되는 시간과 저장 공간 때문에 생기는 어쩔 수 없는 제약사항이다.

## 바인드 변수 사용 시 균등 분포 가정

컬럼 히스토그램이 있으면 옵티마이저가 그것을 가지고 조건절에 대한 선택도를 구한다.

그런데 아무리 정확한 컬럼 히스토그램을 보유하더라도 바인드 변수를 사용한 SQL에는 무용지물이 되고 만다

조건절에 바인드 변수를 사용하면 옵티마이저가 균등 분포를 가정하고 비용을 계산하기 때문

이는 옵티마이저가 가장 극복하기 어려운 난제, 특히 OLTP 환경에선 라이브러리 캐시 부하를 피하기 위해 바인드 변수를 적극 사용하는 것이 필수 권고사항이기 때문

## 결합 선택도 산정의 어려움

조건절 컬럼이 서로 상관관게에 있으면 정확한 데이터 분포와 카디널리티를 산정하기 어렵다

```sql
select * from 사원 where 직급 = '부장' and 연봉 >= 5000;
```

직급의 종류 = {부장, 과장, 대리 사원} 각각 25%의 비중을 갖는다.

전체 사원이 1000명이고 연봉 >= 5000 조건에 부합하는 사원 비중이 10%이면, 옵티마이저는 위 쿼리 조건에 해당하는 사원 수를 25(1000 _ 0.25 _ 0.1)로 추산한다.

하지만 직급과 연봉에는 상관관계가 매우 높아서 연봉 5000 이상이 모두 부장이라면 실제 위 쿼리 결과는 100(1000 \* 0.1)이다.

이런 이유 때문에 카디널리티가 잘못 계산되면 다른 집합과 여러번 조인을 거치는 동안 카디널리티는 점점 더 부정확해지고 궁극적으로 옵티마이저가 잘못된 실행계획을 수립하는 결과를 낳는다.

모든 컬럼 간 상관관계와 결합 선택도를 미리 저장해 두면 좋겠지만 이것은 거의 불가능에 가깝다.

오라클은 동적 샘플링을 통해 이 문제를 해결하려고 시도하고 있다. 소량의 데이터 샘플링을 통해 where 조건절에 사용된 두 개 이상 컬럼의 결합 분포를 구하는 기능으로서 동적 샘플링 레벨을 4 이상으로 설정할 때만 동작한다.

## 비현실적인 가정

CBO는 쿼리 수행 비용을 평가할때 여러 가정을 사용하는데, 그중 일부는 매우 비현실적인 것들도 있다.

예로 Single Block I/O와 Multiblock I/O 비용을 같게 평가한다거나 캐싱 효과를 고려하지 않는다는점

I/O 비용 모델 하에서의 비용은 단순히 I/O 횟수를 의미한다. 옵티마이저가 예상할 때 I/O Call 횟수가 가장 적은 실행계획을 선택하는 것

그런데 I/O 비용 모델이 사용하는 기본 가정에 따르면 Single Block I/O와 Multi Block Read의 비용은 같다. 이둘을 구분하지 않고 동일한 하나의 시스템 Call로 간주하는 것

또한 옵티마이저는 다른 세션이나 다른 쿼리문에 의해 데이터 블록들이 이미 버퍼 캐시에 캐싱돼 있을 가능성을 배제한다.

비용을 평가할 때 디스크 I/O Call 횟수만을 더한다 다시말해 옵티마이저는 메모리 자원에 대한 최악의 상황을 가정하고 비용을 산정하는 것인데 이는 DW환경에나 적합한 가정이다.

이런 비현실적인 가정들을 보정할 수 있도록 오라클은 8i에서 두 개의 파라미터를 제공하기 시작했다.

-   optimizer_index_caching
-   optimizer_index_cost_adj

## 규칙을 의존하는 CBO

아무리 비용기반 옵티마이저라 하더라도 부분적으로는 규칙에 의존한다.

예로 원격테이블이나 External 테이블에 대해서는 카디널리티, 평균 행 길이, 블록 수, 그리고 각종 인덱스 관련 통계항목들에 대해 고정된 상수 값을 사용한다.

### 알바펫순 인덱스 선택 규칙

CBO가 사용하는 규칙과 관련해 꼭 기억해야할 사항으로는 두 대안 인덱스의 예상비용이 같을 때 알파벳 순에서 앞선 것을 선택한다는 사실

적어도 Unique한 조건으로 PK 인덱스를 액세스해야 하는 상황에서 이런 일이 발생하지 않게하려면 인덱스 명명 규칙을 PK, X01, X02와 같은 식으로 정하는 것이 좋다.

## 하드웨어 성능 특성

옵티마이저는 기본적으로 옵티마이저 개발팀이 사용한 하드웨어 사양에 맞춰져 있다.

따라서 실제 운영 시스템의 하드웨어 사양이 그것과 다를 때 옵티마이저가 잘못된 실행계획을 수립할 가능성이 높아진다.

또안 애플리케이션 특성에 의해서도 하드웨어 성능은 달라진다.

이러한 문제는 오라클 9i부터 시스템 통계를 사용하면서 해결이 되었다.

### 동적 실시간 최적화

모든 데이터베이스의 부하는 매우 가변적이다. 따라서 하드웨어 성능 특성을 반영한 실행계획을 수립하더라도 쿼리 수행 당시 시스템 부하 정도에 따라 최적이 아닐 수 있다.

정적인 통계정보와 옵티마이저 모델로는 이런 한계점을 극복하기 어려우므로 시스템 부하에 따라 실행전략을 동적으로 조정하는 최적화 기법이 도입되고 있다.

이 기능의 핵심은 쿼리가 수행되는 시점의 시스템 상태에 따라 하드웨어 리소스를 적절히 배분해 주는 데 있다.

쿼리최적화가 단일 SQL문 성능을 최적화하는데 초점을 맞추는 반면, 동적 실시간 최적화는 수많은 SQL이 동시에 수행되는 환경에서 시스템 전체 최적화를 이루는데 초점을 맞춘다.

# 기본 개념

병렬 처리란 SQL문이 수행해야 할 작업 범위를 여러 개의 작은 단위로 나누어 여러 프로세스가 동시에 처리하는 것을 말한다.

여러 프로세스가 동시에 작업하므로 대용량 테이블을 처리할 때 수행 속도를 극적으로 단축시킬 수 있다.

## Query Coordinator와 병렬 서버 프로세스

`Query Coordinator(QC)는 병렬 SQL문을 발행한 세션을 말하고, 병렬 서버 프로세스는 실제 작업을 수행하는 개별 세션들을 말한다.`

QC의 역할은 다음과 같다.

1. 병렬 SQL이 시작되면 QC는 사용자가 지정한 병렬도와 오퍼레이션 종류에 따라 하나 또는 두 개의 병렬 서버 집합을 할당한다.

2. QC는 각 병렬 서버에게 작업을 할당한다. 작업을 지시하고 일이 잘 진행되는지 관리 감독하는 장업반장 역할이다.

3. 병렬로 처리하도록 사용자가 지시하지 않은 테이블은 QC가 직접 처리한다.

4. QC는 각 병렬 서버로부터 산출물을 통합하는 작업을 수행한다.

5. QC는 쿼리의 최종 결과집합을 사용자에게 전송하며, DML일때는 갱신 건수를 집계해서 전송해준다. 쿼리 결과를 전송하는 단계에서 수행되는 스칼라 서브쿼리도 QC가 수행한다.

## Intra-Operation Parallelism과 Inter-Operation Parallelism

```sql
select /*+ full(고객) parallel(고객 4) */ *
from 고객
order by 고객명
```

워 쿼리를 수행하는데 두가지 방법을 생각해 볼 수 있다.

-   각자 자신의 것을 정렬하고 나면 마지막으로 머지하는 것
-   두개 조로 나누고 역할을 분담해 서로 다른 작업을 동시에 진행하는것
    -   한 조는 정렬을 하고 한조를 정렬조에 담당한 분야에 분배하는 것

첫 번째 방법은 작업자가 많을수록 나중에 QC가 머지하는 단게에 부하가 걸려 병렬처리를 극대화하기 어렵다.

오라클이 order by를 병렬로 처리할 때 두 번째 방식을 사용하는 이유

`이때 서로 배타적인 범위를 독립적으로 동시에 처리하는 것을 Intra-Operation Parallelism 이라고 한다.` (하나의 작업을 동시에 빠르게) 분배작업 후 정렬작업

4명이 병렬로 자신이 할당받은 범위를 상대편에 분배하는 첫번째 작업과 병렬로 각자 전달받은 데이터를 정렬하는 두 번째 작업 모두 여기에 속한다. 같은 조끼리는 서로 데이터를 주고받을 일이 없다.

`반면 데이터를 읽어 상대편 조(다른 서버집합)에 분배하거나 정렬된 결과를 QC에게 전송하는 작업을 병렬로 동시에 진행하는 것을 Inter-Operation Parallelism이라고 하며 이때는 항상 프로세스간 통신이 발생한다.` (서로 다른 종류의 작업을 동시에 진행) 분배와 정렬 두집합이 동시에

## 테이블 큐

Intra-Operation Parallelism은 한 병렬 서버 집합에 속한 여러 프로세스가 처리 범위를 달리하면서 병렬로 작업을 진행하는 것이므로 집합 내에서는 절대 프로세스간 통신이 발생하지 않는다.

`반면, Inter-Operation Parallelism은 프로세스 간 통신이 발생하고, 메시지 또는 데이터를 전송하기 위한 통신 채널이 필요하다.`

쿼리 서버 집합간 (P->P) 또는 QC오 ㅏ서버 집합간 (P->S, S->P)데이터 전송을 위해 연결된 파이프 라인을 테이블 큐 라고 한다.

쿼리 서버 집합간 (P->P) Inter-Operation Parallelism이 발생할 때는 사용자가 지정한 병렬도의 배수 만큼 서버 프로세스가 필요한 것을 알 수 있다.

또한 테이블 큐에는 병렬도의 제곱 만큼 파이프 라인이 필요하다는 사실도 알 수 있다.

### 생산자 / 소비자모델

테이블 큐에는 항상 생산자와 소비자가 존재한다. select 문장에서의 최종 소비자는 항상 QC일 것이다.

### 병렬 실행계획에서의 생산자와 소비자 식별

생산자에 PX SEND 소비자에 PX RECEIVE가 표시되므로 테이블 큐를 통한 데이터 분배과정을 좀 더 쉽게 확인할 수 있다.

## IN-OUT 오퍼레이션

### S -> P : PARALLEL_FROM_SERIAL

QC가 읽은 데이터를 테이블 큐를 통해 병렬 서버 프로세스에게 전종하는 것이다.

### P -> S : PARALLEL_TO_SERIAL

각 병렬 서버 프로세스가 처리한 데이터를 QC에게 전송하는 것을 의미한다.

병렬 서버 프로세스로부터 QC로 통신이 발생하므로 Inter-Operation Parallelism에 속한다.

참고로 S->P도 통신이 발생하지만 병렬 오퍼레이션이 아니므로(동시 진행 X) Inter-Operation Parallelism에 속하지 않는다.

### P -> P : PARALLEL_TO_PARALLEL

데이터를 재분배하는 오퍼레이션으로서, 기억할 것은 실행계획에 P->P 가 나타날때면 해당 오퍼레이션을 두 개의 서버 집합이 처리한다는 사실

따라서 사용자가 지정한 병렬도의 2배수만큼 병렬 프로세스가 필요하다.

데이터를 정렬 또는 그룹핑하거나 조인을 위해 동적으로 파티셔니앟ㄹ 때 사용되며

첫 번째 병렬 서버집합이 읽거나 가공한 데이터를 두 번째 병렬 서버 집합에 전송하는 과정에서 병렬 프로세스간 통신이 발생하므로 Inter-Operation Parallelism에 속한다.

### PCWP : PARALLEL_COMBINED_WITH_PARENT

한 서버 집합이 현재 스탭과 부모 스탭을 모두 처맇마을 의미한다.

PCWP도 분명히 병렬 오퍼레이션이지만 한 서버 집합 내에서는 프로세스간 통신이 발생하지 않으므로 Intra-Operation Parallelism에 속한다.

즉 한 서버 집합에 속한 서버 프로세스들이 각자 맡은 범위 내에서 두 스텝 이상의 오퍼레이션을 처리하는 것이며

자식 스텝의 처리결과를 부모 스텍에서 사용할 뿐 프로세스간 통신은 필요치 않다.

## PCWC : PARALLEL_COMBINED_WITH_CHILD

한 서버 집합이 현재 스탭과 그 자식 스탭을 모두 처리함을 의미한다.

PCWC도 병렬 오퍼레이션이지만 한 서버 집합 내에서는 프로세스간 통신이 절대 발생하지 않으므로 Intra-Operation Parallelism에 속한다.

자식 스탭의 쳐리 결과를 받아 현재 스텝의 입력값으로 사용할 뿐이며, 프로세스간 통신을 필요치 않다.

정리하자면

-   S->P, P->S, P->P는 프로세스간 통신이 발생한다.
-   PCWP, PCWC는 프로세스 간 통신이 발생하지 않으며, 각 병렬 서버가 독립적으로 여러 스텝을 처리할 때 나타난다. 하위 스텝의 출력 값이 상위 스텝의 입력 값으로 사용된다.

-   P->P, P->S, PCWP, PCWC는 병렬 오퍼레이션인 반면 `S->P`는 직렬 오퍼레이션이다.

`병렬 쿼리 실행계획에 S->P가 나타난다면 해당 오퍼레이션이 병목 지점인지 의심해 볼 필요가 있다.`

만약 처리할 데이터량이 수백MB이상 된다면 병렬 오퍼레이션으로 바꾸는 것을 고려해야 한다.

## 데이터 재분배

앞서 살펴본 in-out 오퍼레이션 중에서 S->P, P->P가 데이터 재분배와 관련 있다.

데이터를 재분배하는 방식에는 일반적으로 아래 5가지가 사용된다.

### RANGE

order by 또는 sort group by를 병렬로 처리할때 사용된다. 정렬 작업을 맡은 두 번째 서버집합의 프로세스마다 처리 범위를 지정하고 나서

데이터를 읽는 첫 번째 서버집합이 두 번째 서버 집합의 정해진 프로세스에게 정렬 키 값에 따라 분배하는 방식이다.

QC는 각 서버 프로세스에게 작업 범위를 할당하고 정렬 작업에는 직접 참여하지 않으며, 정렬이 완료되고 나면 순서대로 결과를 받아서 사용자에게 전송하는 역할만 한다.

### HASH

조인이나 hash group by 를 병렬로 처리할 때 사용된다. 조인 키나 group by 키값을 해시 함수에 적용하고 리턴된 값에 따라 데이터를 분배하는 방식이며

P-P 뿐만 아니라 S->P방식으로 이루어질 수도 있다.

### BROADCAST

QC또는 첫 번째 서버 집합에 속한 프로세스들이 각각 읽은 데이터를 두 번째 서버 집합에 속한 모든 병렬 프로세스에게 전송하는 방식

병렬 조인에서 크기가 매우 작은 테이블이 있을 때 사용되며, P->P뿐만 아니라 S->P 방식으로도 이루어진다.

### KEY

특정 컬럼을 기준으로 테이블 또는 인덱스를 파티셔닝할 때 사용하는 분배 방식으로서 실행계획에는 PARTITION(KEY)로 표시된다.

-   Partial Partition-Wise 조인
-   CTAS(create table as select)문장으로 파티션 테이블을 만들 때
-   병렬로 글로벌 파티션 인덱스를 만들 때

Partial Partition-Wise 조인은 이미 파티션된 테이블과 조인하기 위해 다른 한쪽 테이블을 동적으로 파티셔닝하고 나서 각 Partition-Pair에 대해 독립적으로 병렬 조인을 수행하는 것을 말한다.

### ROUND-ROBIN

파티션 키, 정렬 키, 해시 함수등에 의존하지 않고 반대편 병렬 서버에 무작위로 데이터를 분배할 때 사용된다.(골고루)

## Granule

데이터를 병렬로 처리할 때 일의 최소 단위를 Granule이라고 하며, 병렬 서버는 한 번에 하나의 Granule씩만 처리한다.

Granule 개수와 크기는 병렬도와 관련 있으며, 이는 병렬 서버 사이에 일을 고르게 분배하는 데에 큰 영향을 미친다.

Granule에는 크게 블록 기반 Granule과 파티션 기반 Granule이 있는데 이는 오라클 데이터베이스의 내부적인 결정사항이며 사용자가 그 크기나 종류를 직접 선택할 수는 없다.

### 블록 기반 Granule

블록 기반 Granule은 파티션 테이블인지 여부와 상관없이 대부분의 병렬 오퍼레이션에 적용되는 기본 작업 단위이다.

블록 기반 Granule 단위로 데이터를 읽을 때는 실행계획상에 PX BLOCK ITERATOR라고 표시된다.

이 오퍼레이션이 나타날때면 QC는 테이블로부터 읽어야 할 일정 범위의 블록을 Granule로써 각 병렬 서버에게 할당한다.

그리고 ITERATOR가 의미하는 바와 같이 병렬 서버가 한 Granule에 대한 일을 끝마치면 이어서 다른 Granule을 할당한다.

Granule 크기와 총 개수는 실행 시점에 오브젝트 사이즈와 병렬도에 따라 QC가 동적으로 결정한다.

### 파티션 기반 Granule

파티션 기반 Granule이 사용될 때, 각 병렬 서버 프로세스는 할당받은 테이블 (또는 인덱스)파티션 전체를 처리할 책임을 진다.

한 파티션을 두 개 프로세스가 함께 처리할 수 없으므로 병렬도는 당연히 파티션 개수 이하로만 지정할 수 있다.

파티션 기반 Granule일 때는 실행계획에 PX PARTITION RANGE ALL 또는 PX PARTITION RANGE ITERATOR라고 표시된다.

전자는 파티션 전체를 읽어야 할 때 나타나고, 후자는 일부 파티션만 읽을 때 나타난다.

블록 기반 Granule과 마찬가지로 여기서도 병렬서버가 한 파티션 처리를 끝마치면 이어서 다른 파티션을 할당받는 식으로 진행한다.
(병렬도가 파티션 개수보다 적을때)

파티션 기반 Granule은 아래와 같은 작업을 수행할 때 사용된다.

-   Partition-Wise 조인 시
-   파티션 인덱스를 병렬로 스캔할 떄
-   파티션 인덱스를 병렬로 갱신할 때
-   파티션 테이블 또는 파티션 인덱스를 병렬로 생성할 때

파티션 기반일 때는 Granule개수가 테이블과 인덱스의 파티션 구조에 의해 정적으로 결정되므로 블록 기반 Granule처럼 유연하지 못하다.

파티션간 데이터량에 편자가 심할 때 부하를 효과적으로 분산시키는 데에 불리하고 리소스를 낭비하게 된다.

파티션 기반 Granule은 병렬도보다 파티션 개수가 상당히 많을때라야 유용하다.

## 병렬 처리 과정에서 발생하는 대기 이벤트

병렬 처리를 위한 데이터 재분배 과정에서 프로세스 간 통신이 발생한다.

QC와 병렬 서버 간, 병렬 서버와 병렬 서버 간 테이블 큐를 통해 메시지를 주고받기 위해 내부적으로 메시지 버퍼를 사용하는데, 생산자 프로세스가 버퍼에 데이터를 넣으면 소비자 프로세스가 그것을 꺼내 가는 식이다.

테이블 큐를 보호할 목적으로 오라클은 credit 비트를 사용한다. 데이터를 전송하려면 먼저 상대편 서버 프로세스로부터 credit 비트를 받도록 하는 것이다.

병렬 처리 과정에서 자주 발생하는 대기 이벤트를 요약하면 다음과 같다. (idle, Other은 클래스)

-   PX Deq : Execute Reply (idle)

    -   QC가 각 병렬 소버에게 작업을 배분하고서 작업이 완료되기를 기다리는 상태

-   PX Dep : Execute Msg(idle)
    -   병렬 서버가 자신의 임무를 완수하고서 다른 병렬 서버가 일을 마치기를 기다리는 상태, QC또는 소비자 병렬 서버에게 데이터 전송을 완료했을 때 나타남
-   PX Dep : Table Q Normal(idle)

    -   메시지 수신 대기, 메시지 큐에 데이터가 쌓이기를 기다리는 상태

-   PX Deq Credit: send blkd(other)

    -   메시지 송신 대기 , QC 또는 소비자 병렬 서버에게 전송할 데이터가 있는데 블로킹 된 상태
    -   생산자 프로세스가 메시지 큐를 통해 데이터를 전송하려고 하는데 어떤 이유에서건 소비자 프로세스가 버퍼에서 데이터를 빨리 꺼내가지 않을 때 발생

-   PX Deq Credit : need buffer(idle)
    -   데이터를 전송하기 전에 상대편 병렬 서버 또는 QC로부터 credit 비트를 얻으려고 대기하는 상태
    -   PX Deq Credit: send blkd(other)와 거의 같은 대기 이벤트이고 내부적인 이유로 전자는 로컬시스템에서 이 이벤트는 RAC 시스템에서 자주 발생

### 대기 이벤트 모니터링

```sql
select /*+ parallel(고객 2) */ * from 고객  order by 고객명


select decode(a.qcserial#, null, 'PARENT', 'CHILD') ST_LVL
    , a.server_set "SET", a.sid, a.serial#, status, event, wait_class
  from v$px_session a, v$session b
 where a.sid = b.sid
  and a.qcsid = 5284
 order by a.qcsid, ST_LVL desc, a.server_group, a.server_set;
```

### 대기 이벤트 해소

v$event_name 뷰를 조회해보면 병렬 처리와 관련된 대기 이벤트가 대부분 Idle로 분류돼있다. (이들 이벤트를 회피하기 위해 사용자가 할 수 있는 일들이 거의 없기 때문에)

큰 테이블을 S->P방식으로 분배(PX Deq: Table Q Normal이벤트가 많이 발생)하던 것을 P->P로 바꿔주거나

P->P 분배과정에서 프로세스 간 데이터 전송량이 많은 SQL을 튜닝해서 그 양을 줄일 수 있는 경우가 종종 있기는 하다.

하지만 그런 조치들이 가능하지 않은 상황에서 병렬 쿼리 관련 Idle 대기 이벤트가 많이 발생한다면 병렬 메커니즘상 자연스럽게 나타나는 현상이라고 이해하는 수 밖에 없다.

Idle 이벤트가 아닌 경우에는 종종 튜닝이 가능할 수 있는데 소비자 프로세스가 덜 활동하는 경우라면 병렬 쿼리를 사용하지 않는게 나을 수 있고(PX Deq Credit : send blkd)

Fetch Call과 Fetch Call 사이에 많은 애플리케이션 로직을 수행하는 경우에는 해당 로직을 튜닝할 수 있는 지 검토해 봐야 한다.

```sql
-- 자주 발생하는 사례
insert /*+ append */ into t1
select /*+ full(t2) parallel(t2 4)*/ * from t2
```

t2테이블은 병렬로 읽지만 t1으로의 insert는 직렬로 수행되고 있다.

이럴 때 t2를 읽어 QC에게 전송하는 4개의 병렬 서버들은 아래와 같이 PX Deq Credit : send blkd 이벤트에서 자주 대기하게 된다.

insert 과정에서 병목이 생기므로 select문을 병렬로 수행하는 것은 불필요할 수 있다. (아니면 insert도 병렬로 수행하거나 Direct Path Write)


# 테이블 Random 액세스 부하

인덱스를 효과적으로 사용하면 쿼리 성능이 매우 빨라지고 대량의 데이터를 인덱스를 통해 액세스할때 쿼리성능이 매우 느려진다.

## 인덱스 ROWID에 의한 테이블 액세스

쿼리에서 참조되는 컬럼이 인덱스에 모두 포함되는 경우가 아니라면 인덱스 스캔 이후 테이블 Random 액세스가 일어난다.

오라클은 테이블 블록이 수시로 버퍼 캐시에서 밀려났다가 다시 캐싱되며, 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 직접 포인터로 연결할 수 없는 구조

대신 디스크 상의 블록 위치 정보 즉 DBA를 해시 키 값으로 삼아 해싱 알고리즘을 통해 버퍼 블록을 찾는다.

매번 위치가 달라지더라도 캐싱되는 해시 버킷만큼은 고정적이다.

오라클에서 rowid는 우편주소에 해당하고 메인 메모리 DB에서 사용하는 포인터는 전화번호에 해당한다.

오라클도 포인터로 액세스하는 버퍼 Pinning 기법을 사용하지만 반복적으로 읽힐 가능성이 큰 블록에 대해서만 일부 적용하고 있다.

-   인덱스에서 하나의 rowid를 읽고 DBA를 해시함수에 적용해 시 값을 확인한다.

-   각 해시 체인은 래치에 의해 보호되므로 해시 값이 가리키는 해시 체인에 대한 래치를 얻으려고 시도한다. (하나의 래치가 여러 개 해시 체인을 동시에 관리)

-   다른 프로세스가 래치를 잡고 있으면 래치가 풀렸는지 확인하는 작업을 일정 횟수 만큼 반복한다.

-   그러고도 실패하면 CPU를 OS에 반환하고 잠시 대기 상태로 빠지는디 이때 latch free 대기 이벤트가 나타난다.

-   정해진 시간동안 잠을 자다가 깨어나서 다시 래치 상태를 확인하고 계속해서 래치가 풀리지 않으면 또다시 대기 상태로 빠질 수 있다.

-   래치가 해제되었다면 래치를 재빨리 획득하고 원하던 해시 체인으로 진입힌다.

-   거기서 데이터 블록이 찾아지면 래치를 해제하고 바로 읽으면 되는데 앞서 해당 블록을 액세스한 프로세스가 아직 일을 마치지 못해 버퍼 Lock을 쥔 상태라면 또 다시 대기해야 한다. (buffer busy waits 대기 이벤트)

-   블록 읽기를 마치고 나면 버퍼 Lock을 해제해야 하므로 다시 해치 체인 래치를 얻으려고 시도한다.

해시 체인을 스캔했는데 데이터 블록을 찾지 못했을 때는 일이 더 복잡해진다.

-   디스크로부터 블록을 퍼 올리려면 Free 버퍼를 할당받아야 하므로 LRU 리스트를 스캔한다.

    -   이를 위해서 cache buffers lru chain 래치를 얻어야 하는데 래치 경합이 심할때는 여기서도 latch free 이벤트가 나타날 수 있다.

-   LRU 리스트를 정해진 임계치만큼 스캔했는데도 Free 상태의 버퍼를 찾지 못하면 DBWR에게 Dirty 버퍼를 디스크에 기록해 Free 버퍼를 확보해 달라는 신호를 보낸다.

-   그런후 해당 작업이 끝날 때까지 잠시 대기하는데 이때 나타나는 대기 이벤트가 free buffer waits이다.

-   Free 버퍼를 할당 받은 후에는 I/O 서브시스템에 I/O 요청을 하고 다시 대기 상태에 빠지는데 이때 db file sequential read 대기 이벤트가 나타난다.

-   마지막으로 읽은 블록을 LRU 리스트 상에서 위치를 옮겨야 하기 때문에 다시 cache buffers lru chain 래치를 얻어야 하는데, 이 또한 원할하지 못할 때는 latch free 이벤트가 나타난다.

인덱스 rowid는 테이블 레코드와 물리적으로 연결돼 있지 않기 떄문에 인덱스를 통한 테이블 액세스는 생각보다 고비용 구조다.

## 인덱스 클러스터링 팩터

클러스터링 팩터(Clustering Factor CF)는 군집성 계수쯤으로 번역될 수 있는 용오러소, 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다.

통계정보를 생성하고 나면 오라클이 계산한 인덱스 CF를 뷰에서 확인할 수 있다.

clustering_factor 수치가 테이블 블록에 가까울수록 데이터가 잘 정렬돼 있음을 의미하고 레코드 개수에 가까울 수록 흩어져 있음을 의미한다.

### 클러스터링 팩터와 물리적 I/O

인덱스 CF가 좋다고 하면 인덱스 정렬 순서와 테이블 정렬 순서가 서로 비슷하다는 것을 말한다. 이는 궁극적으로 물리적인 디스크 I/O 횟수를 감소시키는 효과를 가져다 준다.

오라클에서 I/O는 블록단위로 이루어지므로 인덱스를 통해 하나의 레코드를 읽으면 같은 블록에 속한 다른 레코드들도 함께 캐싱되는 결과를 가져올 것

### 클러스터링 팩터와 논리적 I/O

인덱스 CF는 단적으로 말해 인덱스를 경유해 테이블 전체 로우를 액세스할 떄 읽을 것으로 예상되는 논리적인 블록 개수를 의미한다.

### 버퍼 Pinning에 의한 논리적 I/O 감소 원리

CF에 따라 논리적인 블록 I/O 개수가 이처럼 심하게 차이나는 이유는 인덱스를 통해 액세스되는 하나의 테이블 버퍼 블록을 Pinning하기 때문이다.

버퍼 Pinning는 방금 액세스한 버퍼에 대한 Pin을 즉각 해제하지 않고 데이터베이스 Call 내에서 계속 유지하는 기능

연속된 인덱스 레코드가 같은 블록을 가리킨다면, 래치 획득 과정을 생략하고 버퍼를 Pin한 상태에서 읽기 때문에 논리적인 블록 읽기 횟수가 증가하지 않는다.

CF가 좋을때는 인덱스를 통해 12개 레코드를 읽는데 Random 블록 I/O가 단 2회만 발생한다.

요약하자면, 오라클의 버퍼 Pinning은 자주 접근되는 데이터 블록을 버퍼 캐시에 "고정"시켜, 불필요한 래치 획득과 해시 체인 탐색 오버헤드를 줄임으로써 논리적 I/O 효율을 높이고 전반적인 데이터베이스 성능을 향상시키는 내부적인 최적화 기법입니다.

## 인덱스 손익분기점

인덱스 rowid에 의한 테이블 액세스는 생각보다 고비용 구조이고 따라서 일정량을 넘는 순간 테이블 전체를 스캔할 때보다 오히려 더 느려진다.

Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점을 흔히 `손익 분기점`이라고 부른다.

인덱스에 의한 액세스가 Full Table Scan보다 더 느려지게 만드는 가장 핵심적인 두 가지 요인

-   인덱스 rowid에의한 테이블 액세스는 Random 액세스인 반면 Full Table Scan은 Sequential 액세스 방식으로 이루어진다.

-   디스크 I/O시 인덱스 rowid에 의한 테이블 액세스는 Single Block Read 방식을 사용하는 반면 Full Table Scan은 MultiBlock Read방식을 사용한다.

이런 요인에 의해 인덱스 손익분기점은 일반적으로 5~20%의 낮은 수준에서 결정되지만

CF에 따라 크게 달라진다. CF가 좋다면 손익분기점이 90퍼까지 올라가기도 나쁘다면 5%미만으로 떨어지기도 한다. (즉 수치를 정해놓고 인덱스 효용성을 판단하면 틀리기 쉽다.)

손익분기점은 인덱스가 항상 좋을 수 없음을 설명하려고 도입한 개념일뿐 이를 높이기 위해 어떤 조치를 취하라는 것은 아니다.

### 손익분기점을 극복하기 위한 기능들

손익 분기점 원리에 따르면 선택도가 높은 인덱스는 효용가치가 낮기만 대용량 테이블을 Full Scan 하는 것 역시 비효율이 크다.

첫 번째 기능은 IOT

-   테이블을 인덱스 구조로 생성하는 것을 말한다. 테이블 자체가 인덱스 구조이므로 항상 정렬된 상태를 유지한다.

-   인덱스 리프 블록이 곧 데이터 블록이어서 인덱스를 수직 탐색한 다음에 테이블 레코드를 읽기 위한 추가적인 Random 액세스가 불필요하다

두 번째 기능은 클러스터 테이블

-   키 값이 같은 레코드는 같은 블록에 모이도록 저장하기 때문에 클러스터 인덱스를 이용할 때는 테이블 Random액세스가 키 값별로 한 번씩만 발생한다.

-   클러스터에 도달해서는 Sequential 방식으로 스캔하기 떄문에 넓은 범위를 읽더라도 비효율이 없다.

세 번째 기능은 파티셔닝

-   읽고자 하는 데이터가 많을 떄는 인덱스를 이용하지 않는 편이 낫다고 하지만, 수천만 건에 이르는 테이블을 Full Scan해야 한다면 난감하다.

-   이럴때 대량 범위 조건으로 자주 사용되는 컬럼 기준으로 테이블을 파티셔닝 한다면 Full Table Scan하더라도 일부 파티션만 읽고 멈추도록 할 수 있다.

# IOT, 클러스터 테이블 활용

## IOT란

테이블을 찾아가기 위한 rowid를 갖는 일반 인덱스와 달리 IOT는 모든 행 데이터를 리프 블록에 저장하고 있다.

인덱스 리프 블록이 곧 데이터 블록인셈

```sql
-- 테이블을 인덱스 구조로 만드는 구문
create table index_org_t ( a number primary key, b barchar(10))
organization index;
```

일반적인 힙 구조 테이블로의 데이터 삽입은 Random 방식으로 이루어진다. 즉 Freelist로부터 할당 받은 블록에 정해진 순서 없기 값을 입력한다.

반면 IOT는 인덱스 구조 테이블이므로 정렬 상태를 유지하며 데이터를 삽입한다.

타 DBMS의 클러스터형 인덱스와 비슷한 개념

### IOT의 장점과 단점

IOT는 인위적으로 CF를 좋게 만드는 방법 중 하나다.

같은 값을 가진 레코드들이 100% 정렬된 상태로 모여있기 때문에 Random 액세스가 아닌 Sequential 방식으로 데이터를 액세스할 수 있고 이때문에 넓은 범위를 액세스할 때 유리하다.

IOT의 가장 큰 담점으로는 데이터 입력시 성능이 느리다는 점 실제 테스트 해보면 그럴 정도로 늦지는 않다.

일반 힙 구조 테이블에 PK인덱스를 생성하지 않았을 때와 비교하면 많은 차이가 나지만 PK 인덱스를 두고 비교해보면 차이가 거의 없다.

하지만 성능 차이가 발생하는 이유는 인덱스 분할 발생량 때문

IOT는 인덱스 구조이므로 중간에 꽉 찬 블록에 새로운 값을 입력할 일이 종종 생기고 그럴 떄 인덱스 분할이 발생한다.(B+트리 값추가할때 분할하는 현상 같은 레벨 유지를 위해)

IOT가 PK 이외에 많은 컬럼을 갖는다면 리프 블록에 저장해야할 데이터량이 늘어나 그만큼 액세스 분할 발생빈도도 높아진다.

컬럼 수가 그렇게 많은 테이블이라면 인덱스 스캔 효율 때문이라고 IOT 대상으로는 부적합하다.

## IOT 언제 사용할 것인가?

IOT는 아래와 같은 상황에서 유용하다.

-   크기가 작고 NL 조인으로 반복 룩업하는 테이블
-   폭이 좋고 긴(로우수가 많은) 테이블
-   넓은 범위를 주로 검색하는 테이블
-   데이터 입력과 조회 패턴이 서로 다른 테이블

### 크기가 작고 NL 조인으로 반복 룩업하는 테이블

코드성 테이블이 주로 여기에 속한다. NL 조인에서 Inner 쪽 룩업 테이블로서 액세스되는 동안 건건이 인덱스와 테이블 블록을 다 읽는다면 비효율적이다.

이런 테이블을 IOT로 구성해 주면 적어도 테이블은 반복 액세스하지 않아도 된다.

다만 IOT 구성시 PK 이외 속성의 크기 때문에 인덱스 높이가 증가한다면 역효과가 날 수 있으므로 이를 주의

### 넓은 범위를 주로 검색하는 테이블

주로 Between, Like같은 조건으로 넓은 범위를 검색하는 테이블이라면 IOT 구성을 고려해 볼만하다.

특히 PK이외 컬럼이 별로 없는 통계성 테이블에는 최적의 솔루션이라 할 수 있다.

PK 구성 컬럼이 많은 만큼 분석관점과 액세스 경로가 아주 다양한데 이를 위해 B\*트리 결합 인덱스를 계속 추가해 나가는 것은 저장공간이나 DML 부하 측면에서 문제가 많다.

이때 테이블을 IOT로 구성하면 효과적이다.

### 데이터 입력과 조회 패턴이 서로 다른 테이블

## Partitioned IOT

## Overflow 영역

PK이외 컬럼이 많은 테이블일수록 IOT로 구성하기에 부적합하다.

인덱스 분할에 의한 DML 부하는 물론, 검색을 위한 스캔량도 늘어나기 떄문

컬럼들을 다른 주요 컬럼과 분리 저장하여 IOT 활용성을 높일 수 있는데 오라클이 그런 기능을 제공한다.

```sql
create table table(
  ...
  constraint table_pk primary key(...)
)
organization index
overflow tablespace TBS_OVRF01
pctthreshold 30
including 적출건수;
```

-   OVERFLOW TABLESPACE : Overflow 세그먼트가 저장될 테이블 스페이스를 지정한다.

-   PCTTHRESHOLD : DEFAULT 값은 50 블록 크기의 지정한 %를 초과하기 직전 컬럼까지만 인덱스 블록에 저장하고 그 뒤쪽 컬럼은 모두 Overflow세그먼트에 저장한다.

-   INCLUDING : Including에 지정한 컬럼까지만 인덱스 블록에 저장하고 나머지는 무조건 overflow 세그먼트에 저장한다.

주의할점은 OverFlow 영역을 읽을 때도 건건이 Random 액세스가 발생한다는 사실 따라서 Overflow 세그먼트에 저장된 컬럼 중 일부를 자주 액세스해야 하는 상황이 발생한다면 IOT 액세스 효율은 극격히 저하된다.

다만 OverFlow 영역에도 버퍼 Pinning 효과가 타다나기 때문에 연속적으로 같은 OverFlow 블록을 읽을 때는 Random 블록 I/O를 최소화할 수 있다.

## Secondary 인덱스

IOT는 secondary 인덱스 추가 가능성이 크지 않을 떄만 선택하는 것이 바람직하다.

IOT 레코드의 위치는 영구적이지 않기 때문에 오라클은 secondary 인덱스로부터 IOT레코드를 가리킬때 물리적 주소 대신 logical rowid를 사용한다.

logical rowid 는 PK와 physical guess로 구성된다.

physical guess는 secondary 인덱스를 최초 생성하거나 재생성한 시점에 IOT레코드가 위치했던 데이버 블록 주소다.

### PCT_DIRECT_ACCESS

dba/all/user_indexes 테이블을 조회하면 pct_direct_access 값을 확인할 수 있다.

이는 secondary 인덱스가 유효한 physical guess를 가진 비율을 나타내는 지표

이값이 100% 미만이면 오라클은 바로 PK를 이용해 IOT를 탐색한다. 100%일때만 physical guess를 이용하는데 레코드를 찾아갔을 때 해당 레코드가 다른 곳으로 이동하고 없으면(PK 값비교) PK로 다시 IOT를 탐색한다.

그런 비율이 높아지면 성능은 나빠진다.

인덱스를 최초 생성하거나 재성성하면 pct_direct_access 값은 100이다.

이떄는 physical guess로 바로 액세스하고 성공률도 100%이므로 비효율이 없다.

문제는 시간이 지나면서 physical guess 액세스 실패 확률이 높아져 성능이 점점 저하된다는 것(값 추가로 인한 인덱스 분할)

그럴때는 통계정보를 수집해 pct_direct_access가 실제 physical guess 성공률을 반영하도록 해주어야 한다.

인덱스를 Rebuild하거나 update block references 옵션을 이용해 physical guess를 주기적으로 갱신해 준다면 가장 효과적

```sql
alter index iot_second_idx REBUILD;
alter index iot_second_idx UPDATE BLOCK REFERENCES;
```

`secondary 인덱스 physical guess를 갱신하더라도 통계정보를 재수집한 이후부터 Direct 액세스로 전환된다.(실제로 100이더라도 통계정보가 100이 아니면 PK로 접근)`

인덱스 분할이 발생하더라도 통계정보를 재수집한 이후부터 PK를 이용하는 것과 마찬가지

### 비휘발성 IOT에 대한 Secondary 인덱스 튜닝 방안

비휘발성(읽기 전용이거나 맨 우층 블록에만 값이 입력되어 IOT 레코드 위치가 거의 변하지 않는) 테이블이라면 Direct 액세스 성공률이 높을 것이다.

따라서 pct_direct_access 값이 100을 가리키도록 유지하는 것이 효과적인 튜닝이다.

데이터가 쌓이는 양에 따라 한달 또는 일년에 한번 정도만 physical guess를 갱신해 주면 된다.

읽기 전용 테이블이면 pct_direct_access 값을 100을 가리키도록 한 상태에서 더 이상 통계정보를 수집하지 않으면 되겠지만,

맨 우측에 지속적으로 값이 입력되는 경우라면 통계정보 수집이 필수적이다.

그럴 때는 통계정보 수집 직후에 아래 프로시저를 이용해 값을 직접 설정해 주면된다.

> sql exec dbms_stats.set_index_stats (user, 't1_x1', guessq => 100);

physical guess에 의한 Direct 액세스 성공률이 100%에 가깝다면 일반 테이블을 rowid로 액세스할때와 같은 수준의 성능을 보이므로 secondary인덱스를 추가하는데 대한 부담을 덜 수 있다.

### 휘발성 IOT에 대한 Secondary 인덱스 튜닝 방안

IOT 레코드 위치가 자주 바뀌는 IOT에 secondary 인덱스를 추가할 때는 각별한 주의가 필요하고 처음 설계할 때부터 이에 대한 고려가 있어야 한다.

휘발성이어서 physical guess에 의한 Direct 액세스 성공률이 낮다면 두 가지 선택을 할 수 있다.

-   주기적으로 physical guess를 정확한 값으로 갱신해 주는 것

    -   secondary 인덱스 크기가 작을때 쓸 수 있는 방법

-   아예 physical guess가 사용되지 못하도록 pct_direct_access 값을 100 미만으로 떨어트리는 방법
    -   인덱스 크기가 커서 주기적으로 physical guess를 갱신해 줄 수 없을때 사용
    -   선택도가 매우 낮은 secondary 인덱스 위주로 구성해 주면 큰 비효율은 없다.

## 인덱스 클러스터 테이블

클러스터 테이블에는 인덱스 클러스터와 해시 클러스터 두가지가 있다.

-   인덱스 클러스터 테이블은 클러스터 키 값이 같은 레코드가 한 블록에 모이도록 저장하는 구조
    -   한 블록에 모두 담을 수 없을 때는 새로운 블록을 할당해 체인으로 연결한다.

```sql
-- 인덱스 클러스터 테이블을 구성하려면 클러스터를 생성해야 한다.
create cluter c_deptno# (deptno number(2)) index;

-- 클러스터에 테이블을 담기 전에 아래와 같이 클러스터 인덱스를 반드시 정의해야 한다.
create index i_deptno# on cluster c_deptno#;
```

클러스터 인덱스도 일반적인 B\*트리 인덱스 구조를 사용하지만 해당 키 값을 저장하는 첫번째 데이터 블록만 가리킨다 (체인)

클러스터 인덱스의 키 값은 항상 Unique 하며 테이블 레코드와 1:M관계를 갖는다.

이러한 특성떄문에 클러스터 인덱스를 스캔하면서 값을 찾을때에는 Random 액세스가 값 하나당 한번씩 밖에 발생하지 않는다.

클러스터에 도달해서는 Sequential 방식으로 스캔하기 떄문에 넓은 범위를 읽더라도 비효율이 없다.

인덱스 클러스터 테이블에는 아래 두 가지 유형이 있다.

-   단일 테이블 인덱스 클러스터
-   다중 테이블 인덱스 클러스터

## 클러스터 테이블과 관련한 성능이슈

클러스터 테이블은 넓은 범위를 검색할 때 유리하다.

하지만 실무적으로 자주 활용되지 않는 이유는 DML 부하 때문이다.

일반적인 힙 구조 테이블에 데이터를 입력할 때는 Freelist로부터 할당 받은 공간에 정해진 순서 없이 값을 입력한다.

반면 IOT는 정렬 상태를 유지하면서 값을 입력한다. 클러스터 테이블은 IOT처럼 정렬상태를 유지하지는 않지만 정해진 블록을 찾아서 값을 입력해야 하기 때문에 DML 성능이 다소 떨어진다.

클러스터를 구성하지 않는 대신 인덱스를 생성할거면 DML 부하는 비슷하다고 볼 수 있다.

이미 블록이 할당된 클러스터 키값을 입력할 떄는 별 차이가 없고, 만약 계속 새로운 값이 입력돼 많이 느려진다면 클러스터 키를 잘못 선정한 경우

클러스터 테이블을 사용하게 되면서 기존에 사용하던 인덱스 두세 개를 없앨 수 있다면 DML 부하가 오히려 감소할 수 있다.

수정이 자주 발생하는 컬럼은 클러스터 키로 선정하지 않는 것이 좋지만, 삭제 작업때문에 클러스터 테이블이 불리할 것은 없다.

다만 전체 데이터를 지우거나 테이블을 통째로 Drop 할 때 성능 문제가 생길 수 있다.

전체 데이터를 지울 때는 Truncate Table 문장을 쓰는 것이 빠른데, 클러스터 테이블에는 이 문장을 쓸 수 없다.

전체 데이터를 빠르게 지우고 싶을 때는 아래와 같이 클러스터를 Truncate하거나 Drop 하는 것이 가장 빠르다.(다중 테이블 클러스터일 경우 클러스터링 테이블이 모두 삭제되므로 주의)

```sql
truncate cluster objs_cluster#;
drop cluster objs_cluster# including tables;
```

DML 부하 외에 클러스터 테이블과 관련해 고려해야할 성능 이슈로는 다음과 같은 것들이 있다

-   Direct path Loading을 수행할 수 없다.
-   파티셔닝 기능을 함께 적용할 수 없다. IOT의 경우에는 Partitioned IOT가 가능하다.
-   다중 테이블 클러스터를 Full Scan할 때는 다른 테이블 데이터까지 스캔하기 때문에 불리하다.

### SIZE 옵션

클러스터 키 하나당 레코드 개수가 많지 않을 때 클러스터마다 한 블록씩 통째로 할당하는 것은 낭비다.

그래서 오라클은 하나의 블록에 여러 키 값이 같이 상주할 수 있도록 SIZE 옵션을 두었다.

SIZE 옵션은 한 블록에 여러 클러스터 키가 같이 담기더라도 하나당 가질 수 있는 최소 공간을 미리 에약하는 기능

반대로 말하면 하나의 블록에 담을 최대 클러스터 키 개수를 결정짓는다. (블록크기가 8kb일때 SIZE 옵션으로 2000바이트를 주면 최대 4개의 클러스터 키를 담음)

```sql
create cluster emp_cluster# (empno number(4)) pctfree 0 size 2000 index

create index emp_cluster_idx on cluster emp_cluster#;
```

SIZE 옵션은 그 공간을 미리 예약해 두는 것일 뿐 초과했다고 값을 저장하지 못하는것은 아니다.

SIZE 옵션 때문에 데이터 입력이 방해 받지는 않지만 대부분 클러스터 키 값이 한 블록씩을 초과한다면 굳이 이 옵션을 두어 클러스터 체인이 발생하도록 할 이유는 없다.

## 해시 클러스터 테이블

해시 클러스터 테이블은 해시 함수에서 반환된 값이 같은 데이터를 물리적으로 함께 저장하는 구조

인덱스 클러스터 처럼 두 가지 유형이 있다.

-   단일 테이블 해시 클러스터
-   다중 테이블 해시 클러스터

해시 클러스터의 가장 큰 제약사항은 = 검색만 가능하다는 점 따라서 거의 대부분 = 조건으로만 검색되는 컬럼을 해시 키로 선정해야 한다.

물리적인 인덱스를 따로 갖지 않기 때문에 해시 클러스터 키로 검색할 때는 그만큼 블록 I/O가 덜 발생한다는 이점이 생긴다.

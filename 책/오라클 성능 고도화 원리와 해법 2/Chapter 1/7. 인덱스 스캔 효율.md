# 인덱스 스캔 효율

Sequential 액세스는 레코드간 논리적 또는 물리적인 순서를 따라 차례대로 읽어 나가는 방식을 말하고 Random 액세스는 레코드간 논리적, 물리적인 순서를 따르지 않고 한 건을 읽기 위해 한 블록씩 접근하는 방식

I/O 튜닝의 핵심원리

-   Sequential 액세스의 선택도를 높인다.
    -   인덱스를 스캔한 건수중 결과를 선택되는 비율
    -   (테이블 선택도 X)
    -   같은 결과 건수를 내기 위해 적은 양을 읽어야 함을 말함
-   Random 액세스 발생량을 줄인다.

## 비교 연산자 종류와 컬럼 순서에 따른 인덱스 레코드의 군집성

선행 컬럼이 모두 = 조건인 상태에서 첫번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속되게 모여 있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어진다.

## 인덱스 선행 컬럼이 = 조건이 아닐 때 발생하는 비효율

인덱스 Sequential 액세스에 따른 선택도는 인덱스 컬럼이 조건절에 모두 등치 조건으로 사용될때 가장 높다.

반면 인덱스 선행컬럼이 조건절에 누락되거나 between 부등호 like 같은 범위검색 조건이 사용되면 인덱스를 스캔하는 단계에서 비효율이 발생한다.

인덱스 선행컬럼이 모두 = 조건일때 필요한 범위만 스캔하고 멈출 수 있는 것은 조건을 만족하는 레코드가 모두 한데 모여있기 떄문

## BETWEEN 조건을 IN-LIST로 바꾸었을 때 인덱스 스캔 효율

범위검색 컬럼이 맨 뒤로 가도록 인덱스를 변경하면 좋겠지만 운영 중인 시스템에서 인덱스 구성을 바꾸기는 쉽지 않다.

이럴 때 between 조건을 IN-List로 바꿔주면 가끔 큰 효과를 얻는다.

인덱스 컬럼에 In-List 조건절을 사용하면 Concatenation 방식의 실행계획이 나타난다.

이는 쿼리가 내부적으로 union all 방식으로 변환되고 나서 실행됨을 의미한다.

In-List 개수만큼 union all 브랜치가 생성되고 각 브랜치마다 모든 컬럼을 = 조건으로 검색하기 때문에 선두 컬럼을 between 조건으로 비교할 때와 같은 비효율이 사라진다.

In-List 항목개수가 늘거나 줄 수 있다면 NL방식의 조인문이나 서브쿼리로 구현하면 된다.

### 주의사항

IN-List 개수가 많지 않아야 한다 리프 블록을 추가로 스캔하는 비효율보다 브랜치 블록을 반복 탐색하는 비효율이 더 클 수 있고 인덱스 높이가 높을 때 특히 그렇다.

인덱스 스캔과정에서 선택되는 레코드들이 서로 멀리 떨어져 있을 떄만 유용하다

## Index Skip Scan을 이용한 비효율 해소

Index Skip Scan 인덱스 선두 컬럼이 누락됐을 때뿐만 아니라 부등호, between, like 같은 범위검색 조건일 때도 Index Skip Scan이 유용하게 사용될 수 있고

데이터 상황에 따라서는 = 조건 컬럼들을 인덱스 선두에 위치시킨 것에 버금가는 효과를 얻는다.

## 범위 검색 조건을 남용할 때 발생하는 비효율

코딩을 쉽게하려고 인덱스 컬럼에 범위검색 조건을 남용하면 첫 번째 범위검색 조건에 의해 스캔 범위가 대부분 결정되며, 그 다음을 따르는 조건부터는 스캔 범위를 줄이는 데에 크게 기여하지 못하므로 성능상 불리해질 수 있다.

## 같은 컬럼에 두 개의 범위 검색 조건 사용 시 주의 사항

### 인덱스를 스캔하면서 rowid를 필터링 할 때 발생하는 비효율

rowid를 가지고 = 조건으로 바로 액세스할때는 어떤 액세스보다 빠르지만 인덱스를 스캔하면서 rowid를 필터링할때는 아니다.

인덱스 rowid는 리프 블록에만 있기 떄문에 이를 필터링 하려면 다른 액세스 조건만으로 리프 블록을 찾가가야 한다.

## Between과 Like 스캔 범위 비교

like와 between은 둘 다 범위검색 조건으로서, 앞에서 설명한 범위검색 조건을 사용할 떄의 비효율 원리도 똑같이 적용된다.

하지만 검색을 위해 입력한 값과 테이블의 실제 데이터 상황에 따라 둘 간의 인덱스 스캔량이 다를 수 있다.

between을 사용한다면 적어도 손해볼 일은 없다.

범위검색 조건 뒤를 따르는 조건절은 스캔 범위를 줄이는 데에 영향을 미칠 수도 있고 그렇지 않을 수도 있다.

사용자가 조건 비교를 위해 입력한 값이나 테이블의 실제 데이터 상황에 따라 달라지며

적어도 between 이 like보다 더 넓은 범위를 스캔하는 경우는 없으므로 가급적 between을 사용하기 바란다.

## 선분이력의 인덱스 스캔 효율

고객의 변경이력을 관리할 때 이력의 시작시점만을 관리하는 것을 점이력 모델

시작시점과 종료시점을 함께 관리하는 것을 선분이력 모델이라고 한다.

선분이력처럼 between 검색 조건이 사용될 때는 어느 시점을 주로 조회하느냐에 따라 인덱스 구성 전략을 달리 가져가야 한다.

최근 데이터를 주로 조회한다면 [종료일 + 시작일] 순으로 구성하는 것이 효과적

오래된 과거 데이터를 주로 조회한다면 [시작일 + 종료일] 순으로 구성하는 것이 효과적이다.

업무적으로 미래 시점 데이터를 미리 입력하는 경우가 없다면 현재시점 데이터를 조회할때는 between을 사용하기 보다 종료일 = 99991231 조건을 사용하는것이 효과적이다.

## Access Predicate 와 Filter Predicate

1. 인덱스 단계에서의 Access Predicate
2. 인덱스 단계에서의 Filter Predicate
3. 테이블 단계에서의 Filter Predicate

인덱스를 경유하지 않고 테이블 전체를 스캔할때는 항상 Filter Predicate 단 한가지만 나타날 수 있다.

1번 인덱스 단계에서의 Access Predicate는 인덱스 스캔 범위를 결정하는데 영향을 미친느 조건절을 의미한다.

인덱스 컬럼에 대한 조건절은 설령 범위 검색 조건을 뒤따르는 조건이거나 선행 컬럼이 조건절에서 누락될지라도 액세스 범위를 결정하는데 기여하므로 대부분 Access Predicate에 포함된다.

아래의 경우에는 인덱스 스캔 범위를 결정하는데 전혀 영향을 미치지 않기 때문에 Access Predicate에서 제외된다.

-   좌변 컬럼 가공한 조건절
-   왼쪽 % 또는 양쪽 % 사용 like 조건절
-   같은 컬럼에 대한 조건절이 두 개 이상일 때 , 인덱스 액세스 조건으로 선택되지 못한 다른 조건절

위와 같은 경우를 제외하면 수직적 탐색 과정에서 모든 인덱스 컬럼을 비교 조건으로 사용한다.

2번 인덱스 단계에서의 Filter Predicate는 테이블로의 액세스 여부를 결정짓는 조건절을 의미한다.

첫 번째 나타나는 범위 조건부터 이후 모든 조건절 컬럼들이 여기에 포함되며, 조건절에서 누락된 컬럼 뒤쪽에 놓은 인덱스 컬럼들도 포함한다.

테이블 액세스 단게에서의 Filter Predicate는 테이블을 액세스하고나서 최종 결과 집합으로의 포함여부를 결정 짓는 조건절을 의미한다.

## Index Fragmentation

B\*Tree 인덱스의 B는 Balanced의 약자로서 인덱스 루트에서 리프 블록까지 어떤 값으로 탐색하더라도 읽는 블록 수가 같음을 의미한다.

즉 모든 리프블록의 높이가 동일하다. 불균형은 생길 수 없지만 Index Fragmentation 에 의한 Index Skew 또는 Sparse 현상이 생기는 경우는 종종 있고 이는 인덱스 스캔 효율에 나쁜 영향을 미칠 수 있다.

### Index Skew

Index Skew는 인덱스 엔트리가 왼쪽 또는 오른쪽에 치우치는 현상을 말한다.

대량의 Delete 작업을 마치고 나면 한쪽 리프 블록들은 텅 비는 반면 반대 쪽 리프 블록들을 꽉찬 상태가 될 수 있다.

텅빈 인덱스 블록은 커밋하는 순간 Freelist로 반환되지만 인덱스 구조 상에는 그대로 남는다.

상위 브랜치에서 해당 리프 블록을 가리키는 엔트리가 그대로 남아있어 인덱스 정렬 순서상 그 곳에 입력될 새로운 값이 들어오면 언제든 재사용될 수 있다.

새로운 값이 하나라도 입력되기 전 다른 노드에 인덱스 분할이 발생하면 그것을 위해서도 이들 블록이 재사용 된다.

이때는 상위 브랜치에서 해당 리브 블록을 가리키는 엔트리가 제거돼 다른 쪽 브랜치의 자식 노드로 이동하고 freelist에서도 제거된다.

레코드가 모두 삭제된 블록은 언제든 재사용 가능하지만, 문제는 다시 채워질 때까지 인덱스 스캔 효율이 낮다는것

대량의 데이터를 매일 지웠다가 새로 입력하는 통계성 테이블일 때는 Index Skew가 발생하지 않도록 트랜잭션 패턴에 신경을 써야 한다.

delete문 직후에 커밋을 수행하면 지워진 블록들이 곧바로 insert과정에 재사용된다.

Index Skew를 두려워해 트랜잭션을 짧게 정의하는 것이 바람직하지 않지만 이 경우는 일반 사용자가 접근하지 않는 야간에 배치 프로그램을 통해서만 관리되는 통계성 테이블인경우는 사용할만한다.

항상 배치는 delete문 이후에 insert를 하자. insert 이후에 delete는 Index Skew를 부른다.

### Index Sparse

Index Sparse 인덱스 블록 전반에 걸처 밀도가 떨어지는 현상을 말한다.

지워진 자리에 인덱스 정렬 순서에 따라 새로운 값이 입력되면 그 공간은 재사용되지만

마찬가지로 대량의 delete 작업이 있고 난 후 한동안 인덱스 스캔 호율이 낮다는 데에 문제가 있다.

Index Skew처럼 블록이 아예 텅비면 freelist로 반환돼 언제든 재사용되지만

Index Sparse는 지워진 자리에 새로운 값이 입력되지 않으면 영영 재사용되지 않을 수 있다.

총 레코드 건수가 일정한데도 인덱스 공간 사용량이 계속 커지는 것은 대게 이런 현상에 기인한다.

### Index Rebuild

Fragmentation 때문에 인덱스 크기가 계속 증가하고 스캔 효율이 나쁠 때는 아래와 같이 coalesce 명령을 수행해 주면된다.

```sql
alter index t_idx coalesce;
```

coalesce 명령을 수행하면 인덱스 분할과 반대의 작업이 일어난다. 여러 인덱스 블록을 하나로 병합하고 그 결과로서 생긴 빈 블록들은 freelist에 반환한다.

coalesce명령을 수행해도 인덱스 세그먼트에 할당된 미사용 공간(HWM 아래쪽에서 freelist에 등록된 블록과 HWM 위쪽 미사용블록)은 반환되지 않는다.

Index Fragmentation를 해소하면서 공간가지 반환하려면 아래와같이 shrink명령을 수행하면 된다. (단 shrink는 ASSM에서만 작동)

```sql
alter index t_idx shrink space;
```

coalesce나 shrink는 레코드를 건건이 지웠다가 다시 입력하는 방식을 사용하므로 작업량이 많을 때는 rebuild 명령을 사용하는 편이 나을 수 있다.

```sql
alter index t_idx rebuild;
```

위와 같은 방식들로 인덱스 구조를 슬림화하면 저장효율이나 스캔 효율은 좋아지지만 일반적으로 인덱스 블록에는 어느 정도 공간을 남겨두는 것이 좋다.

공간이 전혀 없으면 인덱스 분할이 자주 발생해 DML 성능을 떨어뜨리기 때문

인덱스 분할 때문에 Shared모드 enq:TX-index contention 대기 이벤트가 자주 나타난다면 pctfree를 높게 설정하는 것을 고려할 수 있다.

하지만 pctfree를 높게 설정하는 것만으로는 전혀 효과가 없다.

인덱스에서의 pctfree는 인덱스를 처음 생성하거나 rebuild할때만 적용되기 때문

인덱스 분할에 의한 경합을 줄이려면 pctfree를 높이고 나서 인덱스를 rebuild해야 한다.

하지만 효과는 일시적이며 언젠가 그 빈공간이 다시 채워지기 때문 적당한 시점마다 rebuild 작업을 반복하지 않는한 근본적인 해결책이 되지는 못한다.(but rebuild하는데 걸리는 시간좌 부하도 무시할 수 없다.)

아래와 같은 예상효과가 확실할 때만 rebuild를 고려하는 것이 바람직하다.

-   인덱스 분할에 의한 경합이 현저히 높을때
-   자주 사용되는 인덱스 스캔 효율을 높이고자 할 떄, 특히 NL 조인에서 반복 액세스되는 인덱스 높이가 증가했을 때
-   대량의 delete 작업을 수행한 이후 다시 레코드가 입력되기까지 오랜 기간이 소요될 때
-   총 레코드 수가 일정한대도 인덱스가 계속 커질 때

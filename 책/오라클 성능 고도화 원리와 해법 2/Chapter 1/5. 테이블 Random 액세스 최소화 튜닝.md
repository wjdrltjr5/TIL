# 테이블 Random 액세스 최소화 튜닝

Random 액세스를 최소화 하기 위한 튜닝 방안

## 인덱스 컬럼 추가

인덱스를 새로 만드는건 부담스럽지만 기존 인덱스에 필요한 컬럼만 추가하는 것만으로 큰 효과를 얻을 수 있다.

## PK 인덱스에 컬럼 추가

NL 조인할 때 Inner 쪽에서 액세스될 때는 Random 액세스 부하가 만만치 않다.

특히 Outer 테이블에서 Inner 테이블 쪽으로 조인 액세스가 많은 상황에서 Inner 쪽 필터 조건에 의해 버려지는 레코드가 많다면 그 비효율은 매우 심각한 것일 수 있다.

PK 인덱스에는 컬럼을 추가할 수 없다. 그러다 보니 PK 컬럼 + 필터조건 컬럼 형태의 새로운 Non-Unique 인덱스를 추가하는 경우가 종종있다.

그럴 때 Non-Unique 인덱스를 이용해 PK제약을 설정한다면 인덱스 개수를 줄일 수 있다.

PK제약에는 중복 값 확인을 위한 인덱스가 반드시 필요하다. 인덱스가 없다면 값이 입력될 때마다 테이블 전체를 읽어 중복 값 존재 여부를 체크해야 하기 때문

중복 체크를 위해 반드시 Unique인덱스가 필요한 것은 아니며 Non-Unique 인덱스로도 가능하다.

Non-Unique 인덱스를 이용하면 중복 여부를 체크할 때 one-plus 스캔이 발생하는 약간의 비효율이 있기는 하지만 무시할 만하다.

PK제약을 위해 Non-Unique인덱스를 사용하도록 하는방법은 다음과 같다.

```sql
alter table dept drop primary key;

create index dept_x01 on dept(deptno, loc);

alter table dept add
constraint dept_pk primary key(deptno) using index dept_x01;
```

PK제약을 위해 사용되는 인덱스는 PK 제약 순서와 서로 일치하지 않아도 상관없다.

중복값 유무를 체크하는 용도이므로 PK 제약 컬럼들이 선두에 있기만 하면 된다.

[고객번호, 상품번호, 거래일자] PK 제약 컬럼 구성일때 사용가능한 인덱스 구성

-   거래일자 + 고객번호 + 상품번호
-   상품번호 + 거래일자 + 고객번호 + 거래구분
-   고객번호 + 거래일자 + 상품번호 + 매체구분 + 거래구분

불가능한 구성 (중복값 유무는 확인할 수 있지만 너무 비효율적)

-   고객번호 + 상품번호 + 거래구분 + 거래일자.

## 컬럼 추가에 따른 클러스터링 팩터 변화

인덱스에 컬럼을 추가함으로써 테이블 Random 액세스 부하를 줄이는 효과가 있지만 인덱스 클러스터링 팩터가 나빠지는 부작용을 초래할 수도 있다.

인덱스 내에서 키 값이 같은 레코드는 rowid순으로 정렬된다. 그런데 여기에 변별력이 좋은 컬럼을 추가하면 rowid 이전에 해당 컬럼 순으로 정렬되므로 클러스터링 팩터를 나쁘게 만드는 요인으로 작용한다.

(인덱스는 컬럼 + rowid로 구성 컬럼 변별력이 낮으면 rowid순으로 정렬되는 효과)

결론적으로 object_type처럼 변별력이 좋지 않은 컬럼뒤에 변별력이 좋은 다른 컬럼을 추가할때는 클러스터링 팩터 변화에 주의를 기울여야 한다.

## 인덱스만 읽고 처리

테이블 Random 액세스가 아무리 많더라도 필터 조건에 의해 버려지는 레코드가 거의 없다면 거기에 비효율은 없다.

테이블 엑세스가 아예 발생하지 않도록 인덱스 자체에서 필요한 컬럼을 모두 처리하는 것 (커버드 인덱스라고 부름)

## 버퍼 Pinning 효과 활용

오라클의 경우 한번 입력된 테이블 레코드는 절대 rowid가 바뀌지 않는다. 즉 레코드 이동이 발생하지 않는다.

따라서 미리 알고 있던 테이블 rowid 값을 이용해 레코드를 조회하는 것이 가능하다.(해당 레코드가 지워지지 않는다면)

```sql
select * from emp where rowid = :rid;
```

실행계획생에는 Table Access By UserROWID라고 표시된다.

미리 알고있던 rowid값이 아니더라도 아래처럼 인라인 뷰에서 읽은 rowid값을 이용해 테이블을 액세스하는 것도 가능하다.

```sql
-- 오라클이 서브쿼리 병합하지 않게 no_merger !
select /*+ ordered use_nl(b) rowid(b)*/ b.*
  from (select /*+ index(emp emp_pk) no_merge */ rowid rid
          from emp
         order by rowid) a
      , emp b
 where b.rowid = a.rid
```

위쿼리는 emp_pk 인덱스 전체를 스캔해 얻은 레코드를 rowid순으로 정렬한 다음(CF는 가장 완벽하게 좋은 상태가 됨)

한 건씩 순차적으로 테이블을 액세스하고 있다.

Random 액세스의 비효율은 한 건을 읽기 위해 블록을 통째로 읽기 때문에 발생하는 것인데 위와 같은 쿼리에 버퍼 Pinning 효과까지 나타난다면

한번의 액세스로 블록 안에 있는 모든 레코드를 다 읽어 들이는 셈이 된다. CF가 가장 좋을때 인덱스 손익분기점이 90%이상에서 결되는 것도 그 때문

그런 효과가 나타나기만 한다면 인덱스를 통해 아무리 많은 테이블 레코드를 액세스 하더라도 Random 액세스에 의한 비효율은 거의 존재하지 않게 되몬 SQL 튜닝시 가장 자주 사용되는 기법 중 하나가 될 것

## 수동으로 클러스터링 팩터 녹이기

테이블에는 데이터가 무작위로 입력되는 반면, 그것을 가리키는 인덱스는 정해진 키 순으로 정렬되기 때문에 대개 CF가 좋지 않기 마련

CF가 나쁜 인덱스를 이용해 많은 양의 데이터를 읽어야 할 때, SQL 튜닝이 가장 어렵다.

해당 인덱스 기준으로 테이블을 재생성함으로써 CF를 인위적으로 좋게 만드는 방법을 생각해 볼 수 있고 실제로 해보면 효과가 극적이다.

주의할점은 인덱스가 여러개인 상황에서 특정 인덱스를 기준으로 테이블을 재정렬하면 다른 인덱스의 CF가 나빠질 수 있다는것

따라서 인위적으로 CF를 높일 목적으로 테이블을 Reorg할 때는 가장 자주 사용되는 인덱스를 기준으로 삼아야 하며, 다른 인덱스를 사용하는 중요한 쿼리 성능에 나쁜 영향을 주지 않는지 반드게 체크해 봐야 한다.

이방법을 주기적으로 수행해야 한다면 관리비용이 증가하므로 테이블과 인덱스를 Rebuild하는 부담이 적고 효과가 확실할 때만 사용해야 한다.

## 차세대 시스템 구축시 주의사항

데이터 이관시에는 ASIS 대비 TOBE 시스템의 CF가 나빠지지 않았는지 조사하고 그 결과에 따라 적절한 조치를 취해 주어야 한다.

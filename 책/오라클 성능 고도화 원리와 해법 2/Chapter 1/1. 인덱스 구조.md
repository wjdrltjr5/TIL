# 인덱스 구조

## 범위 스캔

인덱스는 대용량 테이블에서 필요한 데이터만 빠르고 효율적으로 액세스할 목적으로 사용하는 오브젝트다

인덱스는 키 컬럼 순으로 정렬돼 있기 때문에 특정 위치에서 스캔을 시작해 검색 조건에 일치하지 않는 값을 만나는 순간 멈출 수 있다. 이것이 범위 스캔이 의미하는 바이다.

테이블도 범위 스캔이 가능한 경우가 있기는 하다 IOT는 특정 컬럼 순으로 정렬 성태를 유지마혀 값을 입력하므로 범위 스캔이 가능하다. 이를 제외한다면 일반적인 힙 구조 테이블에서 범위 스캔은 있을 수 없다.

## 인덱스 기본 구조

인덱스 중에서 가장 일반적으로 사용되는 B\*tree 인덱스 구조

루트를 포함한 브랜치 블록에 저장된 엔트리에는 하위 노드 블록을 찾아가기 위한 DBA정보를 갖고 최말단 리프 블록에는 인덱스 키 컬럼과 함께 해당 테이블 레코드를 찾아가기 위한 주소정보 (rowid)를 갖는다.

브랜치 노드의 각 ㅁ엔트리는 키 값과 하위 노드를 가리키는 블록 주소를 갖는다. 그런데 각 브랜치 노드의 첫번째 엔트리 LMC는 키 값을 가지지 않는다. (키 값을 가진 첫번째 엔트리 보다 작은 값의 의미를 가진다.)

오라클은 인덱스 구성 컬럼이 모두 null인 레코드는 저장하지 않는다.

인덱스와 테이블 레코드 간에는 서로 1:1 대응 관계를 갖는다. 참고로 클러스터 인덱스는 1:M 관계를 갖는다.

인덱스 리프 노드상의 레코드와 테이블 레코드 간에는 1:1 관계 값도 서로 일치한다.

따라서 테이블 레코드에서 값이 갱신되면 리프 노드 인덱스 키 값도 같이 갱신된다(delete &insert)

반면 리프 노드상의 엔트리 키값이 갱신되더라도 브랜치 노드까지 값이 바뀌지는 않는다. (B tree 특성)

브랜치 블록에 놓인 엔트리는 자신의 키 값과 같거나 큰 값을 담는 하위 노드 블록을 포인팅하는 것으로써 그 키 값은 자식 노드가 갖는 값의 범위를 나타내기 때문

`브랜치 노드는 인덱스 분할에 의해 새로운 블록이 추가되거나 삭제될 때만 갱신된다.`

요약

-   리프 노드상의 인덱스 레코드와 테이블 레코드 간에는 1:1 관계
-   리프 노드상의 키 값과 테이블 레코드 키 값은 서로 일치
-   브랜치 노드상의 레코드 개수는 하위 레벨 블록 개수와 일치
-   브랜치 노드상의 키 값은 하위 노드가 갖는 값의 범위를 의미

## 인덱스 탐색

인덱스 탐색 과정을 수직적 탐색과 수평적 탐색으로 구분할 수 있다.

-   수직적 탐색 : 수평적 탐색을 위한 시작 지점을 찾는 과정 루트에서 리프블록까지의 진행

-   수평적 탐색 : 범위 스캔, 리프 블록을 인덱스 레코드간 논리적 순서에 따라 좌에서 우, 우에서 좌로 스캔한다.

CLARK를 찾는과정

-   루트 블록을 스캔하면서 왼쪽 브랜치 블록으로 갈지 오른쪽 브랜치 블록으로 갈지를 결정

-   찾아간 블록을 스캔하면 그 다음 찾아갈 인덱스 블록을 탐색

-   도착한 리프블록에서 CLARK를 찾으면 수평적 탐색 과정으로 넘어가고 못찾으면 인덱스 탐색을 마친다.

-   인덱스 리프 블록을 스캔하면서 값이 CLARK인지 확인한다.

-   CLARK이면 거기서 얻은 ROWID를 이용해 해당 테이블 레코드를 찾아가 필요한 컬럼 값들을 얻는다.

    -   인덱스 컬럼만으로 해결가능하다면 이 과정은 생략

-   4번과 5번과정을 반복하다가 검색 조건을 만족하지 못하는 레코드를 만나는 순간 멈춘다.

## 브랜치 블록 스캔

브린 블록을 따라 수직적 탐색을 진행할 때는 찾고자 하는 값보다 키 값이 작은 엔트리를 따라 내려간다. (중복값 대비)

## 결합 인덱스 구조와 탐색

수직적 탐색과정에서 선행 컬럼만을 가지고 필터링이 아니라 후행 컬럼까지 합쳐서 필터링한다.

## ROWID 포맷

rowid에는 데이터파일 번호, 블록 번호, 로우 번호 같은 테이블 레코드의 물리적 위치정보를 포함한다.

테이블 레코드를 찾아가는 데 필요한 주소 정보이므로 테이블 자체에 저장되는 것이 아니라 인덱스에 저장된다.

인덱스를 거치치 않는 쿼리에서 rowid를 요구하면 오브젝트 및 데이터파일 번호, 그리고 그 파일 내에서의 상대적인 블록 번호가 데이터 블록 헤더에 저장돼 있기 때문에 전혀 어렵지 않다.

6바이트를 차지하는 rowid

-   파티션되지 않은 일반 테이블에 생성한 인덱스
-   파티션된 테이블에 생성한 로컬 파티션 인덱스

10바이트를 차지하는 rowid

-   파티션 테이블에 생성한 글로벌 파티션 인덱스
-   파티션 테이블에 생성한 비 파티션 인덱스

오라클 7버전 까지 사용하던 제한 rowid 포맷

-   데이터파일번호 4자리
-   블록번호 8자리
-   로우번호 4자리

오라클 8버전 부터 사용되기 시작한 확장 rowid 포맷

-   데이터 오브젝트 번호 6자리
-   데이터파일 번호 3자리
-   블록 번호 6자리
-   로우 번호 3자리

# 인덱스 설계

## 가장 중요한 두 가지 선택 기준

인덱스 스캔 방식에 여러 가지가 있지만 가장 정상적이고 일반적인 것은 Index Range Scan이다.

이를 위해서는 인덱스 선두 컬럼이 조건절에 반드시 사용되어야만 한다. 따라서 결합 인덱스를 구성할때 첫 번째 기준은 조건절에 항상 사용되거나 적어도 자주 사용되는 컬럼들을 선정하는 것

두 번째 기준은 그렇게 선정된 컬럼 중 = 조건으로 자주 조회되는 컬럼을 앞쪽에 두어야 한다는 것

-   조건절에 항상 사용되거나, 자주 등장하는 컬럼들을 선정한다.
-   = 조건으로 자주 조회되는 컬럼들을 앞쪽에 둔다.

## 인덱스 설계는 공식이 아닌 전략과 선택의 문제

앞서 제시한 두 가지 선택 기준이 일바넉으로 통용될 수 있는 기본 공식임을 틀림 없지만 인덱스 설계가 그렇게 간단하지는 않다.

`인덱스 필터 역할하는 것만 고려해도 랜덤 액세스를 줄일 수 있으니 이득`

### 스캔 효율성 이외의 판단 기준

자주 사용되는 = 조건이라는 애초의 기준은 인덱스 스캔의 효율성만을 고려한 것

실제 인덱스를 설계할 때는 시스템 전체적인 관점에서의 추가적인 요소들을 고려해야 한다.

-   쿼리 수행 빈도
-   업무상 중요도
-   클러스터링 팩터
-   데이터량
-   DML 부하
-   저장공간
-   인덱스 관리 비용 등

### 인덱스 설계는 공식이 아닌 전략과 선택의 문제

인덱스 설계가 어려운 이유는 개별 쿼리 성능뿐만 아니라 그 개수를 최소화함으로써 DML 부하를 줄이는 것까지 목표로 삼아야 하기 때문

핵심적인 액세스 경로 한두 개를 전략적으로 선택하고, 그것을 중심으로 나머지 액세스 경로는 약간의 비효율이 있더라도 목표한 성능 수준에 도달하도록 구성해 주면 된다.

## 결합 인덱스 컬럼 순서 결정 시, 선택도 이슈

인덱스 생성 여부를 결정할 때는 선택도가 충분히 낮은지가 중요한 판단 기준

인덱스를 스캔하면서 테이블을 액세스하는 양이 일정 수준을 넘는 순간 Full Table Scan보다 오히려 느려지기 때문.

따라서 선택도가 높은 인덱스는 생성해 봐야 효용가치가 별로 없다.

결한 인덱스 컬럼간 순서를 정할 때도 선택도가 낮은 즉 변별력이 높은 쪽(카티널리티 수치가 높은)을앞에 두는 것이 좋다고 흔히 알려져 있는데 어느쪽이 유리한지는 상황에 따라 다르다.

### 선택도가 액세스 효율에 영향을 주지 않는 경우

= 조건으로 항상 사용되는 컬럼들을 앞쪽에 위치시켰다면 그중 선택도가 낮은 것을 앞쪽에 두려는 노력은 의미없는 것이거나 오히려 손해일 수 있다.

`수직적 탐색 과정에선( 몇몇 경우를 제외하고) 모든 인덱스 컬럼을 비교 조건으로 사용하므로 스캔 시작 지점은 어느 것을 앞에 두더라도 동일하게 결정된다.`

여러 차례 강조 했듰이 선행 컬럼이 모두 = 조건이면 첫 번째 범위검색 조건까지의 인덱스 레코드들은 모두 한 곳에 모여 있다.

### 선택도가 높은 컬럼을 앞쪽에 두는 것이 유리한 경우

고객 등급(선택도가 높음)을 선두에 두면 나중에 이 컬럼이 조건절에서 누락되거나 범위검색 조건으로 조회되는 일이 생기더라도 Index Skip Scan을 효과적으로 활용할 수 있어 유리하다.

Index Skip Scan은 선행 컬럼의 Distinct Value 개수가 적고(중복도가 높고) 후행 컬럼의 Distinct Value 개수가 많아야 효율적이다.

변별력이 좋은 컬럼을 선두에 두는 것이 좋다는 상식은 오라클 5버전에서 사용하던 인덱스 압축 방식 때문에 생긴 것이고 그런 특징은 오라클 6에서 로우 단위 Lock이 구현되면서 사라졌다.

하지만 `인덱스 생성 여부를 결정할 때는 선택도가 충분히 낮은지가 중요한 판단 기준` 이걸 잊지 말자 선택도가 너무 높으면 풀스캔이 좋다.

### 상황에 따라 유 . 불리가 바뀌는 경우

선택도가 높은 컬럼(예 고객등급)을 선두에 두면 나중에 범위검색 조건이 사용되거나 아예 조건절에서 누럭되더라도

Index Skip Scan 또는 In-List를 활용할 수 있어 유리하다. 다만 이들 기법이 효과를 발휘할 정도로 Distinct Value개수가 충분히 적은지가 관건이다.

선택도가 낮은 컬럼을 선두에 두면 이를 범위검색 조건으로 조회하는 일이 생겼을 때 불리하지만

입력 값의 범위가 좁다면 비효율이 크지 않아 Index Skip Scan 이나 IN-List를 활용하지 못하더라도 오히려 유리할 수 있다.

#### 선택도가 낮은 컬럼을 앞쪽에 두는 것이 유리한 경우

`범위검색 조건을 사이에 둔 컬럼끼리는 선택도가 낮은 컬럼을 앞쪽에 두는 것이 유리하다.`

두개의 인덱스 구성요소

-   고객번호 + 거래일자(범위조건) + 상품번호
-   상품번호 + 거래일자(범위조건) + 고객번호

가 있을경우 고객번호 + 거래일자(범위조건) + 상품번호 를 사용하는 것이 유리하다.

2번쨰 인덱스는 변별력이 좋은 고객번호가 필터 역할을 하므로 비효율적이다.

1번 인덱스는 고객번호와 거래일자 조건에 의해 100개 레코드를 스캔하고서 1개 레코드를 최종 선택한다면.

2번 인덱스는 상품번호와 거래일자 조건으로 10000개 레코드를 스캔하고서 1개 레코드를 선택한다.

### 선택도가 낮은 컬럼을 선택하는 것이 유리한 경우

선택도가 낮은 고객번호를 위해 인덱스를 사용해야 더 적은 양의 테이블 Random 액세스가 발생하기 때문

`결론적으로 결합 인덱스 컬럼간 순서를 정할 때는 개별 컬럼의 선택도보다는 조건절에서 어떤 형태로 자주 사용되는지, 사용빈도는 어느 쪽이 높은지, 데이터를 빠르게 검색하는 데에 어느쪽 효용성이 높은지 등이 더 중요한 판단기준이다.`

## 소트 오퍼레이션을 생략하기 위한 컬럼 추가.

인덱스는 항상 정렬 상태를 유지마흐모 order by, group by를 위한 소트 연산을 생략할 수 있도록 해준다.

따라서 조건절에 사용되지 않은 컬럼이더라도 소트 연산을 대체할 목적으로 인덱스 구성에 포함시킴으로써 성능 개선은 도모할 수 있다.

인덱스를 이용해 소트 연산을 대체하려면, 인덱스 컬럼 구성과 같은 순서로 누락없이(뒤쪽 컬럼 누락되는 것은 상관없음) order by절에 기술해 주어야 한다.

아래처럼 order by 절에 기술한 순서가 인덱스 순서와 일치하기만 한다면 조건절에서 어떤 연산자로 비교하더라도 정렬 작업이 생략될 수 있다.

```sql
select * from t
where a between 1 and 2
and b not in (1, 2)
and c between 2 and 3
```

정렬 작업을 생략할 수 있다는 것이지 옵티마이저가 항상 그런 선택을 한다는 뜻은 아니다.

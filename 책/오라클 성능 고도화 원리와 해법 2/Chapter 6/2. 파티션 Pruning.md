# 파티션 Pruning

파티션 Pruning은 하드파싱이나 실행 시점에 SQL 조건절을 분석하여 읽지 않아도 되는 파티션 세그먼트를 액세스 대상에서 제외시키느 ㄴ기능이다.

파티션 테이블에 대한 쿼리나 DML을 수행할 때 극적인 성능 개선을 가져다주는 핵심 원리가 파티션 Pruning에 있다고 할 숭 ㅣㅆ다.

## 기본 파티션 Pruning

기본 파티션 Pruning 기법으로는 아래 두가지가 있다.

-   정적 파티션 Pruning : 파티션 키 컬럼을 상수 조건으로 조회하는 경우에 작동하며, 액세스할 파티션이 쿼리 최적화 시점에 미리 결정되는 것이 특징

    -   실행계획의 Pstart와 Pstop컬럼에는 액세스할 파티션 번호가 출력된다.

-   동적 파티션 Pruning : 파티션 키 컬럼을 반인드 변수로 조회하면 쿼리 최적화 시점에는 액세스할 파티션을 미리 결정할 수 없다.
    -   실행 시점이 돼서야 사용자가 입려한 값에 따라 결정되며,
    -   실행 계획의 Pstart와 Pstop 컬럼에는 KEY라고 표시된다. NL조인할 때도 Inner 테이블이 조인 컬럼 지군으로 파티셔닝 돼 있다면 동적 Pruning이 작동한다.

실행계획상에는 PARTITION RANGE ITERATOR로 표시됨

### 동적 파티션 Pruning시 테이블 레벨 통계 사용

바인드 변수를 사용하면 최적화 시점에 파티션을 확정할 수 없어 동적 파티션 Pruning이 일어난다고 했는데 같은 이유로 쿼리 최적화에 테이블 레벨 통게가 사용된다.

반면 정적 테이블 Pruning일 때는 파티션 레벨 통계가 사용된다.

테이블 레벨 통게는 파티션 레벨 통게보다 다소 부정확하기 때문에 옵티마이저가 가끔 잘못된 실행계획을 수립하는 경우가 생기며 이는 바인드 변수 때문에 생기는 대표적인 부작용 중 하나다.

## 서브쿼리 Pruning

조인에 사용되는 고급 파티션 Pruning 기법으로는 아래 두 가지가 있다.

-   서브쿼리 Pruning
-   조인 필터 Pruning

대용량 주문 테이블을 Random 액세스 위주의 NL 방식으로 조인한다면 결고 좋은 성능을 기대하기 어렵다

그렇다고 해시 조인이나 소트 머지 조인으로 처리하기도 부담스럽다. 이럴때 오라클은 Recursive 서브쿼리를 이용한 동적 파티션 Pruning을 고려한다.

이른바 서브쿼리 Pruning이라고 불리는 메커니즘으로서, 위 쿼리에 대해 내부적으로 아래와 같은 서브쿼리가 수행된다.

```sql
select distinct TBL$OR$IDX$PART$NUM(주문, 0, 1, 0, a.일자)
from (select 일자 from  일자 where 분기 >= 'Q20071') a
order by 1
```

이쿼리를 수행하면 액세스해야 할 파티션 번호 목록이 구해지며, 이를 이용해 필요한 주문 파티션만 스캔할 수 있다.

실행계획에는 PARTITION RANGE SUBQUERY로 표시된다. (KEY(SQ))

이 방식으로 파티션을 Pruning 하려면 드라이빙 테이블을 한 번 더 읽게 되므로 경우에 따라 총 비용이 오히려 증가할 수 있다.

따라서 서브쿼리 Pruning 적용 여부는 옵티마이저가 비용을 고려해 내부적으로 결정한다. 옵티마이저 결정에 영향을 미치는 Hidden 파라미터는 아래 표와 같다.

-   \_subquery_pruning_cost_factor(기본값 20) : 파티션 테이블이 recursive 서브쿼리 대상 테이블보대 20(기본값)배 이상 클때만 이 방식을 사용

    -   바꿔말하면 recursive 서브쿼리 수행 비용이 파티션 테이블에 있는 모든 데이터를 액세스 하는 비용의 5%를 초과하지 않아야 효과적이라는 가정을 세운것

-   \_subquery_pruning_reduction(기본값 50): 드라이빙 테이블 조건절에 의해 액세스되는 데이터가 드라이빙 테이블 전체 건수의 50%를 넘지 않아야 함을 뜻한다.

    -   드라이빙 테이블 조건절에 의한 선택도를 가지고 반대편 파티션 테이블 Pruning 비율을 추정하는 것이다.

-   \_subquery_pruning_enabled(기본값 true) : 서브쿼리 Pruning을 활성화

제거될 것으로 예상되는 파티션 개수가 상당히 많고, where 조건절을 가진 드라이빙 테이블이 파티션 테이블에 비해 상당히 작을 때만 서브쿼리 Pruning이 작동한다는 사실을 알 수 있다.

참고로 아래와 같이 설정하면 옵티마이저에 의해 계산된 비용과 상관없이 항상 서브쿼리 Pruning을 실시한다.

-   \_subquery_pruning_cost_factor = 1
-   \_subquery_pruning_reduction = 100

## 조인 필터 Pruning

서브쿼리 Pruning은 드라이빙 테이블을 한 번 더 액세스하는 추가 비용이 발생한다. 그래서 11g부터 오라클은 블룸 필터 알고리즘을 기반으로 한 조인 필터 Pruning방식을 도입하였다.

### 블룸필터 알고리즘

아래처럼 A,B 두개의 집합이 있고 두 집합간의 교집합을 찾으려고 할때

-   집합 A = {175, 442, 618}
-   집합 B = {175, 327, 432, 548}

만약 각각의 집합이 크다면 잡합 B에 있는 각 원소마다 집합 A를 뒤지면서 같은 값을 가진 원소가 있는지 확인해 봐야 한다.

`교집합이 크다면 많은 일량에도 불구하고 비효율은 없다고 할 수 있다. 하지만 교집합이 매주 작다면 이 방식은 비효율적이다. 블룸필터는 교집합이 작을 때 큰 효과를 발휘한다.`

기본 알고리즘은 다음과 같다.

1. n개의 비트 Array를 할당하고 (1~n) 각 비트를 0으로 설정한다.
2. n개의 값(1~n 중 하나)을 리턴하는 m개의 해시 함수를 정의하며, 서로 다른 해시 알고리즘을 사용한다.

    - m 개의 해시함수는 다른 입력 값에 대해 우연히 같은 출력 값을 낼 수도 있다.

3. 집합 A의 각 원소마다 차례로 m개의 해시 함수를 모두 적용한다. 그리고 각 해시 함수에서 리턴된 값(1~n)에 해당하는 비트를 모두 1로 설정한다.

4. 교집합을 찾을 준비가 끝났다 이제 집합 B의 각 원소마다 차례로 m개의 해시 함수를 모두 적용한다. 그리고 원소별로 해시 함수에서 리턴된 값 (1~n)에 해당하는 비트를 모두 확인한다.

-   하나라도 0으로 설정돼 있으면 그 원소는 집합 A에 없는 것이다. 잘못된 음수는 불가능하기 때문 (집합 A에 있는값인데 0으로 남았을 리가 없다.)

-   모두 1로 설정돼 있으면 그 원소는 집합 A에 포함될 가능성이 있는 값이므로 이때만 집합 A를 찾아가 실제 같은 값을 가진 원소가 있는지 찾아본다

-   모두 1로 설정돼 있는데오 집합 A에 실제 그값이 있는지 확인해야 하는 이유는 잘못된 양수가 간으하기 때문이다. (즉 없는 값인데 모두 1로 설정될 수 있다.)

블룸 필터의 역할은 교집합에 해당하는 원소를 찾는 데 있지 않고 교집합이 아닌 것이 확실한 원소를 찾는 데에 있다.

### 블룸 필터 알고리즘에서 false positive(거짓된 양수)를 줄이는 방법

false positive가 발생해 불필요하게 집합 A를 확인해야 한다. 더 많은 비트를 할당하거나 더 많은 해시 함수를 사용하면 false positive 발생 가능성은 줄어든다

공간/시간 효율성과 false positive발생가능성은 서로 트레이브 오프 관계이므로 적정한 개수의 비트와 해시 함수를 사용하는 것이 과제다.

### 조인 필터(= 블룸 필터)Pruning

오라클은 성능 향상을 위해 여러 곳이 이 알고리즘을 사용하고 있는데, 그중 대표적인 것인 파티션 Pruning이다.

11g부터 적용되지 시작한 이 기능은 파티션 테이블과 조인할 때 읽지 않아도 되는 파티션을 제거해 주는 것으로써 조인 필터 Pruning 또는 블룸 필터 Pruning이라고 부른다.

## SQL 조건절 작성시 주희 사항

like 연산자를 사용하면 불빌표하게 더 많은 파티션을 읽는다.

ex 200901% 를 사용하면 %에 들어갈 수 있는 경우의 수가 너무 많아진다. 차라리 between을 사용하라

인덱스 스캔 효율화 원리에서도 like보다 between이 유리한 이유를 설명했는데 파티션 Pruning을 위해서라도 like 보다는 가급적 between연산자를 이용해 정확한 검색구간을 지정하는 것이 바람직하다.

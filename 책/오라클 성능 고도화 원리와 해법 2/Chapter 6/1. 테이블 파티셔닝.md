# 테이블 파티셔닝

파티셔닝은 테이블과 인덱스 데이터를 파티션 단위로 나누어 저장하는 것을 말한다.

테이블을 파티셔닝하면 하나의 테이블일지라도 파티션 키에 따라 물리적으로는 별도의 세그먼트에 데이터가 저장되며, 인덱스도 마찬가지다.

파티셔닝이 필요한 이유를 관리적 측면과 성능적 측면으로 나누어 볼 수 있다.

-   관리적 측면: 파티션 단위 백업, 추가, 삭제 변경
-   성능적 측면: 파티션 단위 조회 및 DML 수행

파티셔닝도 클러스터, IOT와 마찬가지로 관련 있는 데이터가 흩어지지 않고 물리적으로 인접하도록 저장하는 클러스터링 기술에 속한다.

클러스터와 다른점은 세그먼트 단위로 모아서 저장한다는 점이다

## 파티션 기본 구조

### 수동 파티셔닝

파티션 테이블이 처음 제공되기 시작한 것은 오라클 버전8부터다.

그 이전 버전에서는 파티션 뷰를 통해 파티션 기능을 구현했으며, 이를 수동 파티셔닝이라고 부른다.

파티션 뷰의 핵심 기능은 뷰 쿼리에 사용된 조건절에 부합하는 테이블만 읽는다는 데에 있다.

### 파티션 테이블

오라클 8에서 도입된 기능 아래와 같이 간편하게 파티션을 정의할 수 있을뿐 아니라 기능적으로도 더 낫다.

```sql
create table partition_table
partition by range(deptno)(
  partition p1 values less than(20)
, partition p2 values less than(30)
, partition p3 values less than(40)
)
as
select * from emp;

create index ptable_empno_idx on partition_table(empno) LOCAL;
```

partition by 절은 파티션 뷰의 Base 테이블에 체크 제약을 설정하는 것과 같은 역할을 한다.

인덱스를 만들 때로 local 옵션을 지정했으므로 각 파티션별로 개별적인 인덱스가 만들어져 파티션 뷰 Base 테이블에 각각 인덱스를 만든 것과 같은 모습이다.

쿼리 조건절에 부합하는 세그먼트만을 찾아 읽는 기능은 예나 지금이나 옵티마이저의 몫이다.

파티션 되지 않은 일반 테이블일때는 테이블과 세그먼트가 1:1 관계이지만 파티션 테이블일 때는 1:M관계다. 인덱스를 파티셔닝할때도 마찬가지다.

버전이 올라가면서 기능이 계속 확장되고 있는 테이블 파티션 유형에는 아래와 같은 것들이 있다.

-   Range 파티셔닝
-   해시 파티셔닝
-   리스트 파티셔닝
-   Range-해시 파티셔닝
-   Range-리스트 파티셔닝
-   Range-Range 파티셔닝
-   리스트 - 해시 파티셔닝
-   리스트 - 리스트 파티셔닝
-   리스트 - Range 파티셔닝

## Range 파티셔닝

오라클 8버전 부터 제공된 가장 기초적인 파티션이 방식 주로 날짜 컬럼을 기준으로 한다.

파티션 키로는 하나 이상의 컬럼을 지정할 수 있고, 최대 16개까지 가능ㅎ다.

DB관리자의 실수로 신규 파티션 생성을 빠뜨리면 월초 또는 연초에 데이터가 입력되지 않는 에러가 발생하므로 maxvalue 파티션을 반드시 생성해 두는 것이 좋다.

11g부터는 파티션을 생성할때 interval 기준을 정의함으로써 정해진 간격으로 파티션이 자동 추가되도록 할 수 있다.

## 해시 파티셔민

파티션 키에 해시 함수를 적용한 결과 값이 같은 레코드를 같은 파티션 세그먼트에 저장해 두는 방식이며, 주로 고객ID처럼 변별력이 좋고 데이터 분포가 고른 컬럼을 파티션 기준 컬럼으로 선정해야 효과적이다.

검색할때는 조건절 비교값에 해시 함수를 적용해 읽어야 할 파티션을 결정하며,

알고리즘 특성상 등치조건 또는 In-List 조건으로 검색할 때만 파티션 Pruning이 작동한다.

테이블 파티셔닝 여부를 결정할 때는 데이터가 얼마나 고르게 분산될 수 있느냐가 가장 중요한 관심사항

해시 파티셔닝할 때 특히 데이터 분포를 신중히 고려해야 하는데, 사용자가 직접 파티션 기준을 정하는 Range, 리스트 파티셔닝과 다르게 파티션개수만 결정하고 데이터 분산하는 해싱 알고리즘은 오라클에 의해 결정되기 때문

파티션 키를 잘못 선정하면 데이터가 고르게 분산되지 않아 파티셔닝의 이점이 사라질 수 있다.

오라클은 특정 파티션에 데이터가 몰리지 않도록 하려면 파티션 개수를 2의 제곱으로 설정할 것을 권고한다.

이 규칙을 따르더라도 파티션 키 컬럼의 Distinct Value 개수가 적다면 데이터가 고르게 분산되지 않을 가능성이 높으므로 이때는 리스트 파티션을 이용해서 기준을 수동으로 결정해 주는 것이 낫다.

### 병렬 쿼리 성능 향상

데이터가 모든 파티션에 고르게 분산돼 있다면 더구나 각 파티션이 서로 다른 디바이스에 저장돼 있다면 병렬 I/O성능을 극대화할 수 있다.

반대로 말하면 데이터가 고르게 분산되지 않을때는 병렬쿼리효과가 반감된다.

### DML 경합 분산

병렬 쿼리 성능 향상뿐 아니라 동시 입력이 많은 대용량 테이블이나 인덱스에 발생하는 경합을 줄일 목적으로도 해시 파티셔닝을 사용한다.

대용량 거래 테이블일수록 DML발생량이 많아 경합 발생 가능성도 그만큼 크다.

데이터가 입력되는 테이블 블록에도 경합이 발생할 수 있지만, 그보다는 입력할 블록을 할당받기 위한 Freelist 조회떄문에 세그먼트 헤더 블록에 대한 경합이 더 자주 발생한다.

그럴 때 테이블을 해시 파티셔닝하면 세그먼트 헤더 블록에 대한 경합을 줄일 수 있다.

Right Growing 인덱스도 자주 경합 지점이 되곤 하는데, 맨 우측 끝 블록에만 값이 입력되는 특징 때문이다.

이때도 인덱스를 해시 파티셔닝함으로써 경합 발생 가능성을 낮출 수 있다.

경합 분산이나 병렬 쿼리 성능향상, 두 가지 모두 트랜잭션이 많이 발생하는 대용량 거래 테이블일 때라야 효과가있다. 단일 해시 파티셔닝 보다는 Range와 해시를 조합한 결합 파티셔닝을 주로 사용하게 되는 이유가 여기에 있다.

## 리스트 파티셔닝

오라클 9i버전부터 제공되기 시작한 리스트 파티셔닝은 사용자에 의해 미리 정해진 그룹핑 기준에 따라 데이터를 분할 저장하는 방식이다.

Range 파티션에선 값의 순서에 따라 저장할 파티션이 결정되지만, 리스트 파티션에서는 순서와 상관없이 불연속적인 값의 목록으로써 결정된다.

리스트 파티셔닝에는 단일 컬럼으로만 파티션 키를 지정할 수 있다. Range 파티션에 maxvalue와 마찬가지로 리스트 파티션에도 default 파티션을 생성해 두어야 안전하다.

## 결합 파티셔닝

결합 파티셔닝을 구성하면 서브 파티션마다 세그먼트를 하나씩 할당하고, 서브 파티션 단위로 데이터를 저장한다.

주 파티션 키에 따라 1차적으로 데이터를 분배하고, 서브 파티션 키에 따라 최종적으로 저장할 위치를 결정한다.

11g 부터는 주 파티션이 해시 방식이 아닌 모든 조합을 지원한다.

## 11g부터 추가된 파티션 유형

### Reference 파티셔닝

부모 테이블 파티션 키를 이용해 자식 테이블을 파티셔닝하는 기능

### Interval 파티셔닝

Range 파티션을 생성할때 interval 기준을 정의함으로써 정해진 간격으로 파티션이 자동 추가되도록 할 수 있다.

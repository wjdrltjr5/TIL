# 인덱스 파티셔닝

## 인덱스 파티셔닝 유형

인덱스 파티셔닝으 테이블 파티션닝과 맞물려 다양한 구성이 존재한다. 따라서 테이블을 다음과 같이 구분하고서 인덱스 파티션 유형에 대한 설명을 시작해야 한다.

-   비 파티션 테이블
-   파티션 테이블

인덱스도 테이블처럼 파티션 여부에 따라 비 파티션 인덱스와 파티션 인덱스로 나뉘고

파티션 인덱스는 각 인덱스 파티션이 담당하는 테이블 파티션 범위에 따라 글로벌과 로컬로 나뉜다.

-   비 파티션 인덱스
-   글로벌 파티션 인덱스
-   로컬 파티션 인덱스

로컬 파티션 인덱스는 각 테이블 파티션과 인덱스 파티션이 서로 1:1 대응 관계가 되도록 오라클이 자동으로 관리하는 파티션 인덱스를 말하낟.

로컬이 아닌 파티션 인덱스는 모두 글로벌 파티션 인덱스에 속하며, 테이블 파티션과 독립적인 구성을 갖는다.

-   글로벌 인덱스 : 비 파티션 인덱스 + 글로벌 파티션 인덱스

## 로컬 파티션 인덱스

로컬 파티션 인덱스는 계절별로 별도 색인을 다는 것과 같다. 따라서 따라서 각 인덱스 파티션이 테이블 파티션과 1:1 대응관계를 가지며 태이블 파티션 속성을 그래도 상속받는다

파티셔닝을 전제로 하므로 흔히 로컬 인덱스라고 줄여서 부른다.

파티션 키를 사용자가 따로 정의하지 않아도 오라클이 자동으로 관리한다는 것이 특징인데

테이블 파티션과 1:1 관계가 되도록 사용자가 수동으로 인덱스 파티션을 구성하더라도 이를 로컬 파티션 인덱스라고 부르지 않는 이유가 여기에 있다.

로컬 파티션 인덱스는 항상 테이블 파티션과 1:1관계를 형성하므로 만약 테블이 결합 파티셔닝 돼있다면 인덱스도 같은 단위로 파티셔닝된다.

로컬 파티션 인덱스가 갖는 장점은 무엇보다 관리적 편의성에 있다. 테이블 파티션 구성에 변경이 생기더라고 인덱스를 재생성할 필요가 없어 관리 비용이 아주 적다.

## 비 파티션 인덱스

비 파티션 인덱스는 말 그대로 파티셔닝 하지 않은 인덱스를 말한다.

테이블이 파티셔닝 돼 있다면 1:M 관게에 놓인다. 즉 하나의 인덱스 세그먼트가 여러 테이블 파티션 세그먼트와 관계를 갖는다. 그런 의미에서 비 파티션 인덱스를 글로벌 비파티션 인덱스 라고 부르기도 한다.

## 글로벌 파티션 인덱스

글로벌 파티션 인덱스는 테이블 파티션과 독립적인 구성을 갖도록 파티셔닝 하는것을 말한다. 테이블은 파티셔닝돼 있지 않을 수도 있다.

독립적 구성이라는 점에서 효용성이 높을 것처럼 보이지만 몇몇 제약사항 때문에 오히려 효용성이 낮은 편이다.

글로벌 파티션 인덱스 사용을 불편하게 만드는 가장 큰 제약은 기준 테이블의 파티션 구성에 변경이 생길 때마다 인덱스가 unusable 상태로 바뀌고 그때마다 인덱스를 재생성해야 한다는 것

이 제약은 비 파티션 인덱스일 때도 똑같이 나타난다.

9i 부터 아래와 같이 update global indexes 옵션을 주면 파티션 DDL 작업에 의해 영향받은 인덱스 레코드를 자동으로 갱신 해 주므로 인덱스가 unusable 상태로 빠지지 않는다.

```sql
alter table...
split partition ...
update global indexes;
```

하지만 파티션이 DDL로 인해 영향받는 레코드가 전체의 5% 미만일 때만 유용하다. 다시 말해 5%이상일 때는 인덱스를 재생성하는 것보다 오히려 늦다.

### 테이블 파티션과의 관계

오라클이 자동으로 관리해주는 1:1관게가 아닌 파티션 인덱스는 모두 글로벌 파티션 인덱스라고 했다.

인덱스를 테이블 파티션과 같은 키 컬럼으로 글로벌 파티셔닝한다면 파티션 기준 앖을 어떻게 정의하느냐에 따라 1:M, M:1, M:M 관계가 모두 가능하다. (하지만 본질적인 관계는 M:M 으로 이해해야 한다.)

로컬 파티션 인덱스 처럼 테이블과 1:1관계가 되도록 수동으로 구성하더라도 여느 글로벌 파티션과 마찬가지로 기준 테이블 구성에 변경이 발생할 때마다 인덱스를 재생성해야 한다.

인덱스를 테이블 파티션과 다른 키 컬럼으로 글로벌 파티셔닝할 수도 있는데, 이때는 테이블 파티션과 인덱스 파티션 간에는 항상 M:M관계가 형성된다.

### 글로벌 해시 파티션 인덱스

10g부터는 글로벌 해시 파티션도 가능해 졌다. 즉 테이블과 독립적으로 인덱스만 해시 키 값에 따라 파티셔닝할 수 있게 되었다.

글로벌 해시 파티션 인덱스는 Right Growing 인덱스 처럼 Hot 블록이 발생하는 인덱스의 경합을 분산할 목적으로 사용된다.

글로벌 경합 인덱스 파티셔닝은 여전히 불가능하다.

## Prefixed vs NonPrefixed

파티션 인덱스를 Prefixed와 NonPrefixed로 나눌 수도 있다. 이는 인덱스 파티션 키 컬럼이 인덱스 구성상 왼쪽 선두 컬럼에 위치하는지에 따른 구분이다.

-   Prefixed : 파티션 인덱스를 생성할 때, 파티션 키 컬럼을 인덱스 키 컬럼 왼쪽 선두에 두는 것을 말한다.

-   Nonprefixed : 파티션 인덱스를 생성할때, 파티션 키 컬럼을 인덱스 키 컬럼 왼쪽 선두에 두지 않는 것을 말한다, 파티션 키가 인덱스 컬럼에 아예 속하지 않을 때도 여기에 속한다.

글로벌 파티션 인덱스는 Prefixed 파티션만 지원되므로 결과적으로 세 개의 파티션 인덱스가 있고, 비 파티션 인덱스를 포함해 아래 네 가지 유형으로 최종 정리할 수 있다.

-   비파티션 인덱스
-   글로벌 Prefixed 파티션 인덱스
-   로컬 Prefixed 파티션 인덱스
-   로컬 Nonprefixed 파티션 인덱스

### 인덱스 파티셔닝 예제

`Unique 파티션 인덱스를 만들 때는 파티션 키 컬럼이 인덱스 컬럼에 포함돼 있어야 한다.`

`비 파티션 인덱스를 만들 떄는 그런 제약이 없으므로 에러 없이 Unique 인덱스가 만들어 진다.`

로컬 파티션 인덱스에는 Nonprefixed가 허용되지만 글로벌 파티션 인덱스에는 허용되지 않는다. (참고로 비 파티션 인덱스에는 이런 제약이 없다.)

## 글로벌 파티션 인덱스의 효용성

결론부터 말하면 글로벌 파티션 인덱스는 경합을 분산시키려고 글로벌 해시 파티셔닝하는 경우외에는 거의 사용되지 않는 실정이다.

-   비파티션 테이블에 대한 글로벌 파티션 인덱스 : 이경우 애초에 테이블이 소량이라 인덱스를 파티셔닝 할 이유가 없다.

-   파티션 테이블에 대한 글로벌 파티션 인덱스 : 주로 글로벌 파티션 인덱스보다는 로컬 파티션 인덱스와 비파티면 인덱스가 주로 사용된다.

### 테이블과 같은 컬럼으로 파티셔닝하는 경우

글로벌 파티션 인덱스에는 Prefixed 파티셔만 허용되므로 날짜 컬럼을 선두에 둬야 하는데 날짜 조건은 대개 범위검색 조건이 사용되므로 인덱스 스캔 효율면에서 불리하다.

특히 NL조인에서 Inner 테이블 액세스를 위해 자주 사용되는 인덱스라면 비효율이 더 크게 중요한다.

다른 = 조건을 컬럼은 인덱스 선두에 둘 수 있다는 측면에서 로컬 Nonprefixed 파티션 인덱스가 훨씬 유리하다.

`두 달 이상의 넓은 범위 조건을 가지고 inner 테이블 액세스를 위해 사용될 떄는 로컬 Nonprefixed 파티션 인덱스에도 비효율이 생긴다.`

조인 액세스가 일어나는 레코드마다 여러 인덱스 파티션을 탐색해야 하기 때문

따라서 NL조인에서 넓은 범위 조건을 가지고 Inner텡비ㅡㄹ 액세스를 위해 자주 사용된다면 비 파티션 인덱스가 가장 좋은 선택이다.

### 테이블과 다른 컬럼으로 파티셔닝 하는 경우

테이블 파티션 기준인 날짜 이외의 컬럼으로 인덱스를 글로벌 파티셔닝할 수 있는데

그런 구성은 대게 인덱스를 적정 크기로 유지하려는 데에 목적이 있다.

인덱스가 너무 커지면 관리하기 힘들고 인덱스 높이가 증가해 액세스 효율도 나빠지기 때문이다.

하지만 크런 장점도 로컬 파티션 인덱스 때문에 무색해진다. 글로벌 파티션이 비파티션보다 관리상 이점이 있다고는 하나 로컬 파티션만 못하고 인덱스 높이 조절 측면에서도 그렇다.

## 로컬 Nonprefixed 파티션 인덱스의 효용성

로컬 Nonprefixed 파티션 인덱스는 이력성 데이터를 효과적으로 관리할 수 있게 해 주고, 인덱스 스캔 효율성을 높이는 데에도 유리하다.

따라서 그 특성을 잘 파악하고 있어야 인덱스 및 파티션 설게 시 효과적인 전략을 구사할 수 있다.

이력성 테이블은 거의 대부분 날짜 컬럼을 파티션 키로 사용하므로 여기서도 날짜 컬럼을 기준으로 월단위 Range 파티셔닝 했다고 가정

그리고 아래와 같은 조건절을 가진 쿼리가 자주 수행될때

```sql
select sum(거래량), sum(거래금액)
from 일별계좌별거래
where 게좌번호 = :acnt_no
and 거래일자 between :d1 and :d2
```

### 로컬 Prefixed 파티션 인덱스와 비교

위와 같은 조건절에 최적화된 인덱스를 만드려면 등치 조건 컬럼을 선두에 두고 between 같은 범위검색 조건 컬럼은 뒤쪽에 위치시켜야 한다.

만약 파티션 키 컬럼에 대한 조건식이 등치조건이었다면 두 인덱스가 같은 일량을 보였곘지만 between 조건이었기 때문에 이와 같은 결과가 나타난 것

### 글로벌 Prefixed 파티션 인덱스와 비교

글로벌 파티션 인덱스는 Prefixed 파티션만 허용되므로 거래일자처럼 범위검색 조건으로 자주 사용되는 컬럼이 선두일 때 로컬 Prefixed 파티션과 마찬가지로 인덱스 스캔 효율이 나쁘다.

### 비파티션 인덱스와 비교

비파티션 인덱스를 이용하더라도 관리적 부담은 글로벌 파티션과 동일하게 발생한다.

따라서 관리적 비용 측면에서는 로컬 Nonprefixed 파티션 인덱스가 훨씬 낫다.

조회 측면에서 로컬 Nonprefixed 파티션 인덱스는, 두 달 이상에 걸친 넓은 범위의 거래일자 조건으로 조회할 때 여러 인덱스를 수직 탐색해야 하는 비효율이 있다.

반면 계좌번호를 선두에 둔 비파티션 인덱스는 여러 달에 걸친 거래일자로 조회하더라도 인덱스 스캔상 비효율은 없다.

하지만 아주 넓은 범위의 거래일자로 조회하거나 계좌번호만으로 조회할 때는 Random 액세스 부하 때문에 비 파티션 인덱스도 제 성능을 내기 어렵다.

이럴 때 병렬쿼리가 필요할 수 있는데, 아쉽게도 비파티션 인덱스에는 병렬쿼리가 허용되지 않는다.

로컬 Nonprefixed 파티션 인덱스라면 여러 병렬 프로세스가 각각 하나의 인덱스 스그먼트를 스캔함으로써 위 쿼리의 응답속도를 크게 향상시킬 수 있다.

### 일 단위 파티셔닝

만약 테이블이 일파티션 되있다면 계좌번호만으로 로컬 Nonprefixed 파티션 인덱스를 생성함으로써 인덱스 저장 공간을 줄이는 효과까지 얻을 수 있다.

## 액세스 효율을 고려한 인덱스 파티셔닝 선택 기준

### DW성 애플리케이션 환경

DW/DSS 애플리케이션에는 날짜 컬럼 기준으로 파티셔닝된 이력성 대용량 테이블이 많다.

따라서 관리적 측면뿐만 아니라 병렬 쿼리 활용 측면에서도 로컬 파티션 인덱스가 좋은 선택이다.

로컬 인덱스 중에서는 Nonprefixed 파티션 인덱스가 성능 면에서 유리할 때가 많다.

### OLTP성 애플리케이션 환경

OLTP성 애플리케이션 환경에서는 비파티션 인덱스가 대게 좋은 선택이다.

Right Growing 인덱스에 대한 동시 Insert 경합을 분산할 목적으로 해시 파티셔닝하는 경우가 아니라면 글로벌 파티션 인덱스는 효용성이 낮다.

OLTP이더라도 테이블이 파티셔닝돼 있다면 인덱스 파티셔닝을 고려할 수 있는데 특히 로컬 파티션 인덱스는 테이블 파티션에 대한 DDL 작업 후 인덱스를 재생성하지 않아도 되므로 사용성 측면에서 유리하다.

OLTP 환경에서는 로컬 인덱스 중 Prefixed파티션이 Nonprefixed 파티션보다 유리하다고 오라클 메뉴얼을 포함한 여러 문서에 설명돼 있는데 이말에 동의하기 어렵다.

OLTP 환경에서 로컬 인덱스를 선택했다면 Prefixed 파티션이든 Nonprefixed 파티션이든 검색 조건에 항상 사용되는 컬럼을 파티션 키로 선정하려고 노력해야 한다.

파티션 키가 범위 검색 조건으로 자주 사용된다면 Nonprefixed 인덱스가 유리하고, 될 수 있으면 좁은 범위검색 조건이어야 한다.

특히 NL 조인에서 파티션 키에 대한 넓은 범위검색 조건을 가지고 inner 테이블 액세스 용도로 사용된다면 비파티션 인덱스를 사용해야 한다.

## 인덱스 파티셔닝 제약을 고려한 데이터베이스 설계

인덱스 파티셔닝에 대한 몇 가지 제약이 있는데, 그 중 아래 두가지는 반드시 기억해야 한다.

-   ` Unique 파티션 인덱스를 정의할 때는 인덱스 파티션 키가 모두 인덱스 구성 컬럼에 포함돼어야 한다.`

    -   이 제약이 없다면 인덱스 키 값을 변경하거나 새로운 값을 입력할 때마다 중복값 체크를 위해 매번 많은 인덱스 파티션을 탐색해야 하므로 DML 성능이 저하된다.

-   `  클로벌 파티션 인덱슨느 Prefixed 파티션이어야 한다.`

관리상 목적으로 대용량 테이블을 파티셔닝할 때도 있지만 않은 경우가 성능 향상을 목적으로 한다.

즉 인덱스를 통해 액세스할 데이터량이 아주 많아 빠른 성능을 내기 어렵고, Full Table Scan으로 처리하기에는 너무 많은 양을 읽어야할 때 주로 파티셔닝을 실시하게 된다.

따라서 파티셔닝은 인덱스 전략 수립과 병행해야 한다.

자주 사용되는 액세스 패턴과 데이터 분포를 고려해 인덱스 전략을 수립하고, 인덱스만으로 빠른 성능을 내기 어려운 액세스 경로를 파악해 테이블 파티셔닝과 인덱스 파티셔닝 전략을 수립해야 한다.

# 기타 쿼리 변환

지금까지 설명한 것 외에도 이름이 밝혀지지 않은 많은 쿼리 변환이 작동하고 있다.

## 조인 컬럼에 IS NOT NULL 조건 추가

```sql
select count(e.empno), count(d.dname)
from emp e, dept d
where d.deptno = e.deptno
and sal <= 2900
```

위와 같은 조인문을 처리할때 조인 컬럼 deptno 가 null인 데이터는 조인 액세스가 불필요하다.

```sql
select count(e.empno), count(d.dname)
from emp e, dept d
where d.deptno = e.deptno
and sal <= 2900
and e.deptno is not null
and d.deptno is not null
```

이처럼 조인 컬럼에 is not null 조건을 추가해주면 NL조인뿐만 아니라 해시 조인, 소트 머지 조인시에도 효과를 발휘한다.

여러가지 사실에 비추어 볼 때, 조인 컬럼에 대한 is not null 조건을 추가한다고 손해볼일은 전혀 없다.

하지만 옵티마이저는 null 값의 비중이 5%를 넘을때만 이런 쿼리 변환을 시행한다.

따라서 필요하다면 옵티마이저 기능에 의존하지 말고 사용자가 직접 위와 같은 조건을 추가해 줌으로써 불필요한 액세스를 줄일 수 있다.

## 필터 조건 추가

바인드 변수로 between 검색하는 쿼리가 있다고 하자 쿼리를 수행할때 사용자가 :mx보다 :mn 변수에 더 큰값을 입력한다면 쿼리 결과는 공집합이다.

```sql
select * from emp
where sal between :mn and : mx
```

사전에 두 값을 비교해 알 수 있음에도 쿼리를 실제 수행하고 나서야 공집합을 출력한다면 매우 비합리적이다.

초대용량 테이블에서 사용자가 값을 거꾸로 입력한다면? (근데 이건 방어코드로 그냥 막는게 낫지 않나?)

9i부터는 이를 방지하기 위해 옵티마이저가 임의로 필터 조건식을 추가한다. (mn < mx 이런식으로)

만약 거꾸로 입력한다면 실행계획상으로 Table Full Scan을 수행하고 나서 필터 처리가 일어나는 것 같지만 실제로는 Table Full Scan자체를 생략한다. (읽은 블록 수 확인)

## 조건절 비교 순서

조건절을 처리할때도 어떤 조건을 먼저 평가하느냐에 따라 일량에 차이가 생긴다.

이에 옵티마이저는 테이블 전체를 스캔하거나 인덱스를 수평으로 스캔할 때의 Filter 조건식을 평가할때 선택도가 낮은 컬럼을 먼저 처리하도록 순서를 조정한다.(인덱스 수직탐색을 위한 조건절에는 영향 없음)

이런 쿼리 변환이 작동하려면 옵티마이저에게 시스템 통계를 제공함으로써 CPU Costing 모델을 활성화 해야 한다.

I/O Costing 모델에서는 Where절에 기술된 순서대로 조건식 비교가 일어난다.

### ordered_predicates 힌트의 또 다른 용도

10g 에서 OR 또는 IN-List 조건에 대한 OR-Expansion이 일어날 때 실행 순서를 제어할 목적으로 ordered_predicates힌트를 사용할 수도 있다.

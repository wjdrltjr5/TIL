# 뷰 Merging

## 뷰 Merging이란?

```sql
select *
  from (select * from emp where job = 'SALESMAN') a
     , (select * from dept where job = 'CHICAGO') b
 where a.deptno = b.deptno
```

위와 같이 습관적으로 인라인 뷰를 많이 사용하는 분들을 종종 볼 수 있는데, 그렇게 작성하는 것이 더 읽기 편하기 때문이다.

서브쿼리로 표현하면 아무래도 조인문보다 더 직관적으로 읽힌다. 하지만 옵티마이저의 입장에서는 아니다. 옵티아미저는 쿼리 블록을 아래처럼 풀어내려는 습성을 갖는다.

```sql
select *
  from emp a, dept b
 where a.deptno = b.deptno
   and a.job = 'SALESMAN'
   and b.loc = 'CHICAGO'
```

쿼리블록을 액세스 쿼리블록과의 머지 과정을 거쳐와 같은 형태로 변환되는데, 이를 뷰 Merging 이라고 한다.

이처럼 뷰Merging을 거친 쿼리라야 옵티마이저가 더 다양한 액세스 경로를 조사 대상으로 삼을 수 있게 된다.

이 기능을 제어하는 힌트로는 merge와 no_merge가 있다.

뷰Merging과 다음 절에서 설명하는 조건절 Pushing이 불가능한 형태의 뷰를 사용했을때 성능이 느려지기도 한다.

뷰사용을 꺼리기 보다는 옵티아미저의 쿼리 변환 원리를 정확히 이해함으로 써 적절한 때에 뷰를 사용할 수 있어야 한다.

## 단순 뷰(Simple View) Merging

조건절과 조인문만을 포함하는 단순 뷰는 no_merge 힌트를 사용하지 않는 한 언제든 Merging이 일어난다.

반면 group by절이나 distinct 연산을 포함하는 복합 뷰는 파라미터 설정 또는 힌트 사용에 의해서만 뷰 Merging이 가능하다.

`집합 연산자(union..), connect by, rownum등을 포함하는 복합 뷰는 아예 뷰 Merging이 불가능하다.`

뷰 Merging이 되지 않도록 no_merge를 사용하고 실행게획을 보면 view of ~ 로 표시된다.

## 복합 뷰(Complex View) Merging

아래 항목을 포함하는 복합 뷰는 \_complex_view_merging 파라미터를 true로 설정할 때만 Merging이 일어난다.

-   group by 절
-   select-list에 distinct 연산자 포함

\_complex_view_merging 파라미터를 true로 설정하더라도 아래 항목들을 포함하는 복합 뷰는 Merging 될 수 없다.

-   집합 연산자(union, union all, intersect, minus)
-   connect by 절
-   ROWNUM pseudo 컬럼
-   select-list에 집계함수 사용 : group by 없이 전체를 집계하는 경우
-   분석함수

복합 뷰 Merging을 통해 얻을 수 있는 이점은 필터로 처리된 데이터만 선택해서 조인하고 조인에 성공한 집합만 group by 한다는 데에 있다.

만약 뷰를 Merging 하지 않는다면 emp 테이블에 있는 모든 데이터를 group by 해서 조인하고 나서야 loc = 'CHICAGO' 조건을 필터링 하게 되므로 emp 테이블을 스캔하는 과정에서 불필요한 레코드 액세스가 많이 발생하게 된다.

## 비용기반 쿼리 변환의 필요성

10g 부터는 비용기반 쿼리 변환 방식으로 전환하게 되었고, 이기능을 제어하기 위한 파라미터가 \_optimizer_cost_based_transforamtion이다

설정 가능한 값으로는 아래 5가지가 있다.

-   on
-   off
-   exhaustive
-   linear
-   iterative

비용기반 서브쿼리 Unnesting도 이 파라미터에 의해 영향을 받는다.

조건절 Pushing도 비용기반 쿼리 변환 방식으로 전환되었지만. 이기능은 별도의 파라미터(\_optimizer_push_pred_cost_based)로 제어된다.

오라클 10.2.0.2에서 \_optimizer_connect_by_cost_based파라미터가 추가된 것을 통해 connect by도 비용기반하에서 쿼리 변환이 일어난다.

비용기반 쿼리 변환이 휴리스틱 쿼리 변환보다 고급기능이긴 하지만 파싱 과정에서 더 많은 일을 수행해야 한다.

약간의 하드 파싱 부하를 감수하더라도 더 나은 실행계획을 얻으려는 것이므로 이들 파라미터를 off 시키는것은 바람직하지 않다.

## Merging 되지 않은 뷰의 처리방식

뷰 merging을 시행했을때 비용이 더 증가한다고 판단하거나 부정확한 결과집합이 만들어질 가능성이 있을때 옵티마이저는 뷰 Merging을 포기한다.

어떤 이유에서건 뷰 Merging이 이루이짖 않았을 때는 2차적으로 조건절 Pushing을 시도한다.

하지만 이마저도 실패한다면 뷰 쿼리 블록을 개별적으로 최적화하고 거기서 생성된 서브 플랜을 전체 실행계획을 생성하는 데 사용한다.

실행계획에 VIEW라고 표시된 오퍼레이션 단계가 추가되었다고 해서 다은 단계로 넘어가기 전에 중간 집합을 생성하는 것은 아니다.

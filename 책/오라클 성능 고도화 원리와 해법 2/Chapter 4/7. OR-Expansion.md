# OR-Expansion

아래 쿼리가 그대로 수행된다면 OR조건이므로 Full Table Scan으로 처리될것이다.

```sql
select * from emp
where job = 'CLERK' or deptno = 20
```

job과 deptno에 각각 생성된 인덱스를 사용하고 싶다면 union all 형태로 바꿔주면 된다.

사용자가 쿼리를 직접 바꿔주지 않더라도 옵티마이저가 그런 작업을 대신 해주는 경우가 있는데 이를 OR-Expansion이라고한다.

실행 계획에 concatenation이 나온다.

분기된 두 쿼리가 각각 다른 인덱스를 사용하긴 하지만 emp 테이블 액세스가 두번 일어난다.

따라서 중복 액세스 되는 영역의 데이터 비중이 작을수록 효과적이고 그 반대의 경우라면 오히려 쿼리 수행 비용이 증가한다. 그렇기 때문에 OR-Expansion 쿼리 변환은 처음부터 비용기반으로 작동한다.

중복 액세스되더라도 결과집합에는 중복이 없게 하려고 union all 아래쪽에 오라클이 내부적으로 LNNVL 함수를 사용한다.

job <> CLERK이거나 job is null인집합만을 읽으려는 것이며, 이 함수는 조건식이 false 이거나 null 값일 때 true를 리턴한다.

OR-Expansion을 제어하기 위해 사용하는 힌트로는 use-concat과 no_expand 두 가지가 있다.

## OR-Expansion 브랜치별 조인 순서 최적화

OR-Expansion에 의해 분기된 브랜치마다 각기 다른 조인 순서를 가질수 있음은 매우 중요한 사실이다.

## 같은 컬럼에 대한 OR-Expansion

9i까지는 OR조건이나 In-List도 OR-Expansion이 작동할 수 있었지만. 10g부터는 기본적으로 IN-List Iterator방식으로만 처리된다.

힌트를사용해 OR-Expansion으로 유도할 수 있지만 더 나은점이 없으니 굳이 그렇게 할 필요없다.

## nvl/decode 조건식에 대한 OR-Expansion

사용자가 선택적으로 입력하는 조건절에 대해 nvl또는 decode함수를 이용할 수 있다.

아래 쿼리는 deptno 검색조건을 사용자가 선택적으로 입력할 수 있는 경우에 대비하기 위한 것이다.

```sql
select * from emp
where deptno = nvl(:deptno, deptno)
and ename like :ename || '%'
```

오라클 9i부터 위 쿼리는 아래와 같은 형태로 OR_Expansion쿼리 변환이 일어난다.

```sql
select * from emp
where :deptno is null
and deptno is not null
and ename like :ename || '%'
union all
select * from emp
where :deptno is nut null
and deptno = :deptno
and ename like :ename || '%'
```

:deptno 변수 값의 null 여부에 따라 위 또는 아래쪽 브랜치만 수행하는 것
decode함수를 사용하더라도 같은 처리가 일어난다.

:deptno 변수 값 입력 여부에 따라 다른 인덱스를 사용한다는 사실

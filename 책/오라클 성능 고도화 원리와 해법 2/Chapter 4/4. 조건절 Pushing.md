# 조건절 Pushing (뷰 머지 이루어지지 않을때)

뷰를 액세스하는 쿼리를 최적화할 때 옵티마이져는 1차적으로 뷰 Merging을 고려한다. 하지만 아래와 같은 이유로 뷰 Merging에 실패할 수 있다.

-   복합 뷰(Complex View) Merging 기능이 비활성화
-   사용자가 no_merge 힌트 사용
-   Non-mergeable Views : 뷰 Merging 시행하면 부정확한 가능성
-   비용 기반 쿼리 변환이 작동해 No Merging 선택

어떤 이유에서건 뷰 Merging에 실패했을 때, 옵티마이저는 포기하지 않고 2차적으로 조건절 Pushing을 시도한다. 이는 뷰를 참조하는 쿼리 블록의 조건절을 뷰 쿼리 블록안으로 Pushing하는 기능을 일컫는다.

조건절이 가능한 빨리 처리되도록 뷰 안으로 밀어 넣는다면 뷰 안에서의 처리 일량을 최소화 하게 됨은 불론 리턴되는 결과 건수를 줄임으로써 다음 단계에서 처리해야할 일량을 줄일 수 있다.

### 조건절 Pushing 종류

오라클은 조건절 Pushing과 관련해 다음과 같은 기술을 사용한다.

-   조건절 Pushdown : 쿼리 블록 밖에 있는 조건들을 쿼리 블록 안쪽으로 밀어 넣는 것을 말함.

-   조건절 Pullup: 쿼리 블록 안에 있는 조건들을 쿼리 블록 밖으로 내오는 것을 말하며, 그것을 다시 다른 쿼리 블록에 Pushdown하는 데 사용함

-   조인 조건 Pushdown : NL조인 수행 중에 드라이빙 테이블에서 읽은 값을 건건이 inner쪽 뷰 쿼리 블록 안으로 밀어 넣는것을 말함.

### 관련 힌트와 파라미터

`조건절 Pushdown과 Pullup은 항상 더 나은 성능을 보장하므로 별도의 힌트를제공하지 않는다.`

하지만 조인 조건 Pushdown은 NL조인을 전제로 하기 때문에 성능이 더 나빠질 수 있다.

따라서 오라클은 조인 조건 Pushdown을 제어할 수 있도록 push_pred와 no_push_pred 힌트를 제공한다.

조인 조건 Pushdown이 비용기반 쿼리 변환으로 바뀌면서 종종 시스템을 업그레이드 후 더 느려지는 현상이 발생하는데

아래와 같이 힌트를 이용해 파라미터를 false로 변경하면 된다.

```sql
select /*+ opt_param('_optimizer_push_pred_cost_based', 'false')*/ * from...
```

### Non-pushable View

뷰안에 rownum을 사용하면 Non-mergeable View가 되는데 Non-pushable View가 된다는 사실도 기억

실시간으로 rownum이 부여되는데 기존에 없던 조건절이 생겨 같은 로우가 다른 값을 부여받을 수 있기 때문 즉 옵티마이징 기법에 따라 쿼리 결과가 달라질 수 있기 떄문

분석함수를 사용해도 마찬가지

## 조건절 Pushdown

### Group by 절을 포함한 뷰에 대한 조건절 Pushdown

group by 절을 포함한 복합 뷰 Merging에 실패했을 때, 쿼리 블록 밖에 있는 조건절을 쿼리 블록 안쪽에 밀어 넣을 수 있다면 group by 해야할 데이터량을 줄일 수 있다.

인덱스 상황에 따라서는 도 효과적인 인덱스 선택이 가능해지기도 한다.

실행계획을 보면 뷰 merging에 실패하여 View가 표시되지만 옵티마이저가 조건절을 뷰 안쪽으로 밀어 넣음으로 써 인해 인덱스가 사용가능해 지기도 한다. (range scan가능 아니면 full scan후 group by 후 조건 필터링)

조인문역시 가능

### UNION 집합 연산자를 포함한 뷰에 대한 조건절 Pushdown

union을 포함한 집합 연산자는 뷰 merging에 실패함으로 조건절 Pushdown을 통해서만 최적화가 가능하다

## 조건절 Pullup

조건절을 쿼리 블록 안으로 밀어 넣을 뿐만 아니라 안쪽에 있는 조건들을 바깥쪽으로 끄집어 내기도 한다. 이를 조건절 Pullup이라고 한다.

그리고 그것을 다리 다른 쿼리 블록에 Pushdown하는데 사용한다.

```sql
select
       *
  from (select deptno, avg(sal) from emp where deptno = 10 group by )e1
  , (select deptno, min(sql) max(sal) from emp group by deptno) e2
 where e1.deptno = e2.deptno;
```

인라인 뷰 e2에는 deptno = 10 조건이 없지만 Predicate 정보를 보면 이 조건이 인덱스의 액세스 조건으로 사용된 것을 볼 수 있다.

아래와 같은 형태로 변환이 일어난것

```sql
select
       *
  from (select deptno, avg(sal) from emp where deptno = 10 group by )e1
  , (select deptno, min(sql) max(sal) from emp where deptno = 10 group by deptno) e2
 where e1.deptno = e2.deptno;
```

Predicate Move Around 기능이 작동하지 않는다면 범위스캔이 아니라 index full scan이 일어난다.

## 조인 조건 Pushdown

조인 조건 Pushdown은 말 그대로 조인 조건절을 뷰 쿼리 블록 안으로 밀어 넣는 것으로서, NL조인 수행 중에 드라이빙 테이블에서 읽은 조인 컬럼 값을 Inner 쪽 뷰 쿼리 블록 내에서 참조할 수 있도록 하는 기능이다.

지금까지 보았던 조인문에서의 조건절 Pushdown은 상수 조건이 조인 조건을 타고 전이된것을 Pushdown하는 기능이었던 반면

지금 설명하는 조인 조건 Pushdown은 조인을 수행하는 중에 드라이빙 집합에서 얻은 값을 뷰 쿼리 블록안에 실시간으로 Pushing 하는 기능이다.

조인 조건 Pushdown을 제어하는 힌트로는 아래 두 가지가 있다.

-   push_pred : 조인 조건 Pushdown을 유도한다.
-   no_push_pred : 조인 조건 Pushdown을 방지한다.

이를 제어하는 파라미터로는 아래 세 가지가 있다.

-   \_push_join_predicate : 뷰 merging에 실패한 뷰 안쪽으로 조인 조건을 Pushdown하는 기능을 활성화 한다.

    -   union 또는 union all을 포함하는 Non-mergeable 뷰에 대해서는 아래 두 파라미터가 따로 제공된다.

-   \_push_join_union_view : union all을 포함하는 Non-mergeable View 안쪽으로 조인 조건을 Pushdown 하는 기능을 활성화한다.

-   push_join_union_view2: union을 포함하는 Non-mergeable View 안쪽으로 조인 조건을 pushdown하는 기능을 활성화한다.

### GROUP BY 절을 포함한 뷰에 대한 조인 조건 Pushdown

group by를 포함하는 뷰에 대한 조인 조건 pushdown 기능은 11g에 와서야 제동되기 시작했다

실행계획상에 VIEW PUSHED PREDICATE 오퍼레이션이 나타나고 인덱스 범위 스캔이 가능해진다.

### UNION 집합 연산을 포함한 뷰에 대한 조인 조건 Pushdown

union 또는 union all을 포함한 뷰 쿼리 블록에 대한 조인 조건 Pushdown은 10g이전부터 제동되는 기능

실행계획상에서 UNION ALL PUSHED PREDICATE이 나타난다.

### Outer 조인 뷰에 대한 조인 조건 Pushdown

Outer 조인에서 inner 쪽 집합이 뷰 쿼리 블록일 때, 뷰 안에서 참조하는 테이블 개수에 따라 옵티마이져는 다음 2가지 방법중 하나를 선택한다.

-   뷰 안에서 참조하는 테이블이 단 하나일때 뷰 Merging을 시도한다.

    -   no_merge힌트 사용시 조인 조건 pushdown작동

-   뷰 내에서 참조하는 테이블이 두 개 이상일 때 조인 조건식을 뷰 안쪽으로 Pushing하려고 시도한다.

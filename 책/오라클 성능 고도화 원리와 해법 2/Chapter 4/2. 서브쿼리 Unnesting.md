# 서브쿼리 Unnesting

## 서브쿼리의 분류

서브쿼리는 하나의 SQL문장 내에서 괄호로 묶인 별도의 쿼리 블록을 말한다.

즉 쿼리에 내장된 또 다른 쿼리다.

-   인라인 뷰 : from 절에 나타나는 서브쿼리를 말한다.

-   중첩된 서브쿼리 : 결과집합을 한정하기 위해 where절에 사용된 서브쿼리를 말한다. 특시 서브쿼리가 메인 쿼리에 있는 컬럼을 참조하는 형태를 상관관계가 있는 서브쿼리라고 부른다.

-   스칼라 서브쿼리 : 한 레코드당 정확히 하나의 컬럼 값만을 리턴하는 것이 특징이다. 주로 select-list에서 사용되지만 몇 가지 예외사항을 뺸다면 컬럼이 올 수 있는 대부분 위치에서 사용 가능하다.

이들 서브쿼리를 참조하는 메인 쿼리도 하나의 쿼리 블록이며, 옵티마이저는 쿼리블록 단위로 최적화를 수행한다.

쿼리 블록 단위로 최적의 액세스 경로와 조인 순서, 조인 방식을 선택하는 것을 목표로 한다.

하지만 각 서브쿼리를 최적화 했다고 해서 쿼리 전체가 최적화 됐다고 말할 수는 없다.

옵티마이저가 숲을 바라보는 시각으로 쿼리를 이해하려면 먼저 서브쿼리를 풀어내야만 한다.

서브쿼리를 풀어내는 두 가지 쿼리 변환 중 서브뤄키 Unnesting은 중첩된 서브쿼리와 관련있고, 다음 절에서 설명하는 뷰 Merging은 인라인 뷰와 관련 있다.

## 서브쿼리 Unnesting의 의미

서브쿼리 Unnesting은 중첩된 서브쿼리를 풀어내는 것을 말하며, 풀어내지 않고 그래도 두는 것은 서브쿼리 No-Unnesting이라고 말할 수 있다.

중첩된 서브쿼리는 메인쿼리와 부모와 자식이라는 종속적이고 계층적인 관계가 존재한다.

논리적인 관점에서 그 처리과정은 IN, Exists를 불문하고 필터 방식이어야 한다.

즉 메인 쿼리에서 읽히는 레코드마다 서브 쿼리를 반복 수행하면서 조건에 맞지 않는 데이터를 골라내는 것

서브쿼리를 처리한데 있어 필터 방식이 항상 최적의 수행속도를 보장하지 못하므로 옵티마이저는 아래 둘 중 하나를 선택한다.

-   동일한 결과를 보장하는 조인문으로 변환하고 나서 최적화한다. 이를 일컬어 서브쿼리 Unnesting이라고 한다.

-   서브쿼리를 Unnesting하지 않고 원래대로 둔 상태에서 최적화한다. 메인쿼리와 서브쿼리를 별도의 서브플랜으로 구분해 각각 최적화를 수행하며, 이때 서브쿼리에 필터 오퍼레이션이 나타난다.

1번 서브쿼리 Unnesting은 메인과 서브쿼리 간의 계층구조를 풀어 서로 같은 레벨로 만들어 준다는 의미에서 서브쿼리 Flattening이라고 부른다.

이렇게 쿼리 변환이 이루어지고 나면 일반 조인문처럼 다양한 최적화 기법을 사용할 수 있게 된다.

2번처럼 Unnesting하지 않고 쿼리 블록별로 최적화할 때는 각각의 최적의 쿼리문이 전체의 최적을 달성하지 못할 때가 많다.

그리고 Plan Generator가 고려대상으로 삼을만한 다양한 실행계획을 생성해 내는 작업이 매우 제한적인 범위 내에서만 이루어진다.

## 서브쿼리 Unnesting의 이점

서브쿼리를 메인쿼리와 같은 레벨로 풀어낸다면 다양한 액세스 경로와 조인 메소드를 평가할 수 있다. 특히 옵티마이저는 많은 조인 테크닉을 가지기 때문에 조인 형태로 변환했을 때 더 나은 실행계획을 찾을 가능성이 높아진다.

10g부터는 서브쿼리 Unnesting이 비용기반 쿼리 변환 방식으로 전환되었다. 따라서 변환된 쿼리의 예상 비용이 더 낮을 때만 Unnesting된 버전을 사용하고 그렇지 않을때는 원본 쿼리 그대로 필터 방식으로 최적화한다.

서브쿼리 Unnesting과 관련한 힌트로는 아래 두가지가 있다.

-   unnest : 서브쿼리를 Unnesting 함으로써 조인방식으로 최적화하도록 유도한다.

-   no_unnest : 서브쿼리를 그대로 둔 상태에서 필터 방식으로 최적화하도록 유도한다.

## 서브쿼리 Unnesting 기본 예시

```sql
-- 실행계획에는 Filter로 표시됨
select * from emp
where deptno in (select deptno from dept)

-- Unnesting 변환시 실행계획에는 NL조인으로 표시
select *
  from (select deptno from dept) a, b
 where b.deptno = a.deptno;

-- 뷰 Mergeing 과정을 거쳐 최종적으로 아래와 같은 형태
select emp.* from dept, emp
where emp.deptno = dept.deptno;
```

## Unnesting된 쿼리의 조인 순서 조정

Unnesting에 의해 일반 조인문으로 변환된 후에는 emp, dept 어느쪽이든 드라이빙 집합으로 선택될 수 있다는 점.

선택은 옵티마이저의 몫이며, 판단 근거는 데이터 분포를 포함한 통계정보에 있다.

Unnesting된 쿼리의 조인 순서를 조정하는 방법중 메인 쿼리 집합을 드라이빙 하는 것은 쉽다. leading힌트를 사용하면된다.

서브쿼리를 드라이빙집합으로 사용하려면 ordered힌트를 사용하면 된다. 서브쿼리르 직접 참조하지 않아도 되므로 원하는 대로 조인 순서를 유도할 수 있다.(Unnesting 된 서브쿼리가 from절 앞쪽에 위치)

10g 부터는 쿼리 블록마다 이름을 지정할 수 있는 qb_name 힌트가 제공되므로 더 쉽고 정확하게 제어할 수 있다.

```sql
select /*+ leading(dept@qb1*/ * from emp
where deptno in (select /*+ unnest qb_name(qb1) */ deptno from dept)
```

## 서브쿼리가 M쪽 집합이거나 Nonunique 인덱스일 때

지금까지는 메인쿼리와 서브쿼리의 관계가 M:1 관계이기 때문에 일반 조인문으로 바꾸더라도 쿼리 결과가 보장된다.

옵티마이저는 dept 테이블 deptno 컬럼에 PK 제약이 설정된 것을 통해 dept 테이블이 1쪽 집합이라는 사실을 알 수 있다. 따라서 안심하고 쿼리 변환을 실시한다.

만약 서브쿼리 쪽 테이블이 조인 컬럼에 PK/Unique 제약 또는 Unique 인덱스가 없다면 일반 조인문 처럼 처리할때 결과 오류가 생길 수 있다. 그렇기 때문에 옵티마이저는 결과를 확신할 수 없을때 일반 조인문으로 쿼리 변환을 시도하지 않는다.

옵티마이저는 두 가지 방식 중 하나를 선택하는데 Unnesting 후 어느 쪽 집합이 먼저 드라이빙 되느냐에 따라 달라진다.

-   1쪽집합임을 확신할 수 ㅇ벗는 서브쿼리쪽 테이블이 드라이빙 된다면 먼저, `sort unique` 오퍼레이션을 수행함으로써 1쪽 집합으로 만든 다음에 조인한다.

-   메인 쿼리 쪽 테이블이 드라이빙된다면 세미 조인 방식으로 조인한다. 이것이 세미 조인이 탄색하게 된 배경

### Sort Unique 오퍼레이션 수행

옵티마이저는 아래와 같은 형태로 쿼리 변환이 일어난것

```sql
select b.*
  from (select /*+ no_merge*/ distinct deptno from dept) a , emp b
 where b.deptno = a.deptno
```

### 세미 조인 방식으로 수행

NL 세미조인으로 수행할 때는 sort unique 오퍼레이션을 수행하지 않고도 결과집합이 M쪽 집합으로 확장되는 것을 방지하는 알고리즘을 사용한다.

기본적으로 NL 조인과 동일한 프로세스로 진행하지만 Outer 테이블의 한 로우가 Inner 테이블의 한 로우와 조인에 성공하는 순간 진행을 멈추고 Outer 테이블의 다음 로우를 처리하는 방식

```
-- 의사코드
for(i = 0; ; i++) // Outer
  for(j = 0; ; j++) // Inner
    if(i==j) break;
```

세미 조인 방식으로 변환할 떄의 장점은, NL 세미 조인 뿐만 아니라 해시 세미 조인, 소트머지 세미 조인도 가능하는데 있다.

사용자가 직접 유도할 때는 Unnest 힌트와 함께 각가 hash_sj, merge_sj 힌트를 사용하면 된다.

## 필터 오퍼레이션과 세미조인의 캐싱 효과

옵티마이저가 쿼리 변환을 수행하는 이유는, 전체적인 시각에서 더 나은 실행계획을 수립할 가능성을 높이는 데에 있다.

서브쿼리를 Unnesting 하지 않으면 쿼리를 최적화하는 데 있어 선택의 폭이 넓지 않아 불리하다.

메인 쿼리를 수행하면서 건건히 서브쿼리를 반복 수행하는 단순한 필터 오퍼레이션을 사용할 수 밖에 없기 떄문

대량의 집합을 기준으로 이처럼 Random액세스 방식으로 서브쿼리 집합을 필터링한다면 결코 빠른 수행 속도를 얻을 수 없다.

다행히 오라클은 필터 최적화 기법을 한 가지 갖고 있는데 서브쿼리 수행 결과를 버리지 않고 내부 캐시에 저장하고 있다가 같은 값이 입력되면 저장된 값을 출력하는 방식 (스칼라 서브쿼리의 캐싱효과와 같음)

하지만 10g부터는 NL세미조인도 캐싱효과를 갖는다. 더더욱 필터 오퍼레이션이 설 자리가 없다.

## Anti 조인

not exists, not in 서브쿼리도 Unnesting 하지 않으면 필터방식으로 치뢷ㄴ다.

기본 처리 루틴은 exists 필터와 동일하며 조인에 성공하는 레코드가 하나도 없을 때만 결과 집합에 포함시킨다는 점이 다르다.

-   exists 필터 : 조인에 성공하는 서브 레코드를 만나는 순간 결과집합에 담고 다른 레코드로 이동한다.

-   not exists 필터 : 조인에 성공하는 서브 레코드를 만나는 순간 버리도 다음 레코드로 이동한다. 조인에 성공하는 레코드가 하나도 없을 때만 결과 집합에 담는다.

해당 쿼리를 Unnesting 하면 아래와 같이 Anti 조인 방식으로 처리된다.

NL Anti 조인뫄 머지 Anti 조인은 기본 처리 루틴이 not exists 필터와 같지만 해시 Anti 조인은 조금 다르다.

해시 Anti 조인으로 수행할 때는 먼저 dept(Build Table)를 해시 테이블로 빌드한다.

emp를 스캔하면서 해시 테이블을 탐색하고 조인에 성공한 엔트리에만 표시를 한다.

마지막으로 해시 테이블을 스캔하면서 표시가 없는 엔트리만 결과집합에 담는 방식

## 집계 서브쿼리 제거

집계 함수를 포함하는 서브쿼리를 Unnesting 하고 이를 다시 분석함수로 대체하는 쿼리 변환이 10g에서 도입되었다.

```sql
select d.deptno, d.danme, e.empno, e.ename, e.sal
  from emp e, dept d
 where d.deptno = e.deptno
   and e.sal >= (select avg(sal) from emp where deptno = d.deptno)
```

위 쿼리를 Unnesting하면 1차적으로 아래와 같은 쿼리가 만들어진다.

```sql
select d.deptno, d.dname, e.empno, e.ename, e.sql
  from (select deptno, avg(sal) avg_sal from emp group by deptno) x, emp e, dept d
 where d.deptno = e.deptno
   and e.deptno = x.deptno
   and e.sql >= x.avg_sql
```

옵티마이저는 한 번 더 쿼리 변환을 시도해 인라인 뷰를 merging 하거나 그대로 둔 채 최적화할 수 있다.

10g부터 옵티마이저가 선택할 수 있는 옵션이 한가지 더 추가되었는데 서브쿼리로부터 전환된 인라인 뷰를 제거하고 메인쿼리에 분석함수를 사용하는 형태로 변환하는 것이다.

이 기능은 \_remove_aggr_subquery 파라미터에 의해 제어되며 비용기반으로 작동한다.

## Pushing 서브쿼리

Unnesting되지 않은 서브쿼리는 항상 필터 방식으로 처리되며, 대게 실행계획상에서 맨 마지막 단계에 처리된다. 만약 서브쿼리 필터링을 먼저 처리했을 때 다음 수행단계로 넘어가는 로우 수를 크게 줄일 수 있다면 성능은 그만큼 향상된다.

`Pushing 서브쿼리는 실행계획 상 앞 단계에서 서브쿼리 필터링이 처리되도록 강제하는 것을 말하며 이를 제어하기 위해 사용하는 옵티마이저 힌트가 push_subq이다.` (인라인 뷰안에 조건절을 밀어넣는것과 다름)

`Pushing 서브쿼리는 Unnesting 되지 않은 서브쿼리에서만 작동한다.`

그렇기 때문에 push_subq는 no_unnest 힌트와 같이 기술하는 것이 올바른 사용법이다.

해당 힌트를 사용해서 사전 필터링을 통해 조인 횟수를 줄일 수 있다. 왜? 읽는 레코드 수를 줄일 수 있으니까

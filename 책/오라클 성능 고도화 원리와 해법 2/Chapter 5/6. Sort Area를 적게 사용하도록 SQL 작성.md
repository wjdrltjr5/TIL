# Sort Area를 적게 사용하도록 SQL 작성

소트 연산이 불가피하다면 메모리 내에서 처리를 완료할 수 있도록 노력해야 한다.

Sort Area크기를 늘리는 방법도 있지만 그전에 적게 사용할 방법부터 찾는것이 순서다.

## 소트를 완료하고 나서 데이터 가공하기

```sql
-- 1번
select lpad(상품번호, 30) || lpad(상품명, 30) || lpad(고객ID, 10)
|| lpad(고객명, 20) || to_char(주문일시, 'yyyymmdd hh24:mi:ss')
from 주문상품
where 주문일시 between :start and :end
order by  상품번호

-- 2번
select lpad(상품번호, 30) || lpad(상품명, 30) || lpad(고객ID, 10)
|| lpad(고객명, 20) || to_char(주문일시, 'yyyymmdd hh24:mi:ss')
from (
  select 상품번호, 상품명, 고객ID, 고객명, 주문일시
  from 주문상품
  where 주문일시 between :start and :end
  order by 상품번호
)
```

2번이 훨씬 Sort Area를 적게 사용한다.

## Top-N쿼리

Top-N쿼리 형태로 작성하면 소트 연산횟수를 최소화함을 물론 Sort Area사용량을 줄일 수 있다.

오라클에서는 인라인 뷰로 한번 감싸야하는 불편함이 있다.

```sql
select * from (
    select 거래일시, 체결건수, 체결수량, 거래대금
    from 시간대별종목거래
    where 종목코드 = 'KR123456'
    and 거래일시 >= '20080304'
    order by 거래일시
)
where rownum <= 10
```

위 쿼리를 수행하는 시점에 종목코드 + 거래일시 순으로 구성된 인덱스가 존재한다면 옵티마이저는 그 인덱스를 이용함으로써 order by 연산을 대체할 수 있다.

rownum 조건을 사용해 N건에서 멈추도록 했으므로 조건절에 부합하는 레코드가 아무리 많아도 매우 빠른 수행 속도를 낼 수 있다.(실행계획 count stopkey)

#### Top-N쿼리의 소트 부하 경감 원리

종목코드 + 거래일시 순으로 구성된 인덱스가 없을 때는 종목코드만을 선두로 갖는 다른 인덱스를 사용하거나 Full Scan을 할텐데 이때는 정렬 작업이 불가피하다.

하지만 Top-N쿼리 알고리즘이 효과를 발휘해 sort order by 부하를 경감시켜준다.

처음 10개를 담은후 맨 우측에 있는 값과 비교해서 그보다 작은 값이 나타날때만 배열 내에서 다시 정렬을 시도한다. (물론 우측값은 버린다.) sort area 영역 적게 사용

## 분석함수에서의 Top-N쿼리

window sort시에도 rank()나 row_number()를 쓰면 Top-N쿼리 알고리즘이 작동해 max()함수를 쓸 때보다 소트 부하를 경감시켜 준다.

```sql
select id, seq, owner, object_name, object_type, created, status
from (select id, seq
           , rank() over(partition by id order by seq desc) rnum
           , owner, object_name, object_type, created, status
        from t)
where rnum = 1

```

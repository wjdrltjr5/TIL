# 소트 수행 원리

SQL 튜닝에서 빠질 수 없는 요소가 소트 튜닝이다. 소트 오퍼레이션은 수행과정에서 CPU와 메모리를 많이 사용하고, 데이터량이 많을 때는 디스크 I/O까지 일으킨다.

많은 서버 리소스를 사용하는 것도 문제지만 부분범위처리를 불가능하게 해 OLTP 환경에서 애플리케이션 성능을 저하시키는 주요인으로 작용하기도 한다.

## 소트 수행 과정

SQL 수행 도중 데이터 정렬이 필요할 때면 오라클은 PGA 메모리에 Sort Area를 할당하는데, 그 안에서 처리를 완료할 수 있는지 여부에 따라 소트를 두 가지 유형으로 나눈다.

-   메모리 소트 : 전체 데이터의 정렬 작업을 메모리 내에서 완료하는 것을 말하며 Internal Sort 라고도 한다.

-   디스크 소트 : 할당받은 Sort Area 내에서 정렬을 완료하지 못해 디스크 공간까지 사용하는 경우를 말하며 External Sort라고도 한다.

정렬된 결과를 Temp 영역에 임시 저장했다가 다시 읽어들이는 디스크 소트가 발생하는 순간 SQL 수행 성능은 크게 나빠진다.

-   Optimal 소트 : 소트 오퍼레이션이 메모리 내에서만 이루어짐
-   Onepass 소트 : 정렬 대상 집합이 디스크에 한 번만 쓰임
-   Multipass 소트 : 정렬 대상 집합이 디스크에 여러 번 쓰임

## 소트 오퍼레이션 측정

디스크 I/O시 버퍼캐시를 경유하므로 일반적으로 디스크 블록 I/O가 메모리 블록 I/O 개수를 초과할 수없다.

하지만 디스크 소트 과정에서 발생한 디스크 I/O까지 physical reads에 포함된다면 실행계획상에서 더 커진다.

## Sort Area

데이터 정렬을 위해 사용되는 Sort Area는 소트 오퍼레이션이 진행되는 동안 공간이 부족해질때마다 청크단위로 조금씩 할당된다.

#### PGA

각 오라클 서버 프로세스는 자신만의 PGA 메모리 영역을 할당받고 이를 프로세스에 종속적인 고유 데이터를 저장하는 용도로 사용된다.

다른 프로세스와 공유되지 않는 독립적인 메모리 공간으로서, 래치 메커니즘이 필요 없어 똑같은 개수의 블록을 읽더라도 SGA 버퍼 캐시에서 읽는 것 보다 훨신 빠르다.

#### UGA

전용 서버 방식으로 연결할 때는 프로세스와 세션이 1:1 관계를 갖지만, 공유 서버방식으로 연결할 때는 1:M 관계를 갖는다.

세션이 프로세스 개수보다 많아질 수 있는 구조로서 하나의 프로세스가 여러 개 세션을 위해 일한다.

따라서 각 세션을 위한 독립적인 메모리 공간이 필요해지는데 이를 UGA라고 한다.

(그렇다고 전용 서버 방식에서 UGA를 사용하지 않는 것은 아니다. 전용 서버 방식으로 연결할때는 PGA에 공유 서버 방식으로 연결할때는 SGA에 할당된다.)

#### 정리

-   하나의 프로세스는 하나의 PGA를 갖는다.
-   하나의 세션은 하나의 UGA를 갖는다.
-   PGA에는 세션과 독립적인 프로세스만의 정보를 관리한다.
-   UGA에는 프로세스와 독립적인 세션만의 정보를 관리한다.
-   거의 대부분 전용 서버 방식을 사용하므로 세션과 프로세스는 1:1 관계고 따라서 UGA도 PGA내에 할당된다고 이해

#### CGA

PGA에 할당되는 메모리 공간에는 CGA(Call Global Area)도 있다. 오라클은 하나의 데이터베이스 Call을 넘어서 다음 Call까지 계속 참조되어야 하는 정보는 UGA에 담고

Call이 진행되는 동안에만 필요한 데이터는 CGA에 담는다.

CGA는 ParseCall, Execute Call, Fetch Call 마다 매번 할당받는다.

Call이 진행되는 동안 Recursive Call이 발생하면 그안에서도 Parse, Execute, Fetch단계별 CGA가 추가로 할당된다. 할당된 공간은 Call이 끝나자마자 해제돼 PGA로 반환된다.

-   CGA : Call이 진행되는 동안만 필요한 정보 저장
-   UGA : Call을 넘어서 다음 Call 까지 계속 참조되는 정보

### Sort Area 할당위치

Sort Area가 할당되는 위치는 SQL문 종류와 소트 수행 단계에 따라 다르다.

DML 문장은 하나의 Execute Call 내에서 모든 데이터 처리를 완료하며, Execute Call이 끝나는 순간 자동으로 커서가 닫힌다.

따라서 DML 수행 도중 정렬한 데이터를 Call 넘어서까지 참조할 필요가 없으므로 Sort Area를 CGA에 할당한다.

select문의 경우 정렬된 데이터는 Fetch Call 까지 사용되어야 한다. 따라서 UGA에 할당된다.

반먼 마지막보다 앞선 단계에서 정렬된 데이터는 첫 번째 Fetch Call 내에서만 사용되므로 Sort Area를 CGA에 할당한다.

select 마지막 단계더라도 sort_area_retained_size제약이 있으면 소트작업은 CGA에서 수행하고 이 제약만큼의 공간을 UGA에 할당해 소트된 결과를 그곳에 옮겨 담는다.

그럼으로써 이후 발생하는 FetchCall을 통해 조금씩 결과집합을 전송할 수 있도록 한다.

마지막보다 앞선 단게에서 정렬을 수행할 때도 sort_area_retained_size 제약이 있다면 다음 단계로 넘어가기 전에 이 값을 초과한 분량을 Temp 세그먼트에 저장하고 초과만큼의 CGA 메모리는 반환한다.

#### 요약

1. DML 문장 수행 시 발생하는 소트는 CGA에서 수행
2. SELECT 문장 수행시
    - 쿼리 중간 단계의 소트
        - CGA에서 수행 sort_area_retained_size제약이 있다면 다음 단계로 넘어가기 전에 이 값을 초과하는 CGA영역 반환
    - 결과집합을 출력하기 직전 단계에서 수행하는 소트
        - sort_area_retained_size제약이 있다면 CGA에서 소트 수행, 이 제약만큼의 UGA를 할당해 정렬된 결과를 담았다가 이후 Fetch Call에서 array단위로 전송
        - sort_area_retained_size 제약이 없다면 곧바로 UGA에서 소트 수행

CGA에 할당된 Sort Area는 하나의 Call이 끝나자마자 PGA에 반환된다. UGA에 할당된 Sort Area는 마지막 로우가 Fetch될 때 비로소 UGA Heap에 반환되고, 거의 대부분 그 부모 Heap에도 즉각 반환된다.

## 소트 튜닝 요약

소트 오퍼레이션은 메모리 집약적일뿐만 아니라 CPU집약적 작업이기도 하며 데이터량이 많을 때는 디스크I/O까지 발생시키므로 쿼리 성능을 좌우하는 가장 중요한 요소다.

부분범위처리를 할 수 없게 만들어 OLTP 환경에서 성능을 떨어트리는 주 요인으로 작용한다.

소트 튜닝 방안

-   데이터 모델 측면에서 검토
-   소트가 발생하지 않도록 SQL작성
-   인덱스를 이용한 소트 연산 대체
-   Sort Area를 적게 사용하도록 SQL 작성
-   Sort Area크기 조정

# 인덱스를 이용한 소트 연산 대체

인데스는 항상 키 컬럼 순으로 정렬된 상태를 유지하므로 이를 이용해 소트 오퍼레이션을 생략할 수 있다.

예로 서브쿼리에 사용된 테이블이 unique인덱스를 갖는다면 Unnesting되었을때 sort unique 생략

## Sort Order By 대체

아래 쿼리를 수행할 떄 region + custid 순으로 구성된 인덱스를 사용한다면 sort order by 연산을 대체할 수 있다.

```sql
select custid, name, resno, status, tell
from customer
where region = 'A'
order by custid
```

소트해야할 대상 레코드가 무수히 많고 그 중 일부만 읽고 멈출 수 있는 업무에서 이 방식이 유리

인덱스를 스캔하면서 결과집합을 끝까지 Fetch한다면 오히려 I/O 및 리소스 사용 측면에서 손해다. 대상 레코드가 소량일 때는 소트가 발생하더라도 부하가 크지 않아 개선 효과도 미미하다.

## Sort Group By대체

region이 선두 컬럼인 결합 인덱스나 단일 컬럼 인덱스를 사용한다면 아래 쿼리에 필요한 sort group by 연산을 대체할 수 있다.

```sql
select region, avg(age), count(*)
from customer
group by region
```

실행계획에 sort group by nosort라고 표시된다.

이처럼 인덱스를 이용한 nosort 방식으로 수행될 때는 group by 오퍼레이션에도 불구하고 부분범위처리가 간으해져 OLTP 환경에서 매우 극적인 성능 개선 효과를 얻을 수 있다.

## 인덱스가 소트 연산을 대체하지 못하는 경우

아래는 sql 컬럼을 선두고 갖는 인덱스가 있는데도 정렬을 수행하지 못하는 경우

```sql
select * from emp order by sql;
```

옵티마이저가 이런 결정을 하는 가장 흔한 원인은 인덱스를 이용하지 않는 편이 더 낫다고 판단하는 경우

옵티마이저 모드를 바꿧는데오 계속해서 소트 오퍼레이션을 고집한다면 sal 컬럼에 not null 제약조건이 정의돼있지 않은 것

단일 컬럼 인덱스의 경우 null이면 인덱스 레코드에 포함되지 않기때문에 사용하지 못함 (group by nosort역시 마찬가지)

오라클의 경우 결합인덱스에 null은 맨 뒤쪽에 저장 null값부터 출력하라고 할때는 인덱스를 사용하더라도 소트가 불가피

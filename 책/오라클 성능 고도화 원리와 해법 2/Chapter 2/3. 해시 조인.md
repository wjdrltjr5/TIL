# 해시 조인

해시 조인은 둘 중 작은 집합을 읽어 Hash Area에 해시 테이블을 생성하고, 반대쪽 큰 집합을 읽어 해시 테이블을 탐색하면서 조인하는 방식이다.

해시 조인은, NL조인처럼 조인 과정에서 발생하는 Random 액세스 부하가 없고(양쪽 집합을 읽는 과정에서 인덱스 사용하면 발생한다.)

소트 머지 조인처럼 조인 전에 양쪽 집합을 정렬하는 부담도 없다. 다만 해시 테이블을 생성하는 비용이 수반된다. 따라서 Build Input이 적을 때라야 효과적이다.

구체적으로 말해 PGA 메모리에 할당되는 Hash Area에 담길 정도로 충분히 작아야 한다.

Build Input이 Hash Area 크기를 초과한다면 디스크에 썻다가 다시 읽어 들이는 과정을 거치기 때문에 성능이 많이 저하된다.

Build Input 으로 선택된 테이블이 작은 것도 중요하지만 해시 키 값으로 사용되는 컬럼에 중복값이 거의 없을 때라야 효과적이다.

NL조인과 비교하면 Inner 루프가 Hash Area에 미리 생성해 둔 해시 테이블을 이용한다는 점만 다르다.

해시 테이블을 만든느 단게는 전체 범위 처리가 불가피 하지만 반대쪽 Probe Input을 스캔하는 단계는 NL 조인처럼 부분범위 처리가 가능하다.

해시 조인은 래치 획득 과정없이 PGA에서 빠르게 데이터를 탐색한다.

## Build Input이 Hash Area를 초과할 때 처리 방식

In-Memory 해시 조인이 불가능할때 오라블의 해시조인 처리 방식

### Grace 해시 조인

In-Memory 해시조인이 불가능할 때 오라클은 Grace 해시 조인이라고 알려진 조인 알고리즘을 사용하는데 두 단계로 나누어 진행한다.

#### 파티션 단계

조인되는 양쪽 집합(조인 컬럼 이외의 조건절을 만족하는 레코드) 모두 조인 컬럼에 해시 함수를 적용하고, 반환된 해시 값에 따라 동적으로 파티셔닝을 실시한다.

독립적으로 처리할 수 있는 여러 개의 작은 서브 집합으로 분리함으로써 파티션 짝을 생성하는 단계

파티션 단게에서 양쪽 집합을 모두 읽어 디스크 상의 Temp 공간에 일단 저장해야 하므로 In-Memory 해시 조인도바 성능이 크게 떨어지게 된다.

#### 조인 단계

파티션 단계가 완료되면 각 파티션 짝에 대해 하나씩 조인을 수행한다. 이때 각각의 Build Input과 Probe Input은 독립적으로 결정된다.

즉 파티션하기 전 어느 쪽이 작은 테이블이었는지에 상관없이 각 파티션 짝의 작은 쪽을 Build Input으로 선택해 해시 테이블을 생성한다.

해시 테이블이 생성되고 나면 반대 쪽 파티션 로우를 하나씩 읽으면서 해시 테이블을 탐색하며 모든 파티션 짝에대한 처리가 완료될 떄까지 이런 과정을 반복한다.

Grace 해시 조인은 한마디로 분할 정복 방식이라고 말할 수 있다.

### Hybrid 해시 조인

Grace 해시 조인 방식을 그대로 따른다면 디스크 I/O 부하가 상당히 심할 것

조인에 성공할 가능성 없는 대상 집합까지 일단 디스크에 모두 쓰고, 나중에 디스크로부터 다시 읽어 조인해야 하기 떄문

이런 단점을 보완하기 위해 여러가지로 변형된 최적화 알고리즘을 사용하는 오라클이 사용하는 Hybrid 해시 조인은 아래와 같은 방식이다.

1. 두 테이블 중 작은 쪽을 Build Input으로 선택하고 Hash Area에 해시 테이블을 생성하기 시작한다. 이때 두 개의 해시 함수를 적용하는데 첫 번째 해시 값으로는 레코드를 저장할 파티션(버킷)을 결정하고, 두 번째 해시 값은 나중에 실제 조인할때를 위해 레코드와 함께 저장해 둔다.

2. 해시 테이블을 생성하는 도중에 Hash Area가 꽉차면 그 중 가장 큰 파티션(버킷)을 디스크에 기록한다.

3. 해시 테이블을 완성하기 위해 Build Input을 계속 읽는 동안 이미 디스크에 기록된 파티션에 해당되는 레코드는 디스크 파티션에 기록한다.

4. 다시 Hash Area가 다차면 이번에도 가장 큰 파티션을 디스크에 저장한다.

5. 이렇게 첫 번째 테이블에 대한 파티셔닝 단계가 끝나면 파티션 크기가 가장 작은 순으로 메모리에 적재한다.

6. 이제 두 번째 테이블을 읽기 시작하는데 이때도 두개의 해시 함수를 사용한다. 첫번째 해시 값에 해당하는 파티션이 현재 메모리에 있다면 그 파티션을 스캔하고 거기서 조인 레코드를 찾으면 바로 결과집합에 포함한다. 이때 첫 번째 해시 값으로 곧바로 파티션을 스캔하는 것이 아니라 비트-백터 필터링을 거쳐 선택된 레코드만 파티션을 스캔하고 선택되지 않은 레코드는 그냥 버린다.

7. 비트-백터 필터링을 통과했지만 메모리에서 매칭되는 파티션을 찾지 못했다면 Build Input을 파티셔닝할 때와 같은 방식으로 해시 파티셔닝한다. 즉 첫 번째 해시 값으로 레코드가 저장될 파티션을 결정하고 두 번째 해시 값과 함께 디스크로 저장된다. (비트-백터 필터링을 거친 레코드만)

8. 7번과정까지 마치고 나면 양쪽 테이블 모두 같은 해시 함수로써 파티셔닝 했기 때문에 같은 해시 값을 갖는 레코드끼리는 같은 파티션 짝에 놓이게 되었다. 이제 각 파티션 짝에대한 조인을 수행하는데 작은쪽 파티션을 Build Input으로 선택해 해시 테이블을 생성한다. (이때 저장해둔 두번째 해시 값이 사용)

9. 모든 파티션에 대해 8번 과정을 반복함으로 써 해시조인을 마친다.

#### Recursive 해시 조인(Nested-loops 해시 조인)

디스크에 기록된 파티션 짝끼리 조인을 수행하려고 작은 파티션을 메모리에 로드하는 과정에서 또다시 가용 Hash Area를 초과하는 경우가 발생할 수 있다.

그럴 때는 추가적인 파티셔닝 단계를 거치게 되는데 이를 Recursive 해시 조인이라고 한다.

Recursive 해시 조인을 Multipass 해시 조인이라고도 하며 디스크 쓰기가 발생했지만 Multipass 오퍼레이션을 거치지 않는 경우를 OnePass 해시 조인

디스크를 전혀 사용하지 않은 In-Memory 해시 조인을 Optimal 해시 조인이라고 한다.

#### 비트-백터 필터링

Hybrid 조인 5~6단계를 거치는 동안 가능한 메모리 상에서 조인을 완료하므로 두 번째 테이블이 디스크에 기록되는 양을 상당히 줄일 수 있다.

오라클은 비트-백터 필터링 기법까지 사용하는데, 조인 성공 가능성이 없는 파티션 레코드는 아예 디스크에 기록되지 않게 하려는 것이다.

ex. part join filter가 보였을때

## Build Input 해시 키 값에 중복이 많을 때 발생하는 비효율

해시 알고리즘의 성능은 해시 충돌을 얼마나 최소화할 수 있느냐에 달렸다.

가능하면 오라클은 충분히 많은 개수의 버킷을 할당함으로써 버킷 하나당 하나의 키 값만 갖게 하려고 노력한다.

해시 버킷을 아무리 많이 할당하더라도 해시 테이블에 저장할 키 컬럼에 중복값이 많다면 하나의 버킷에 많은 엔트리가 달릴 수 밖에 없다. (조인 조건으로 사용되는 값이 중복이 많다면)

ex. 상품번호와 체결일자만 조인 조건으로 사용하고 고유 값인 주문접수번호를 사용하지 않을때

## 해시 조인 사용기준

해시 조인 성능을 좌우하는 두 가지 키 포인트는 다음과 같다.

-   한쪽 테이블이 Hash Area에 담길 정도로 충분히 작아야함
-   Build Input 해시 키 컬럼에 중복이 거의 없어야 함

해시 조인은 언제 효과적일까

-   조인 컬럼에 적당한 인덱스가 없어 NL 조인이 비효율적일때
-   조인 컬럼에 인덱스가 있더라도 NL 조인 드라이빙 집합에서 Inner 쪽 집합으로의 조인 액세스량이 많이 Random 액세스 부하가 심할 때
-   소트 머지 조인하기에는 두 테이블이 너무 커 소트 부하가 심할때
-   수행빈도가 낮고 쿼리 수행시간이 오래 걸리는 대용량 테이블을 조인할 때

수행시간이 짧으면서 수행빈도가 매우 높은 쿼리를 해시 조인으로 처리한다면

NL조인에 사용되는 인덱스는 영구적으로 유지되면서 다양한 쿼리를 위해 공유 및 재사용되는 구조다.

반면 해시 테이블은 단 하나의 쿼리를 위해 생성하고 조인이 끝나면 곧바로 소멸하는 자료구조다.

따라서 수행빈도가 높은 쿼리에 해시 조인을 사용하면 CPU와 메모리 사용률을 크게 증가시킨다.

`해시조인은 수행 빈도가 낮고, 쿼리 수행 시간이 오래 걸리는 대용량 테이블을 조인할때 주로 사용해야 한다.` (배치, DW, OLAP)

OLTP환경에서 1초 걸리는 쿼리를 0.1초로 단축시킬 목적으로 해시 조인을 쓰는 것은 자제해야한다.

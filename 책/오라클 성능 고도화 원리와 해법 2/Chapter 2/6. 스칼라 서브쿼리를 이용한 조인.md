# 스칼라 서브쿼리를 이용한 조인

## 스칼라 서브쿼리

```sql
select empno, ename, sal, hiredate
    , (select d.dname
         from dept d
        where d.deptno = e.deptno) dname
  from emp e
 where sal >= 2000
```

위 스칼라 서브쿼리는 아래 Outer 조인문과 100% 같은 결과를 낸다. 조인이 실패하는 emp 레코드가 있다면 dname으로 null 값이 출력된다.

```sql
select /*+ ordered use_nl(d) */
       e.empno, e.name, e.sal, e.hiredate, d.dname
  from emp e, dept d
 where d.deptno(+) = e.deptno
   and e.sal >= 2000
```

위 두 쿼리는 결과만 같은 것이 아니라 조인을 수행하는 처리 경로도 동일하다.

NL방식으로 수행되도록 힌트를 사용했기 때문 다만 스칼라 서브쿼리는 내부적으로 캐싱기법이 적용한다는 점이 다르고, 이를 이용한 튜닝이 자주 행해진다.

## 스칼라 서브쿼리의 캐싱 효과

`오라클은 스칼라 서브쿼리 수행횟수를 최소화하려고 그 입력 값과 출력 값을 내부 캐시에 저장해 둔다.`

`스칼라 서브쿼리가 수행될 때면 일단 '입력 값'을 캐시에서 찾아보고 거기 있으면 저장된 '출력 값을'리턴한다.`

캐시에서 찾지 못할 때만 쿼리를 수행하며, 결과는 버리지 않고 캐시에 저장해둔다.

반복 수행되는 함수 때문에 쿼리 성능이 크게 저하될 때, 아래와 같이 함수에 스칼라 서브쿼리를 덧씌움으로써 호출 횟수를 줄이는 튜닝사례가 있다.

```sql
select empno, ename, sal, hiredate
      , (select get_dname(deptno) from dual) dname
  from emp e
 where sal >= 2000
```

입력 값과 출력 값을 빠르게 저장하고 찾기 위해 오라클은 해싱 알고리즘을 사용한다.

해시 충돌이 발생했을 때 기존 엔트리를 밀어내고 새로 수행한 입력 값과 출력 값으로 대체할 것 같지만, 오라클은 기존 캐시 엔트리를 그대로 둔 채 스칼라 서브쿼리만 한 번 더 수행하고 만다.

따라서 해시 충돌이 발생한 입력 값이 반복적으로 입력되면 스칼라 서브쿼리도 반복 수행된다.

`결론적으로 스칼라 서브쿼리의 캐싱 효과는 입력 값의 종류가 소수여서 해시 충돌 가능성이 적은 때라야 효과가 있으며, 반대의 경우라면 캐시를 확인하는 비용 때문에 오히려 성능은 저하되고 CPU사용률만 높게 만든다.`

`스칼라 서브쿼리를 사용하면 NL조인에서 Inner 쪽 인덱스와 테이블에 나타나는 버퍼 Pinning 효과도 사라진다는 사실을 기억해야 한다.`

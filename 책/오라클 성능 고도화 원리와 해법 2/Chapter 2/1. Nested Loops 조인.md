# Nested Loops 조인

## 기본 메커니즘

NL 조인은 중첩루프문 구조로 조인을 진행한다.

```sql
begin
  for outer in (select deptno, empno, rapd(ename, 10) ename from emp)
  loop -- outer 루프
    for inner in (select dname from dept where deptno = outer.deptno)
    loop -- inner 루프
      dbms_outer.put_line(outer.empno || ' : ' || outer.ename || ' : ' || inner.dname);
    end loop;
  end loop;
end;

select /*+ ordered use_nl(d) */ e.empno, e.ename, d.dname
  from emp e, dept d
 where d.deptno = e.deptno
```

PL/SQL과 쿼리문은 내부적으로 쿼리를 반복수행하지 않는다는 점만 다르다.

뒤에서 나오는 소트머지조인과 해시조인도 가공해둔 데이터를 이용한다는 점만 다를뿐 기본적인 조인 프로세싱은 다르지 않다.

## 힌트를 이용해 NL 조인을 제어하는 방법

ordered 힌트는 from절에 기술된 순서대로 조인하라고 옵티마이저에게 지시하고 use_nl 힌트는 NL방식으로 조인하라고 지시할 때 사용한다.

## NL 조인 수행 과정 분석

```sql
select /*+ ordered use_nl(e) */
       e.empno, e.ename, d.dname, e.job, e.sal
  from dept d, emp e
 where e.deptno = d.deptno  -- 3
  and d.loc = 'SEOUL'       -- 1
  and d.gb = '2'            -- 2
  and e.sal >= 1500         -- 4
order by sql desc
```

주석의 숫자는 조건 비교 순서

실행계획읜 해석은 형제노드간에는 위에서 아래로 부모-자식 노드간에는 안쪽에서 바깥쪽으로 즉 자식노드 부터 읽는다.

1. dept_loc_idx 인덱스 범위 스캔
2. 인덱스 rowid로 dept 테이블 액세스
3. emp_deptno_idx 인덱스 범위 스캔
4. 인덱스 rowid로 emp 테이블 액세스
5. sql 기준 내림차순 정렬

-   dept.loc = 'SEOUL' 조건을 만족하는 레코드를 찾으려고 인덱스를 범위스캔한다.

-   dept_loc_idx 인덱스에서 읽은 rowid를 가지고 dept 테이블을 액세스해 dept.gb = '2' 필터조건을 만족하는 레코드를 찾는다.

-   dept 테이블에서 읽은 deptno 값을 가지고 조인 조건을 만족하는 emp쪽 레코드를 찾으려고 emp_deptno_idx 인덱스를 범위스캔한다.

-   emp_deptno_idx 인덱스에서 읽은 rowid를 가지고 emp 테이블을 액세스해 sal >= 1500 필터 조건을 만족하는 레코드를 찾는다.

-   위 과정을 통과한 레코드들은 sal 컬럼 기준 내림차순으로 정렬한 후 결과를 리턴한다.

`여기서 기억할 것은 각 단계를 완료하고 나서 다음 단계로 넘어가는 게 아니라 한 레코드씩 순차적으로 진행한다는 사실 단 order by는 전체 집합을 대상으로 정렬해야 하므로 작업을 모두 완료한 후에 다음 오퍼레이션을 진행한다.`

첫 번째 부하지점. dept_loc_idx인덱스를 스캔하는 양에 따라 전체 일랴이 좌우됨을 이해해야 한다.
단일 컬럼 인덱스를 = 조건으로 스캔했으므로 비효율없이 스캔하고 그만큼의 테이블 Random 액세스가 발생했다.

dept 테이블로 많은양의 Random 액세스가 있었는데 gb=2조건에 의해 필터링 되는 비율이 높다면 인덱스 컬럼에 추가하는 방안으로 고려해야 한다.

두 번째 부하지점. emp_deptno_idx 인덱스를 탐색하는 부분이며. Outer 테이블인 dept를 읽고 나서 조인 액세스가 얼만큼 발생하느냐에 의해 결정된다.

이것 역시 Random 액세스에 해당하며(범위 스캔이 아니라 건당 스캔이니까) gb=2 조건을 만족하는 건수만큼 3번의 조인시도가 있었다.

emp_deptno_idx의 높이가 3이면 매 건마다 그만큼의 블록 I/O가 발생하고 리프 블록을 스캔하면서 추가적인 블록 I/O가 더해진다.

세 번째 부하지점. emp_deptno_idx를 읽고 나서 emp 테이블을 액세스하는 부분

여기서도 sal >= 1500 조건에 의해 필터링되는 비율이 높다면 emp_deptno_idx 인덱스에 sal 컬럼을 추가하는 방안을 고려해야 한다.

OLTP 시스템에서 조인을 튜닝할 때는 일차적으로 NL 조인부터 고려하는 것이 올바른 순서다.

NL 조인 메커니즘을 따라 각 단게의 수행 일량을 분석해 과도한 Random 액세스가 발생하는 지점을 파악한다.

조인 순서를 변경해 Random 액세스 발생량을 줄일 수 있는 경우가 있고, 그렇지 못할 때는 인덱스 컬럼 구성을 변경하거나 다른 인덱스의 사용을 고려해야 한다.

NL조인이 효과적이지 못하다고 판단될 때 해시조인이나 소트 머지 조인을 검토한다.

## NL 조인의 특징

오라클은 블록단위로 I/O를 수행하며, 하나의 레코드를 읽으려고 블록을 통째로 읽는 Random 액세스 방식은 메모리 버퍼에서 빠르게 읽더라도 비효율이 존재한다.

`NL 조인의 첫 번째 특징이 Random 액세스 위주의 조인 방식이라는 점. 인덱스 구성이 아무리 완벽하더라도 대량의 데이터를 조인할 떄 매우 비효율적이다.`

`두 번째 특징은, 조인을 한 레코드씩 순차적으로 진행한다는 점이다. 첫 번째 특징 때문에 대용량 데이터 처리 시 매우 치명적인 한계를 드러내지만, 반대로 이 두 번째 특징 때문에 아무리 대용량 집합이더라도 매우 극적인 응답속도를 낼 수 있다. (부분범위처리가 가능한 상황에서)`

순차적으로 진행하는 특징 때문에 먼저 액세스되는 테이블의 처리 범위에 의해 전체 일량이 결정된다.

결론적으로 NL 조인은 소량의 데이터를 주로 저리하거나 부분범위처리가 가능한 온라인 트랜잭션 환경에 적합한 조인방식이라고 할 수 있다.

## 테이블 Prefetch

인덱스 rowid에 의한 Inner 테이블 액세스가 Nested Loops 위쪽에 표시되곤 하는데, 이는 해당 테이블 액세스 단게에 Prefetch 기능이 적용되었음을 표현하기 위함이다.

새로운 포맷의 실행계획이 나타난다고 항상 테이블 Prefetch가 작동하는 것은 아니다. 단지 그기능이 활성화 되었음을 의미할 뿐이다.

Prefetch 방식으로 디스크 블록을 읽었는데 실제 버퍼 블록액세스로 연결되지 못한 채 메모리에서 밀려나는 비율이 높다면, 실행계획은 그대로인 채 내부적으로 기능이 비활성화 되기 때문이다.

Prefetch 기능이 실제로 작동할 때면 db file sequential read 대기 이벤트 대신 db file parallel reads 대기 이벤트가 나타난다.

`Prefetch는 디스크 I/O와 관련있다. 디스크 I/O를 수행하려면 비용이 많이 들기 때문에 한 번 I/O Call이 필요한 시점에, 곧이어 읽을 가능성이 큰 블록들을 캐시에 미리 적재해 두는 기능이다.`

한 번의 I/O Call 로써 여러 Single Block I/O를 동시에 수행한다.

NL 조인에서 항상 새 포맷의 실행계획(Inner Table 액세스가 Nested Loops 위쪽에 표시되는)이 나타나는것은 아니다.

기본적으로 Outer쪽 인덱스를 Unique Scan할 때는 작동하지 않는다.

-   Inner쪽 Non-Unique 인덱스를 Range Scan할 때는 테이블 Prefetch 실행게획이 항상 나타난다.

-   Inner쪽 Unique인덱스를 Non-Unique조건(모든 인덱스 구성 컬럼이 = 조건이 아닐 때) Range Scan할때도 테이블 Prefetch 실행계획이 항상 나타난다.

-   Inner 쪽 Unique 인덱스를 Unique 조건(모든 인덱스 구성컬럼이 = 조건)으로 액세스할 때도 테이블 Prefetch 실행계획이 나타날 수 있다.
    -   이때 인덱스는 Range Scan으로 액세스한다. 테이블 Prefetch 실행계획이 안타날때는 Unique Scan으로 액세스한다.
    -   이경우는 흔치 않다.

## 배치 I/O

오라클 11g에서 시작한 배치 I/O 메커니즘에 대해서는 공식적으로 알려진 바가 ㅇ벗지만 아래 실행계획이 의미하는 바와 같이 inner 쪽 인덱스만으로 조인하고나서 테이블과 조인은 나중에 일괄 처리하는 메커니즘으로 추정된다.

테이블 액세스를 나중에 하지만 부분범위 처리는 정삭적으로 작동한다. 따라서 인덱스와의 조인을 모두 완료하고 나서 테이블을 액세스하는 것이 아니라 일정량씩 나누어 처리하는 것을 알 수 있다.

```sql
Execution Plan
------------------------------------------------------------------
0     SELECT STATEMENT Optimizer=ALL_ROWS (Cost=16 Card=14 Bytes=2K)
1  0    NESTED LOOPS
2  1      NESTED LOOPS (Cost=16 Card=14 Bytes=2K)
3  2        TABLE ACCESS (FULL) OF 'EMP' (TABLE) (Cost=2 Card=14 Bytes=1K)
4  2        INDEX (UNIQUE SCAN) OF 'PK_DEPT' (INDEX (UNIQUE)) (Cost=0 Card=1)
5  1      TABLE ACCESS (BY INDEX ROWID) OF 'DEPT' (TABLE) (Cost=1 Card=1 Bytes=30)
```

위 실행계획을 풀어서 설명하면 아래와 같다.

1. 드라이빙 테이블에서 일정량의 레코드를 읽어 Inner쪽 인덱스와 조인하면서 중간 결과집합을 만든다.

2. 중간 결과집합이 일정량 쌓이면 inner 쪽 테이블 레코드를 액세스한다. 이때 테이블 블록을 버퍼 캐시에서 찾으면 바로 최종 결과집합에 담고, 못 찾으면 중간 집합에 남겨둔다.

3. 2번 과정에서 남겨진 중간 집합에 대한 Inner쪽 테이블 블록을 디스크로부터 읽는다.

    - 이때 Multiple Single Block I/O방식을 사용한다.

4. 버퍼 캐시에 올라오면 테이블 레코드를 읽어 최종 결과집합에 담는다.

5. 모든 레코드를 처리하거나 사용자가 Fetch Call을 중단할 때까지 1~4번과정을 반복한다.

이것은 Outer 테이블로부터 액세스되는 inner쪽 테이블 블록에 대한 디스크 I/O Call 횟수를 줄이기 위해, 테이블 Prefetch에 이어 추가로 도입된 메커니즘이다.

이 메커니즘이 작동하도록 유도하려면 nlj_batching 힌트를 사용하면 된다.

만약 이 방식을 원치 않을때는 no_nlj_batching 또는 nlj_prefetch 힌트를 사용하면 된다. 그러면 테이블 Prefetch 방식으로 전환된다.

위 방식을 사용할때 Inner쪽 테이블 블록이 모두 버퍼 캐시에서 찾아지지 않으면(버퍼 캐시 히트율 < 100%)

즉 실제 배치 I/O가 작동한다면 데이터 정렬순서가 달라질 수 있다는 사실

모두 버퍼 캐시에서 찾을 때는 이전 메커니즘과 똑같은 정렬순서를 보인다.

테이블 Prefetch 방식이나 전통적인 방식으로 NL조인할 때는 디스크 I/O가 발생하든 안 하든 데이터 정렬 순서가 항상 일정하다.

## 버퍼 Pinning 효과

하나의 SQL FETCH Call 내에서 `동일한 버퍼 블록에 2회 이상 반복적으로 접근할 때` 해당 블록이 Pinning 상태가 되어 래치(latch) 획득 오버헤드를 줄이고 효율성을 높이는 것

같은 값으로 반복 액세스해야 버퍼 Pinning 효과가 나타난다.

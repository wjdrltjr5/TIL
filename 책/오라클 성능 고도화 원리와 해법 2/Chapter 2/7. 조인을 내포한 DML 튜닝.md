# 조인을 내포한 DML 튜닝

## 수정 가능 조인 뷰 활용

### 전통적인 방식의 UPDATE

튜닝을 하다 보면 아래와 같이 작성된 Update문을 종종 볼 수 있다.

```sql
update 고객 c
   set 최종거래일시 = (select max(거래일시) from 거래
                     where 고객번호 = c.고객번호
                       and 거래일시 >= trunc(add_months(sysdate, -1)))
     , 최종거래횟수 = (select count(*) from 거래
                      where 고객번호 = c.고객번호
                        and 거래일시 >= trunc(add_months(sysdate, -1)))
     , 최근거래금액 = (select sum(거래금액) from 거래
                      where 고객번호 = c.고객번호
                        and 거래일시 >= trunc(add_months(sysdate, -1)))
  where exists (select 'x' from 거래
                 where 고객번호 = c.고객번호
                   and 거래일시 >= trunc(add_months(sysdate, -1)))
```

만약 독자가 개발 중인 프로그램에 위와 같은 update문이 있다면 아래와 같이 고치기 바란다.

```sql
update 고객 c
   set (최종거래일시, 최근거래횟수, 최근거래금액) = (select max(거래일시), count(*), sum(거래금액)
                                                       from 거래
                                                      where 고객번호 = c.고객번호
                                                        and 거래일시 >= trunc(add_months(sysdate, -1)))
 where exists (select 'x'
                 from 거래
                where 고객번호 = c.고객번호
                  and 거래일시 >= trunc(add_months(sysdate, -1)))
```

위 방식에도 비효율이 없는 것은 아니다. 한 달 이내 거래가 있던 고객을 두 번 조회하기 때문인데 총 고객수와 한달 이내 거래가 발생한 고객 수에 따라 성능이 좌우된다.

총 고객 수가 아주 많다면 Exists 서브쿼리를 아래와 같이 해시 세미 조인으로 유도하는 것을 고려할 수 있다.

```sql
update 고객 c
   set (최종거래일시, 최근거래횟수, 최근거래금액) =
       (select max(거래일시), count(*), sum(거래금액)
          from 거래
         where 고객번호 = c.고객번호
           and 거래일시 >= trunc(add_months(sysdate, -1)))
 where exists (select /*+ unnest hash_sj */ 'x'
                 from 거래
                where 고객번호 = c.고객번호
                  and 거래일시 >= trunc(add_months(sysdate, -1)))
```

만약 한 달 이내 거래를 발생시킨 고객이 많아 update 발생량이 많다면 아래와 같이 변경하는 것을 고려할 수 있다.

```sql
update 고객 c
   set (최종거래일시, 최근거래횟수, 최근거래금액) =
       (select nvl(max(거래일시), c.최종거래일시)
             , decode(count(*), 0, c.최근거래횟수, count(*))
             , nvl(sum(거래금액), c.최근거래금액)
          from 거래
         where 고객번호 = c.고객번호
           and 거래일시 >= trunc(add_months(sysdate, -1)))
```

하지만 위처럼 하면 모든 고객 레코드에 lock이 발생함을 물론, 이전과 같은 값으로 갱신되는 비중이 높을수록 Redo 로그 발생량이 증가해 오히려 비효율적일 수 있다.

이처럼 다른 테이블과 조인이 필요할 때 전통적인 방식의 update문을 사용하면 비효율을 감수해야만 한다. 참고 set 절에 사용된 서브쿼리에는 캐싱 메커니즘이 작용하므로 distinct value 개수가 적은 1쪽 집합을 읽어 M쪽 집합을 갱신할 때 효과적이다.

물론 exists 서브쿼리가 NL세미 조인이나 필터 방식으로 처리된다면 거기서도 캐싱 효과가 나타난다.

### 수정 가능 조인 뷰

아래와 같이 수정가능 조인뷰를 활용하면 참조 테이블과 두 번 조인하는 비효율 없앨 수 있다.

```sql
update /*+ bypass_ujvc */
      (select /*+ ordered use_hash(c) */
              c.최종거래일시,  c.최근거래횟수, c.최근거래금액
            , t.거래일시, t.거래횟수, t.거래금액
         from (select 고객, max(거래일시) 거래일시, count(*) 거래횟수, sum(거래금액) 거래금액
                 from 거래
                where 거래일시 >= trunc(add_months(sysdate, -1))
                group by 고객) t
               , 고객 c
        where c.고객번호 = t.고객번호
       )
  set 최종거래일시 = 거래일시
    , 최근거래횟수 = 거래횟수
    , 최근거래금액 = 거래금액
```

`조인뷰는 from 절에 두 개 이상 테이블을 가진 뷰를 가리키며 수정가능 조인 뷰는 말 그대로 입력, 수정, 삭제가 되는 조인뷰를 말한다. 단 1쪽 집합과 조인되는 M쪽 집합에만 입력, 수정, 삭제가 허용된다.`

하지만 1쪽 집합과 M쪽집합을 사용하더라도 unique 인덱스가 없다면 옵티마이저의 입장에서는 어느쪽이 1집합인지 알 수 없어서 에러가 난다.

1쪽 집합에 PK제약을 설정하거나 unique인덱스를 생성해야 수정 가능 조인 뷰를 통한 입력/수정/삭제가 가능해지만다.

#### 키 보존 테이블인란?

키 보존 테이블이란 조인된 결과집합을 통해서도 중복 값 없이 unique 하게 실벽이 가능한 테이블을 말한다. unique한 1쪽 집합과 조인되는 테이블이어야 조인된 결과집합을 통한 식별이 가능하다.

단적으로 말해 `키 보존 테이블이란 뷰에 rowid를 제공하는 테이블을 말한다.`

## MERGE문 활용

DW에서 가장 흔히 발생하는 오퍼레이션은, 기간계 시스템에서 가져온 신규 트랜잭션 데이터를 반영함으로써 두 시스템 간 데이터를 동기화시키는 작업이다.

## 다중 테이블 Insert 활용

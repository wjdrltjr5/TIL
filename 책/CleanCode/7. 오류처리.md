## 7. 오류처리

오류 처리는 프로그램에 반드시 필요한 요소 중 하나일 뿐이다. 입력이 이상하거나 디바이스가 실패할지도 모르기 때문이다. 뭔가가 잘못될 가능성은 늘 존재한다. 그걸 바로 잡을 책임은 프로그래머에게 있다.

깨끗한 코드와 오류 처리는 연관성이 있다. 상당수 코드 기반은 오류 처리 코드에 좌우된다.

### 오류 코드보다 예외를 사용하라.

예외를 사용하는 것이 훨씬 더 깔끔하다.

### Try-Catch-Finally문부터 작성하라.

어떤 면에서 try블록은 트랜잭션과 비슷하다. try블록에서 무슨일이 생기든지 catch블록은 프로그램 상태를 일관성있게 유지해야 한다. 그러므로 예외가 발생할 코드를 짤 때는 try-catch-finally문으로 시작하는 편이 낫다.

try-catch 구조로 범위를 정의했으므로 tdd를 사용해 필요한 나머지 논리를 추가한다.

강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하는 코드를 작성하는 방법을 권장한다. 그러면 자연스럽게 try블록의 트랜잭션 범위부터 구현하게 되므로 범위 내에서 트랜잭션 본질을 유지하기 쉬워진다.

### 언체크예외를 사용하라

체크드예외는 OCP를 위반한다. 메메서드에서 확인된 예외를 던졌는데 catch블록이 세 단계 위에 있다면 그 사이 메서드 모두가 확인된 예외를 던져야 한다. 즉 하위 단게에서 코드를 변경하면 상위 단계 메서드 선언부를 전부 고쳐야 한다는 말이다.

최상위 함수가 아래함수를 호출한다. 아래 함수는 그 아래 함수를 호출한다. 모든 함수가 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화가 깨진다.

때로는 체크드예외도 유용하다 아주 중요한 라이브러리를 작성한다면 모든 예외를 잡아야 한다. 하지만 일반적인 애플리케이션은 의존성이라는 비용이 이익보다 크다.(금융관련은?)

### 예외에 의미를 제공하라.

예외를 던질 때는 전후 상황을 충분히 덧붙인다. 그러면 오류가 발생한 원인과 위치를 찾기가 쉬워진다.

자바는 모든 예외에 호출 스택을 제공한다. 하지만 실패한 코드의 의도를 파악하려면 호출 스택만으로 부족하다.

오류 메세지에 정보를 담아 예외와 함께 던진다. 실패한 연산 이름과 실패 유형도 언급한다.

애플리케이션이 로깅 기능을 사용한다면 catch블록에서 오류를 기록하도록 충분한 정보를 넘겨준다.

### 호출자를 고려해 예외 클래스를 정의하라.

애플레키에션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 한다.

```java
//오류를 형편없이 분류한 사례
//외부 라이브러리를 호출하는 try-catch-finally문을 포함한
//코드로 위부 라입러리가 던질 예외를 모두 잡아 낸다.
ACMEport port = new ACMEPort(12);
try{
  port.open();
}catch(DeviceResponseException e){
  reportPortError(e);
  logger.log("Device response exception", e);
}catch(ATM1212UnlockedException e){
  reportPortError(e);
  logger.log("Unlock exception", e);
}catch(GMXError e){
  reportPortError(e);
  logger.log("Device response exception");
}finally{
  ...
}
```

위 코드는 중복이 심하다 대다수 상황에서 우리가 오류를 처리하는 방식은 비교적 일정하다.

-   오류를 기록한다.
-   프로그램을 계속 수행해도 좋은지 확인한다.

위 경우는 예외에 대응하는 방식이 예외 유형과 무관하게 거의 동일하다. 그래서 코드를 간결하게 고치기가 아주 쉽다. 호출하는 라이브러리 API를 감싸면서 예외 유형 하나를 반환하면 된다.

```java
//LocalPort 클래스는 ACMEPort클래스가 던지는 에외를 잡아
//변환하는 래퍼클래스일 뿐이다.
LocalPort port = new LocalPort(12);
try{
  port.open();
}catch(PortDeviceFailure e){
  reportError(e);
  logger.log(e.getMessage(), e);
}finally{
  ...
}

public class LocalPort{
  private ACMEPort innerPort;

  public LocalPort(int portNumber){
    innerPort = new ACMEPort(portNumber);
  }

  public void open(){
    try{
      innerPort.open();
    }catch(DeviceResponseException e){
      throw new PortDeviceFailure(e);
    }catch(ATM1212UnlockedException e){
      throw new PortDeviceFailure(e);
    }catch(GMXError e){
      throw new PortDeviceFailure(e);
    }
  }
  ...
}
```

LocalPort클래스 처럼 ACMEPort를 감싸는 클래스는매우 유용하다.
실제로 위부 API를 사용할 때는 감싸기 기법이 최선이다. 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다 나중에 다른 라이브 러리로 갈아타도 비용이적다. 또한 감싸기 클래스에서 외부 API를 호출하는 대신 테스트 코드를 넣어주는 방법으로 프로그램을 테스트 하기도 쉬워진다.

마지막 장점으로 특정 업체가 API를 설계한 방식에 발목 잡히지 않는다. 프로그램이 사용하기 편리한 API를 정의하면 그만이다.

예외 클래스가 하나만 있어도 충분한 코드가 많다. 예외 클래스에 포함된 정보로 오류를 구분해도 괜찮은 경우가 그렇다. 한 예외는 잡아내고 다른 예외는 무시해도 괜찮을 경우라면 여러 예외 클래스를 사용한다.

### 정상 흐름을 정의하라.

앞 절에서 충고한 지침을 추일히 따른다면 비즈니스논리와 오류처리가 잘 분리된 코드가 나온다.

코드 배부분이 깨끗하고 간결한 알고리즘으로 보이기 시작한다 하지만 그러다 보면 오류 감지가 프로그램 언저리로 밀려난다.

외부 API를 감싸 독자적인 예외를 던지고, 코드 위에 처리기를 정의해 중단된 계산을 처리한다.

하지만 때로는 중단이 적합하지 않을 때도 있다.

다음은 비용 청구 애플리케이션에서 총계를 계산하는 허술한 코드이다.

```java
try{
  MealExpences expenses = expenseReportDAO.getMeals(employee.getID());
  m_total += expenses.getTotal();
}catch(MealExpensesNotFound e){
  m_total += getmealPerDiem();
}
```

위에서 식비를 비용으로 청구했다면 직원이 청구한 식비를 총계에 더한다. 식비를 비용으로 청구하지 않았다면 일일 기본 식비를 총계에 더한다.

그런데 예외가 논리를 따라가기 어렵게 만든다. 특수 상황을 처리할 필요가 없다면 더 좋지 않을까?

```java
MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());
m_total += expences.getTotal();
```

ExpenseReportDAO를 고쳐 언제나 MealExpense 객체를 반환한다. 청구한 식비가 없다면 일일 기본 식비를 반환하는 MealExpense객체를 반환한다.

```java
public class PerDiemMealExpenses implements MealExpenses{
  public int getTotal(){
    //기본값으로 일일 식비를 반환한다.
  }
}
```

이를 특수 사례 패턴이라 부른다. 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식. 클라이언트 코드가 예외적인 상황을 처리할 필요가 없어진다. 클래스나 객체가 예외적인 상황을 캡슐화해서 처리하므로

### null을 반환하지 마라.

흔히 저지르는 바람에 오류를 유발하는 행위중 하나가 null을 반환하는 습관이다. (컬렉션의 경우 차라리 빈 컬렉션 반환)

### null을 전달하지 마라.

이것도 뭐 반환하는 거나 마찬가지

### 결로

깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다. 이 둘은 상충하는 목표가 아니다 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다.

# 의존성 관리하기

## 의존성 이해하기

### 변경과 의존성

의존성

-   실행시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
-   구현 시점: 의존 대상 객체가 변경될경우 의존하는 객체도 변경된다.

두 요소 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미 따라서 의존성은 변경에 의한 영향의 전파 가능성을 암시한다.

### 의존성 전이

a-> b ->c a 에서 b 직접의존성 a에서 c 간접의존성

### 런타임 의존성과 컴파일타임 의존성

컴파일 타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용 가능해진다.

객체지향 프로그래밍의 실행 구조는 소스코드 구조와 일치하지 않는 경우가 종종 있다. 코드 구조는 컴파일 시점에 확정되는 것이고 이 구조에는 고정된 상속 클래스 관계들이 포함된다. 그러나 프로그래밍 실행 시점 구조는 협력하는 객체에 따라 달라질 수 있다. 두 구조는 전혀 다른 별개의 독립성을 갖는다. 시스템의 실행 시점 구조는 언어가 아닌 설계자가 만든 타입들 간의 관련성으로 만들어진다.

### 컨텍스트 독립성

ex 추상클래스(인터페이스) 에 의존하게

클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다. 클래스가 사용될 특정한 문맥에 대해 최고한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해 진다. (컨텍스트 독립성)

### 의존성 해결하기

컴파일 타임 의존성은 구체적인 런타임 의존성으로 대체돼야 한다.
컴파일 타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 방법을 의존성 해결이라고 부른다.

-   객체를 생성하는 시점에 생성자를 통해 의존성 해결
-   객체 생성 후 setter메서드를 통해 의존성 해결
-   메서드 실행 시 인자를 이용해 의존성 해결

## 유연한 설계

### 의존성과 결합도

바람직한 의존성은 재사용과 관련이 있다. 어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못한 것이다.

컨텍스트 독립적인 의존성이 바람직한 의존성

### 지식이 결합을 낳는다.

결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고있는 정보의 양으로 결정된다. 한 요소가 다른 요소에 비해 더 많은 정보를 알고 있을수록 두 요소는 강하게 결합된다.

서로에 대해 알고있는 지식의 양이 결합도를 결정한다.

### 추상화에 의존하라

목록에서 아래로 갈수록 결합도가 느슨해짐

-   구체 클래스 의존성
-   추상 클래스 의존성
-   인터페이스 의존성

### 명시적인 의존성

의존성이 인자에 적혀있어 퍼블릭 인터페이스에 노출되면 명시적인 의존성

숨겨져있다면 숨겨진 의존성

의존성이 명시적이지 않다면 의존성을 파악하기 위해 내부 구현을 직접 살펴볼 수 밖에 없다.

의존성은 명시적으로 표현돼야 한다.

### new 는 해롭다.

결합도 측면에서 new가 해로운 이유

-   new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 한다. 따라서 구체클래스에 의존하기 때문에 결합도가 높아짐
-   new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다. 지식의 양이 늘어나기 때문에 결합도가 높아진다.

### 가끔은 생성해도 무방하다.

오버로딩을 하는경우.

```java
public class Movie{
  private DiscountPolicy discountPolicy;

  public Movie(String title, Duration runningTime, Money fee){
    this(title, runningTime, fee, new AmountDiscountPolicy(...));
  }

  public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy){
    ...
    this.discountPolicy = discountPolicy;
  }
}
```

구체 클래스를 사용하더라도 클래스의 사용성이 더 중요하다면 결합도를 높이는 방향으로 코드를 작성할 수 있다.

### 표준 클래스의 대한 의존은 해롭지 않다.

뭐 java.lang, util... 어차피 변경될 확률이 적으니까

### 컨텍스트 확장하기

만약에 할인정책이 없을경우 null로 사용시 기존의 내부코드를 수정해야함(null 체크하고 원래값 리턴)

코드 내부를 직접 수정하는 일은 버그의 발생 가능성을 높이는 것

그래서 할인정책이 없는 DiscountPolicy 생성(NoneDiscountPolicy)

기존 코드를 수정하지 않고 확장.

### 조합 가능한 행동

객체지향 시스템은 협력하는 객체들의 네트워크로 구성돼 있다. 시스템은 객체를 생성해 서로 메시지를 주고 받을 수 있게 조립하는 과정을 거쳐 만들어진다. 시스템의 행위는 객체의 조합(객체의 선택과 연결방식)을 통해 나타나는 특성이다.

따라서 시스템에 포함된 객체의 구성을 변경해(절차적인 코드를 작성하기 보다는 인스턴스 추가나 제거 또는 조합을 달리해서) 시스템의 작동 방식을 바꿀 수 있다. 이러한 객체 구성을 관리할 목적으로 작성하는 코드를 객체 네트워크의 행위에 대한 선언적인 정의라고 한다. 시스템을 이런 방식으로 구축하면 방법(how)이 아니라 목적(what)에 집중할 수 있어 시스템의 행위를 변경하기가 더 쉽다.

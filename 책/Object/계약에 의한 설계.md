# 계약에 의한 설계

의도를 드러내도록 인터페이스를 다듬고 CQRS를 헀더라도 명령으로 인해 발생하는 부수효과를 명확하게 표현하는 데는 한계가 있다.

메서드의 구현이 단순하다면 내부를 살펴보는 것만으로도 부수효과를 쉽게 이해할 수 있을것이지만. 구현이 복잡하고 부수효과를 가진 다수의 메서드들을 연이어 호출하는 코드를 분석하는 경우는 결과를 예측하기 어렵다.

캡슐화의 사치는 사라지고 개발자는 복잡하게 얽히고 설킨 로직을 이해하기 위해 고생을 해야 한다.

즉 인터페이스 만으로는 객체의 행동에 관한 다양한 관점을 전달하기 어렵다.

계약에 의한 설계를 사용하면 협력에 필요한 다양한 제약과 부수효과를 명시적으로 정의하고 문서화 할 수 있다.

계약에 의한 설계는 클래스의 부수효과를 명시적으로 문서화하고 명확하게 커뮤니케이션할 수 있을뿐만 아니라 실행 가능한 검증 도구로써 사용할 수 있다.

## 협력과 계약

### 부수효과를 명시적으로

객체지향의 핵심은 협력 안에서 객체들이 수행하는 행동이다.

```c#
class Event{
  public boolean IsSatisfied(RecurringSchedule schedule){...}

  public void Reschedule(RecurringSchedule schedule){
    Contract.Requires(IsSatisfied(schedule));
  }
}
```

이 코드가 if문을 사용한 일반적인 파라미터 체크 방식과 크게 다르지 않다고 생각할 수도 있겠지만 여러가지 차이점이있다.

### 계약

계약의 세부적인 내용은 상황에 따라 다르겠지만 일반적으로 다음과 같은 특성을 가진다.

-   각 계약 당사자는 계약으로부터 이익을 기대하고 이익을 얻기 위해 의무를 이행한다.
-   각 계약 당사자는 이익과 의무는 계약서에 문서화된다.

한쪽의 의무가 반대쪽의 권리가 된다.

### 계약에 의한 설계

-   협력에 참여하는 각 객체는 계약으로부터 이익을 기대하고 이익을 얻기 위해 의무를 이행한다.
-   협력에 참여하는 각 객체의 이익과 의무는 객체의 인터페이스 상에 문서화된다.

계약에 의한 설계 개념은 인터페이스에 대해 프로그래밍하라는 원칙을 확장한 것이다.

서버는 자신이 처리할 수 있는 범위의 값들을 클라이언트가 전달할 것이라고 기대한다. 클라이언트는 자신이 원하는 값을 서버가 반환할 것이라고 기대한다. 클아이언트의 메시지 전송 전과 후의 서버의 상태가 정상일 것이라고 기대한다.

이 세가지가 계약에 의한 설계를 구성하는 세가지 요소에 대응된다.

-   사전조건 : 메서드가 호출되기 위해 만족돼야하는 조건 (클라이언트의 의무) 만족되지 않을경우 메서드 실행되어서는 안되낟.

-   사후조건 : 메서드가 실행된 후에 클라이언트에게 보장해야 하는 조건 클라이언트가 사전조건을 만족시켰다면 메서드는 사후조건에 명시된 조건을 만족시켜야 한다.(조건을 만족 못시킬경우 예외를 던져야 한다. 만족시키는 것은 서버의 의무)

-   불변식 : 항상 참이라고 보장되는 서버의 조건. 메서드 실행 중에는 불변식을 만족시키지 못할 수도 있지만 메서드를 실행하기 전이나 종료된 후에 불변식은 항상 참이여야 한다.

### 사전조건

일반적으로 사전 조건은 메서드의 전달된 인자의정합성을 체크하기 위해 사용된다.

```c#
// 보통 생성자에서 검증하거나 하던데
public Reservation Reserve(Customer customer, int audienceCount){
  Contract.Requires(customer != null);
  Contract.Requires(audienceCount >= 1);
  return new Reservation(customer, this, calculateFee(audienceCount), audienceCount);
}
```

### 사후 조건

메서드의 실행 결과가 올바른지 검사하고 실행 후에 객체가 유효한 상태로 남아 있는지를 검증한다.

일반적으로 사후조건은 다음과 같은 세 가지 용도로 사용된다.

-   인스턴스 변수의 상태가 올바른지를 서술하기 위해
-   메서드에 전달된 파라미터의 값이 올바르게 변경됐는지를 서술하기 위해
-   반환값이 올바른지를 서술하기 위해

다음과 같은 두가지 이유로 사전조건보다 사후조건을 정의하는것이 더 어려울 수 있다.

-   한 메서드 안에서 return문에 여러번 나올경우

    -   모든 return 문마다 결괏값이 올바른지 검증하는 코드를 추가해야함.

-   실행 전과 실행 후의 값을 비교해야 하는 경우
    -   실행 전의 값이 다른 값으로 변경됐을 수 있기 때문에 두 값을 비교하기 어려울 수 있다.

### 불변식

사전 조건과 사후 조건은 각 메서드마다 달라지는데 반해 불변식은 인스턴스생명주기 전반에 걸쳐 지켜져야 하는 규칙을 명세한다.

일반적으로 객체의 내부 상태와 관련이 있다.

-   불변식은 클래스의 모든 인스턴스가 생성된 후에 만족돼야 한다. 이것은 클래스에 정의된 모든 생성자는 불변식을 준수해야 한다는 것을 의미

-   불변식은 클라이언트에 의해 호출 가능한 모든 메서드에 의해 준수돼야 한다. 메서드가 실행되는 중에는 객체의 상태가 불안정한 상태로 빠질 수 있기 떄문에 불변식을 만족시킬 필요는 없지만 실행 전과 후에는 만족하는 상태가 유지돼야 한다.

## 계약에 의한 설계와 서브 타이핑

계약에 의한 설계의 핵심은 클라이언트와 서버 사이의 견고한 협력을 위해 준수해야 하는 규약을 정의하는 것.

서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 계약을 준수해야 한다.

-   협력에 참여하는 객체에 대한 기대를 표현하는 계약 규칙
-   교체 가능한 타입과 관련된 가변성 규칙

계약 규칙은 슈퍼타입과 서브타입 사이의 사전 조건, 사후 조건, 불변식에 대해 서술할 수 있는 제약에 완한 규칙

-   서브타입에 더 강력한 사전조건을 정의할 수 없다. (EX 부모0원 서브+100원)
-   서브타입에 더 완화된 사후 조건을 정의할 수 없다.(EX. 부모0원 서브-100원)
-   슈퍼타입의 불변식은 서브타입에서도 반드시 유지돼야 한다.

가변석 규칙은 파라미터와 리턴 타입의 변형과 관련된 규칙이다.

-   서브타입의 메서드 파라미터는 반공변성을 가져야 한다.
-   서브타입의 리런 타입은 공변성을 가져야 한다.
-   서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안된다.

### 계약 규칙

-   서브타입에 더 강력한 사전조건을 정의할 수 없다. (EX 부모0원 서브+100원)
-   서브타입에 더 완화된 사후 조건을 정의할 수 없다.(EX. 부모0원 서브-100원)
-   슈퍼타입의 불변식은 서브타입에서도 반드시 유지돼야 한다.

### 가변성 규칙

#### 서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안된다

#### 서브타입의 리턴 타입은 공변성을 가져야 한다.

-   공변성 : s와 t사이의 서브타입 관계가 그대로 유지된다. 서브타입 s가 슈터타입인 t대신 사용될 수 있다.
-   반 공변성 : s와 t사이의 서브타입 관계가 역전된다. 이경우 해당위치에서 슈퍼타입 t가 서브타입인 s대신 사용할 수 있다.
-   무공변성 : 서로 아무런 관계가 존재하지 않는다. 서로 대신할 수 없음

부모 클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할때 부모 클래스에서 선언한 반환타입의 서브타입으로 지정할 수 있는 특성을 리턴 타입 공변성이라고 부른다.

슈퍼타입 대신 서브타입을 반환하는 것은 더 강력한 사후조건을 정의하는 것과 같다(해도됨)

#### 서브타입의 메서드 파라미터는 반공변성을 가져야 한다.

즉 파라미터는 추상화 타입 적고 반환타입은 구체화 타입 적으란 말

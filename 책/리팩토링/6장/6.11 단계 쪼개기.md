# 단계 쪼개기

```JavaScript
const orderData = orderString.split(/\s+/);
const productPrice = priceList[orderData[0].split("-")[1]];
const orderPrice = parseInt(orderData[1]) * productPrice;
```

<center>🔽</center>

```JavaScript
const orderRecord = parseOrder(order);
const orderPrice = price(orderRecord, priceList);

function parseOrder(aString){
  const values = aString.split(/\s+/);
  return({
    productID: values[0].split("-")[1],
    quantity: parseInt(values[1]),
  });

  function price(order, priceList){
    return order,quantity * priceList[order.productID];
  }
}
```

## 배경

`서로 다른 두 대상을 한꺼번에 다루는 코드를 발견하게 되면 각각을 별개 모듈로 나누는 방법을 모색한다`

코드를 수정해야 할 떄 두 대상을 동시에 생각할 필요 없이 하나에만 집중하기 위해서다.

모듈이 잘 분리되어 있다면 다른 모듈의 상세 내용은 전혀 기억하지 못해도 원하는대로 수정을 끝마칠 수도 있다.

분리하는 가장 간편한 방법은 동작을 연이은 두 단계로 쪼개는 것이다. 입력이 처리 로직에 적합하지 않은 형태로 들어오는 경우를 예로 이럴때는 본 작업에 들어가기 전에 입력값을 다루기 편한 현태로 가공한다.

아니면 로직을 순차적인 단계들로 분리해도 된다. (이때 각 단계는 서로 확연히 다른 일을 수행해야 한다.)

예로. 컴파일러는 텍스트를 토큰화 하고, 토큰을 파싱해서 구문트리를 만들고, 구문트리를 변환하는 다양환 단계를 거친 다음, 목적 코드를 생성하는 방식 각 단계는 자신만의 문제에 집중하기 때문에 나머지 단계에 관해서는 자세히 몰라도 이해할 수 있다.

## 절차

-   두번째 단계에 해당하는 코드를 독립 함수로 추출한다.
-   테스트 한다.
-   중간 데이터 구조를 만들어서 앞에서 추출한 함수의 인수로 추가한다.
-   테스트 한다.
-   추출한 두 번째 단계 함수의 매개변수를 하나씩 검토한다. 그중 첫 번째 단계에서 사용되는 것은 중간 데이터 구조로 옮긴다. 하나씩 옮길 때마다 테스트 한다.
-   첫 번째 단계 코드를 함수로 추출하면서 데이터 구조를 반환하도록 만든다.

## 예시

상품의 결제 금액을 계산하는 코드

```JavaScript
function priceOrder(product, quantity, shippingMethod){
  const basePrice = product.basePrice * quantity;
  const discount = Math.max(quantity - product.discountThreshold, 0)
          * product.basePrice * product.discountRate;
  const shippingPerCase = (basePrice > shippingMethod.discountThreshold)
                ? shippingMethod.discountedFee : shippingMethod.feePerCase;
  const shoppingCost = quantity * shippingPerCase;
  const price = basePrice - discount + shippingCost;
  return price;
}
```

간단한 예지만, 가만 보면 계산이 두 단게로 이뤄짐을 알 수 있다.

-   앞의 몇 줄은 상품 정보를 이용해서 결게 금액 중 상품 가격을 계산한다.
-   뒤의 코드는 배송정보를 이용하여 결제 금액 중 배송비를 계산한다.
-   나중에 상품 가격과 배송비 계산을 더 복잡하게 만드는 변경이 생긴다면 이 코드는 두 단계로 나누느 것이 좋다.

1. 먼저 배송비 계산 부분을 함수로 추출한다.

```JavaScript
function priceOrder(product, quantity, shippingMethod){
  const basePrice = product.basePrice * quantity;
  const discount = Math.max(quantity - product.discountThreshold, 0)
              * product.basePrice * product.discountRate;

  const price = applyShipping(basePrice, shippingMethod, quantity, discount);
  return price;
}
// 2번째 단계를 처리하는 함수
function applyShipping(basePrice, shippingMethod, quantity, discount){
  const shippingPerCase = (basePrice > shippingMethod.discountThreshold)
                  ? shippingMethod.discountedFee : shippingMethod.feePerCase;
  const shippingCost = quantity * shippingPerCase;
  const price = basePrice - discount + shippingCost;
  return price;
}
```

2. 다음으로는 첫 번째 단계와 두 번째 단계가 주고받을 중간 데이터 구조를 만든다.

```JavaScript
function priceOrder(product, quantity, shippingMethod){
  const basePrice = product.basePrice * quantity;
  const discount = Math.max(quantity - product.discountThreshold, 0)
          * product.basePrice * product.discountRate;
  const priceData = {}; //중간 데이터 구조
  const price = applyShipping(priceData, basePrice, shippingMethod, quantity, discount);
  return price;
}

function applyShipping(priceData, basePrice, shippingMethod, quantity, discount){
  const shippingPerCase = (basePrice > shippingMethod.discountThreshold)
                    ? shippingMethod.discountedFee : shippingMethod.feePerCase;
  const shippingCost = quantity * shippingPerCase;
  const price = basePrice - discount + shippingCost;
  return price;
}
```

3. 이제 applyShipping()에 전달되는 다양한 매개변수를 살표보자. 이중 basePrice는 첫 번째 단계를 수행하는 코드에서 생성된다. 따라서 중간 데이터 구조로 옮기고 매개변수 목록에서 제거한다.

```JavaScript
function priceOrder(product, quantity, shippingMethod){
  const basePrice = product.basePrice * quantity;
  const discount = Math.max(quantity - product.discountThreshold, 0)
              * product.basePrice  * product.discountRate;
  const priceData = {basePrice: basePrice};
  const price = applyShipping(priceData, shippingMethod, quantity, discount)
  return price
}

function applyShipping(priceData, shippingMethod, quantity, discount){
    const shippingPerCase = (pricePrice.basePrice > shippingMethod.discountThreshold)
                    ? shippingMethod.discountedFee : shippingMethod.feePerCase;
  const shippingCost = quantity * shippingPerCase;
  const price = priceData.basePrice - discount + shippingCost;
  return price;
}
```

-   이후 여러가지 매개변수들을 중간 변수로 옮긴다.

```JavaScript
function priceOrder(product, quantity, shippingMethod){
  const basePrice = product.basePrice * quantity;
  const discount = Math.max(quantity - product.discountThreshold, 0)
              * product.basePrice  * product.discountRate;
  const priceData = {basePrice: basePrice, quantity: quantity, discount: discount};
  const price = applyShipping(priceData, shippingMethod)
  return price
}

function applyShipping(priceData, shippingMethod){
    const shippingPerCase = (pricePrice.basePrice > shippingMethod.discountThreshold)
                    ? shippingMethod.discountedFee : shippingMethod.feePerCase;
  const shippingCost = priceData.quantity * shippingPerCase;
  const price = priceData.basePrice - priceData.discount + shippingCost;
  return price;
}
```

-   이제 첫 번째 단계 코드를 함수로 추출하고 데이터 구조를 반환하게 한다.

```JavaScript
function priceOrder(product, quantity, shippingMethod){
  const priceData = calculatePricingData(prod)
}
```

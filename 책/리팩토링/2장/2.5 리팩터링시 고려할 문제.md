# 리팩터링 시 고려할 문제

특정한 기술, 도구, 아키텍처 등을 내세울 때마다 항상 문제점을 찾는다. 무언가를 언제 어디에 적용할지 판단하려면 손익을 제대로 이해해야 한다.

### 새 기능 개발 속도 저하

`리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.`

준비를 위한 리팩터링을 하면 변경을 훨씬 쉽게 할 수 있다고 확신한다. 그래서 새 기능을 구현해 넣기 편해지겠다 싶은 리팩터링이라면 주저하지 안고 리팩터링부터 한다.

반면 직접 건드릴 일이 거의 없거나, 불편한 정도가 그리 심하지 않다고 판단되면 리팩터링하지 않는편이다. (또는 개선점이 떠오르지 않거나.)

`사람들이 빠지기 가장 쉬운 오류는 리팩터링을 클린 코드나, 바람직한 엔지니어링 습관 처럼 도덕적인 이유로 정당화 하는 것`

리팩터링의 본질은 코드베이스를 예쁘게 꾸미는게 아니라 오로지 경제적인 이유로 하는 것(개발기간단축)

### 코드 소유권

바꾸려는 함수가 API로 제공된 것이라면?

코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다. 클라이언트에 영향을 주지 않고서는 원하는 형태로 변경할 수 없기 때문이다(ex. 함수명 바꾸기)

코드 소유권을 팀에 두고 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 한다.(다른사람이 작성헀더라도) 불안하면 오픈소스방식으로

### 브랜치

머지가 복잡해지는 문제는 기능별 브랜치들이 독립적으로 개발되는 기간이 길어질 수록 기하급수적으로 늘어난다.

브랜치의 통합 주기는 짧게 관리해야 한다. CI 또는 트렁크 기반 개발(TBD)에 따르면 하루에 최소 한번은 마스터와 통합한다.

CI를 적용하기 위해서는 마스터를 건강하게 유지하고, 거대한 기능을 잘게 쪼개는 법을 배우고, 각 기능을 끌 수 있는 기능 토글을 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야한다.

켄트백이 CI와 리팩터링을 합쳐서 익스트림프로그래밍(XP)을 만든 이유도 두 기법의 궁합이 잘 맞기 때문이다.

기능별 브랜치를 사용하면 절대 안된다는 말이 아니다. 자주 통합할 수만 있다면 문제가 발생할 가능성을 크게 줄일 수 있다. CI를 완벽하게 적용하지 못하더라도 통합 주기만큼은 최대한 짧게 잡아야 한다.

### 테스팅

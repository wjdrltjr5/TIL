# 리팩터링 시 고려할 문제

특정한 기술, 도구, 아키텍처 등을 내세울 때마다 항상 문제점을 찾는다. 무언가를 언제 어디에 적용할지 판단하려면 손익을 제대로 이해해야 한다.

### 새 기능 개발 속도 저하

`리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.`

준비를 위한 리팩터링을 하면 변경을 훨씬 쉽게 할 수 있다고 확신한다. 그래서 새 기능을 구현해 넣기 편해지겠다 싶은 리팩터링이라면 주저하지 안고 리팩터링부터 한다.

반면 직접 건드릴 일이 거의 없거나, 불편한 정도가 그리 심하지 않다고 판단되면 리팩터링하지 않는편이다. (또는 개선점이 떠오르지 않거나.)

`사람들이 빠지기 가장 쉬운 오류는 리팩터링을 클린 코드나, 바람직한 엔지니어링 습관 처럼 도덕적인 이유로 정당화 하는 것`

리팩터링의 본질은 코드베이스를 예쁘게 꾸미는게 아니라 오로지 경제적인 이유로 하는 것(개발기간단축)

### 코드 소유권

바꾸려는 함수가 API로 제공된 것이라면?

코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다. 클라이언트에 영향을 주지 않고서는 원하는 형태로 변경할 수 없기 때문이다(ex. 함수명 바꾸기)

코드 소유권을 팀에 두고 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 한다.(다른사람이 작성헀더라도) 불안하면 오픈소스방식으로

### 브랜치

머지가 복잡해지는 문제는 기능별 브랜치들이 독립적으로 개발되는 기간이 길어질 수록 기하급수적으로 늘어난다.

브랜치의 통합 주기는 짧게 관리해야 한다. CI 또는 트렁크 기반 개발(TBD)에 따르면 하루에 최소 한번은 마스터와 통합한다.

CI를 적용하기 위해서는 마스터를 건강하게 유지하고, 거대한 기능을 잘게 쪼개는 법을 배우고, 각 기능을 끌 수 있는 기능 토글을 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야한다.

켄트백이 CI와 리팩터링을 합쳐서 익스트림프로그래밍(XP)을 만든 이유도 두 기법의 궁합이 잘 맞기 때문이다.

기능별 브랜치를 사용하면 절대 안된다는 말이 아니다. 자주 통합할 수만 있다면 문제가 발생할 가능성을 크게 줄일 수 있다. CI를 완벽하게 적용하지 못하더라도 통합 주기만큼은 최대한 짧게 잡아야 한다.

### 테스팅

자가 테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다.

리팩터링 과정에서 버그가 생길 위험이 아주 크다는 불안감을 해소할 수 있다. 자가 테스트 코드 없이 리팩터링할 때는 당연히 이 점을 염려해야 한다.

자동 리팩터링 기능을 제공하는 환경이라면 굳이 테스트하지 않아도 오류가 생기지 않는다고 확신할 수 있다.(IDE) 물론 이러면 활용할 수 있는 리팩터링 기법 수가 제한된다.

자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서 자연스럽게 CI와도 밀접하게 연관된다. CI에 통합된 테스트는 XP의 관장사항이자 CD의 핵심이기도 하다

### 레거시 코드

레거시 시스템을 파악할 때 리팩터링이 도움된다. 하지만 대규모 레거시 시스템을 텟그트 코드 없이 명료하게 리팩터링 하기는 어렵다.

테스트 보강을 하면 되지만 쉬운 일은 아니다. `레거시 코드 활용 전략`에 나온 지침을 충실히 따르자. (프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다)

### 데이터베이스

데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다. (문제가 생겼을 때 변경을 되돌리기 쉽게 하기 위해)

예로 필드 이름을 바꿀 때

-   첫번째 커밋에서는 새로운 데이터베이스 필드를 추가만하고 사용하지는 않는다.
-   기존 필드와 새 필드를 동시에 업데이트하도록 설정한다.
-   데이터에비스를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체한다.
-   발생하는 버그도 해결하면서 클라이언트 교체 작업을 모두 끝낸다.
-   예전 필드를 삭제한다.

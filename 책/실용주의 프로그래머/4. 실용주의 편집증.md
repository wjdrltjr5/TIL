# 실용주의 편집증

**완벽한 소프트웨어는 만들 수 없다.**

프로그래머는 완벽한 코드를 작성할 수 없음을 알기에 자신의 실수에 대비해 방어적으로 코드를 짠다.

## 계약에 의한 설계

소프트웨어 시스템의 모든 함수와 메서드는 뭔가를 한다. 그 무언가를 시작하기 전에 해당 루틴은 세상의 상태에 대해 어떤 기대를 갖고 있을 테고, 루틴이 끝난 후에 세상의 상태가 어떠해야 한다는 진술을 할 수 있을 것이다.

-   선행조건 : 루틴이 호출되기 위해 참이어야 하는것 즉 루틴의 요구사항 더 (부모보다 완화된 조건은 되지만 더 강력한 조건은 안됨.)

-   후행조건 : 루틴이 자기가 할 것이라고 보장하는것. (반환값이 더 강력한 값은 되지만 완화된 값은 설정x) 무한 반복은 허용되지 않는다.

-   클래스 불변식 : 호출자의 입장에서 볼 떄는 이 조건이 언제나 참이라고 클래스가 보장한다. 루틴의 내부 처리 중에는 불변식이 아닐 수도 있지만 종료될때는 불변식이어야 한다.

호출자가 루틴의 모든 선행 조건을 충족해야 한다면 해당 루틴은 종료시 모든 후행조건과 불변식이 참이 될 것을 보장해야 한다.

선행조건을 이용해서 사용자 입력값을 검증한다거나 해서는 안된다.

**계약에 따른 설계를 하라.**

LSP 서브클래스는 사용자가 차이점을 모르고서도 기반 클래스 인터페이스를 통해 사용할 수 있어야 한다.

오류 발생시 소비자의 입장을 우선하라.

## 죽은 프로그램은 거짓말을 하지 않는다.

모든 에러는 정보를 준다.
**일찍 작동을 멈추게 하라**

가능한 한 빨리 문제를 발견하게 되면. 좀 더 일찍 시스템을 멈출 수 있다는 이득이 있다.

## 단정적 프로그래밍

**단정문을 사용해서 불가능한 상황을 예방하라.**

프로시저로 전달된 포인터가 NULL이어서는 절대 안된다면 그걸 감시하라.

```c
void writeString(char *string){
  assert(string != null);
}
```

단정문에 전달된 조건은 부작요이 있으면 안된다.

진짜 에러처리 대신으로 단정을 사용하지는 마라. 단정은 결코 일어나면 안되는 것들을 컴사한다.

```c
//안좋은 예
print("Enter 'y' or 'n' : ");
ch = getChar();
assert((ch=='y') || (ch == 'n')) // 안좋은 예
```

## 언제 예외를 사용할까

모든 가능한 에러를 체크하는 것이 좋지만 이러면 코드가 꽤 지저분해질 수 있다.

프로그램의 정상적 로직이 에러처리에 완전히 묻혀 잘 보이지 않게 될 수도 있다. 다행이도 해당 언어가 예외를 지원한다면 코드를 깔끌하게 작성할 수 있다.

### 무엇이 예외인가?

**예외는 예외적인 문제에 사용하라**

## 리소스 사용의 균형

코딩할때 우리는 모두 리소스를 관리한다.

**시작한 것은 끝내라**

-   리소스를 할당한 순서의 반대로 해제하라. 이렇게 해야 한 리소스가 다른 리소스를 참조하는 경우에도 리소스를 고아로 만들지 않는다.

-   코드의 여러 곳에서 동일한 리소스 집합을 할당하는 경우, 할당 순서를 언제나 같게 하라. 교착 가능성이 줄어들 것이다.

### 균형을 점검하기

리소스가 적절하게 해제되었는지 실제로 점검하는 코드를 늘 작성하는 것이 언제나 좋다.

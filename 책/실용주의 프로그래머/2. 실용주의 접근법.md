# 실용주의 접근법

개발중에 기본죽인 우너리들을 유념한다면 더 좋고, 더 빠르고, 더 강력한 코드를 작성할 수 있다.

## 중복의 해악

대부분의 사람들은 유지보수가 버그를 고치고 기능을 개선하는 것을 의미하기 때문에, 애플리케이션이 출시되었을 때 비로소 유지보수가 시작된다고 믿는다. 하지만 이들은 틀렸다.

프로그래머들은 늘 유지보수 모드에 있다. 우리가 이해하고 있는 것은 날마다 바뀐다. 설계를 하거나 코딩을 하는 중에 새로운 요구사항이 도착한다. 어쩌면 환경이 변할 수도 있다.

소프트웨어를 신뢰성 높게 개발하고, 개발을 이해하고 유지보수하기 쉽게 만드는 유일한 길은 DRY원칙이라고 부르는 것을 따르는 것뿐이다.

모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을만한 표현 양식을 가져야 한다.

**DRY - 반복하지 마라**

### 어떻게 중복이 생기는가?

-   강요된 중복 : 개발자들은 다른 선택이 없다고 느낀다. 환경이 중복을 요구하는 것처럼 보인다.

-   부주의한 중복 : 개발자들은 사진들이 정보를 중보하고 있다는 것을 깨닫지 못한다.

-   참을성 없는 중복 : 중복이 쉬워 보이기 때문에 개발자들이 게을러져서 중복을 하게 된다.

-   개발자간의 중복 : 한 팀에 있는(혹은 다른 팀에 있는) 여러 사람들이 동일한 정보를 중복한다.

### 강요된 중복

-   정보의 다양한 표현 양식

    -   코딩 수준에서 우리는 종종 동일한 정보가 다른 형태로 표현되어야 할 필요를 느낄 때가 있다.

    -   클라이언트-서버 애플리케이션을 작성하는데 클라이언트와 서버에서 서로 다른 언어를 사용하지만 공통된 구조를 양쪽 모두에서 표현해야 할 때가 있다.

    -   약간의 창의력만 있으면 중복의 필요를 제거할 수 있다(필터, 코드생성기 작성)

-   코드내의 문서화

    -   나쁜 코드야 말로 많은 주석을 필요로 한다.

    -   DRY 원칙은 낮은 차원의 지식은 그것이 속하는 코드에 놔두고, 주석은 다른 높은 차원의 설명을 위해 아껴두라고 말한다.

    -   믿을 수 없는 주석은 주석이 전혀 없는 것보다 더 심각한 문제를 만들어 낸다.

-   문서화한 코드

    -   문서를 작성하고 나서 코드를 작성한다.

    -   변경이 있다면 문서를 수정하고 코드를 갱신한다.

    -   급해지면 문서의 갱신을 뒤로 미루기 쉽다.

    -   어떤 클라이언트는 충실한 테스트 명세와 동시에 소프트웨어가 모든 테스트를 통과할 것을 요구

    -   개발팀은 문서 자체에서 테스트가 자동 생성되도록 함

    -   클라리언트가 명세를 수정하면 테스트 슈트는 자동으로 바뀜

-   언어에 관한 문제

    -   많은 언어가 소스코드에 상당한 양의 중복을 강요한다.

    -   이것은 언어가 모듈의 인터페이스와 그 구현을 분리하는 경우에 자주 생긴다.

    -   헤더 파일에는 인터페이스에 대한 사항을 기록하고 구현파일에는 그 코드의 사용자가 알 필요가 없는 상세한 것들을 기록하라

-   부주의한 중복

    -   때때로 중복은 설계 실수의 결과로 나타나기도 한다.

    -   트럭은 타입, 등록번호, 운전사를 속성으로 가지고 있다

    -   배달경로는 경로,트럭,운전사를 속성으로 가지고있다.

    -   만약 운전사를 바꿔야 한다면 둘다 바꿔야 한다.

    -   비 정규화된 데이터를 피하자.

    -   가능하면 객체의 속성을 읽고 쓸 수 있는 엑세스 함수를 사용하자.

-   참을성 없는 중복

    -   모든 프로젝트는 시간의 압박을 받는다.

    -   원래의 것을 복사하고 약간만 바꾸도록 유혹을 받는다.

    -   돌아가는길이 지름길이다 라는 진부한 격언을 기억하라.

    -   참을성 없는 중복은 발견하기도 쉽고 다루기도 쉬운 형태지만, 나중의 고통을 피하기 위해서는 훈련이 필요하고, 미연에 시간을 투자할 의지가 있어야 한다.

-   개발자간의 중복

    -   발견하거나 다루기 가장 어려운 유형의 중복은 한 프로젝트에서 일하는 서로 다른 개발자 사이에서 발생한다.

    -   전체 기능 집합이 부주의하게 중복될 수 있고, 그런 중복은 수년동안 발견되지 않을 수 있으며, 유지보수 문제로 귀결된다.

    -   높은 차원의 해법은 깨끗한 설계와 강력하고 기술적인 프로젝트 리더, 설계 내에서 책임 분배가 제대로 이해되도록 하는 것.

    -   개발자간의 적극적이고 빈번한 소통을 장려하자.

    -   서로 코드 리뷰를 하라. 접근은 상호적이다 다른 사람이 여러분의 코드를 들여다 본다고 해서 기분 나빠하지 마라

**재사용하기 쉽게 만들어라**

## 직교성

설계, 빌드, 테스트 그리고 확장하기에 쉬운 시스템을 만드는 데에 있어 직교성은 매우 중요한 개념이다.

직교성이란 : 기하학에서 빌려온 용어, 컴퓨팅에서 이용어는 일종의 독립성이나 결합도 줄이기를 의미한다.

잘 설계된 시스템에서는 데이터베이스 코드가 사용자 인터페이스에 대해 직교(독립적)할 것이다.

### 직교성의 장점

비직교적인 시스템은 본질적으로 변화와 조정을 하기가 복잡하다. 시스템의 컴포넌트들이 고도로 상호의존적인 경우, 특정 국지적 부분만 수정하는 방법이란 없다.
**관련 없는 것들 간에 서로 영향이 없도록 하라**

직교성적인 시스템을 작성하면 두 가지의 큰 장점이 있다.

### 생산성 향상

-   변화가 국소화 되서 개발 시간과 테스트 시간이 줄어든다.
-   상대적으로 작고 자족적인 컴포넌트를 작성하는 것이 하나의 커다란 코드 덩어리를 만드는 것보다 쉽다.
-   직교적인 접근법을 재사용을 촉진한다.
-   느슨하게 결합되어 있을수록 재설정하고 리엔지니어링하기 쉽다.

### 리스크 감소

-   감염된 코드는 격리된다. 그 부분만 도려내고 새롭고 건강한 놈으로 이식
-   시스템이 잘 깨어지지 않는다.
-   더 많은 테스트를 하게 된다.
-   특정 벤더나 제품, 플랫폼에 덜 종속된다.

### 프로젝트 팀

팀 내 업무가 겹치는 영역이 많다면 구성원들은 책임 영역에 대해 혼동하게 된다.

팀 프로젝트가 얼마나 직교성을 갖는지 간단히 측정하는 방법은 요청된 개별 변화에 대한 토론에 참여할 필요가 있는 사람이 몇 몇인지를 보라.

### 설계

특정 기능에 대한 요구사항을 극적으로 변경했을 경우 몇 개의 모듈이 영향을 받는가? 직교적인 시스템에서는 하나여야 한다.(이상적) ex. GUI 패널의 단추 하나를 옮기는데 DB스키마가 변경되어서는 안된다.

MVC는 이와 같은 상황을 효과적으로 해결해 준다.

### 툴킷과 라이브러리

써드파티 툴킷이나 라이브러리를 도입할 때, 시스템의 직교성을 보존할 수 있는지 주의 깊게 살펴봐라.

객체 영속 방식이 투명하다면 이것은 직교적이다. 하지만 특별한 방식으로 객체를 생성하고 접근해야 한다면 그렇지 않다.

이러한 세부사항을 코드로부터 분리한다면 미래에 벤더가 바뀌더라도 쉽게 대처할 수 있다는 이점이 있다.

### 코딩

-   코드의 결합도를 줄여라
-   전역 데이터를 피하라. (많은 개발자들이 싱글턴 객체를 전역 데이터의 일종으로 남용한다. 싱글톤을 사용할 때는 주의를 기울여라 불필요한 링크를 유도한다.)
-   유사한 함수를 피하라

### 테스트

직교성으로 설계, 구현한 시스템은 테스트하기 더 쉽다.

단위 테스트를 만든다는 것 자체가 직교성을 테스트해 볼 수 있는 흥미로운 작업이다.

시스템의 나머지 부분을 끌어들여 테스트케이스를 만들고 컴파일 혹은 링크해야 한다면 모듈과 시스템의 나머지 부분간의 결합도를 적절히 줄이지 못했다는 증거.

### 문서화

## 가역성

어떤 벤더의 데이터베이스나 아키텍처 패턴, 혹은 특정 배포 모델을 사용하기로 결정했고 이를 통해 프로젝트를 진행해 왔다면 큰 비용을 치루지 않고는 이러한 결정을 되돌릴 수 없다.(결정을 최대한 뒤로 미뤄라.)

프로젝트 초기에 RDB를 사용하기로 결정했다가 다른 RDB로 교체해야 한다면?? 데이터베이스에 대한 아이디어를 올바르게 추상화 하였다면 괜찮았을 것이다.

**최종결정이란 없다**

### 유연한 아키텍처

많은 사람들이 코드를 유연하게 유지하려고 노력한다. 하지만 아키텍처, 배포, 벤터 통합 영역의 유연성에 대해서도 관심을 기울일 필요가 있다.

보통 특정 벤더 제품에 대한 의존도 등은 잘 정의하고 추상화환 인터페이스를 통해 감출 수 있다.

## 예광탄

### 어둠 속에서 빛을 내는 코드

코딩에서도 동일한 효과를 얻으려면, 우리를 요구사항으로부터 최종 시스템의 일부 측면에까지 빨리, 눈에 보이게, 반복적으로 도달하게 해줄 무언가를 찾아야 한다.

**목표물을 찾기 위해 예광탄을 써라.**

예광탄 코드는 나중에 버리려고 만드는 것이 아니다. 단지 아직 완전한 기능이 들어 있지 않을뿐이다.

하지만 시스템을 구성하는 요소를 모두 연결해 놓은 후라면 목표물에 얼마나 가까이 다가섰는지 확인할 수 있으며, 필요하다면 조정도 할 수 있다. 그렇게 해서 일단 목표물을 맞춘다면 기능을 추가하는 일은 쉽다.

코든느 모듈들로 분류되고 각 모듈은 진공 상태에서 작성된다.

에광탄 코드 접근 방법의 장점

-   사용자들은 뭔가 작동되는 것을 일찍부터 보게 된다.
-   개발자들은 들어가서 일할 수 있는 구조를 얻는다.
-   통합 작업을 수행할 기반이 생긴다.
-   보여줄 것이 생긴다.
-   진전 상황에 대해 더 정확하게 감을 잡을 수 있다.

### 예광탄이 언제나 목표물을 맞추는 것은 아니다.

예광탄 코드 기법은 일이 어떻게 될지 확신할 수 없는 상황에서 사용된다. 그냥 가벼운 개발 방법론을 선택했다는 사실에 감사해라. 단지 목표물에 가까워지기 위해 사용

### 예광탄 대 프로토 타이핑

프로토타이핑은 최종 시스템의 어떤 특정한 측면을 탐사해 보는 것이 목표다. 어떤 개념을 구현해 보려고 시도할 때 대퉁 끼워 맞춘 것들을 모두 버린 다음, 실험 과정에서 얻은 교휸을 바탕으로 다시 코드를 만들게 된다.

예광탄 코드 접근 방법은 다른 종류의 문제에 대한 대응 방법이다. 애플리케이션이 전체적으로 어떻게 연결되는지를 알고 싶다. 사용자들에게 실제로 애플리케이션의 요소들이 어떻게 상호작용하는지 보이고 싶고, 개발자들에게는 코드를 붙일 아키텍처 골격을 제시하고 싶다.

이경우 대강 구현한 컨테이너 채우는 알고리즘과 단수하지만 동작은 하는 인터페이스로 구성된 예광탄을 만들것이다.

이렇게 만든 예광탄의 모든 요소들을 이어붙이면 보여줄 프레임워크가 생긴다.

-   프로토타입은 나중에 버릴 수 있는 코드를 만든다.
-   예광탄 코드는 기능은 별로 없지만 완결된 코드이며, 최종 시스템 골격의 일부를 이룬다.

## 프로토타입과 포스트잇

포스트잇은 작업흐름과 애플리케이션 로직과 같은 동적인 것들을 프로토타이핑해 볼 수 있는 휼룡한 도구다. 사용자 인터페이스는 화이트 보드에 그려보거나, 페인트 프로그램, 인터페이스 빌더 등을 이용해 기능은 구현하지 않고 인터페이스만을 그려보는 방법으로 프로토타입을 만들 수 있다.

프로토타입은 제한된 몇 가지 질문에 답할 목적으로 설계되기 때문에 실제 제품보다 훨씬 적은 비용으로 빠르게 개발할 수 있다.

프로토타입의 대상

-   아키텍처
-   기존 시스템에 추가할 새로운 기능
-   서드파티 도구나 컴포넌트
-   성능 문제
-   사용자 인터페이스 설계

프로토 타이핑은 학습 경험이며, 가치는 생성된 코드에 있는 것이 아니라 이를 통해 배우게 되는 교훈에 있다.
**프로토파입일 통해 학습하라.**

### 프로토타입을 어떻게 사용할 것인가?

-   정확성 : 적절히 가짜 테이터를 사용할 수 있다.

-   완전성 : 프로토타입은 어쩌면 미리 선정한 입력 데이터와 한가지 메뉴 항목에서만 작동하면 되기 때문에 제한된 기능만을 제공하기도 한다.

-   안정성 : 에러 검사는 불완전할 수도 있고, 때론 완전히 무시될 수도 있다. 미리 정의된 방법대로 실행시키지 않는다면 와장창
    망가지고 불꽃놀이를 보여주면서 타버릴 수도 있지만 괜찮다.

-   스타일 : 프로토타입 코드는 주석이나 문자를 많이 만들지 않아도 된다. 결과로 문서를 많이 만들 수 있지만 프로토타입 자체에는 문서가 많이 필요 없다.

### 아키텍처 프로토타이핑

아키텍처를 프로토타이핑할 때 코드를 작성하지 않고 화이트보드, 포스트잇, 인텍스 카드 등을 사용해도 된다.

아키텍처 프로토타입에서 규명할 만한 사항들

-   주요 컴포넌트의 책임이 잘 정의되었고 적절한가?
-   주요 컴포넌트 간의 협력관계가 잘 정의되었는가?
-   결합도는 최소화되었는가?
-   잠재적 중복을 찾아낼 수 있는가?
-   인터페이스 정의와 제약 사항은 수용할만한가?
-   각 모듈이 실행 중에 필요로 하는 데이터에 접근할 수 있는 경로를 갖고 있는가?
-   모듈은 데이터를 필요로 할 때 데이터에 접근할 수 있는가?

### 어떻게 프로토타입을 사용하지 않을 것인가?

프로토타입을 코드로 만들 때는 시작하기 전에 항상 모든 사람에게 여러분이 폐기처분할 코드를 작성하고 있다는 사실을 이해시켜야 한다.

## 도메인 언어

**문제 도메인에 가깝게 프로그래밍하라.**

프로젝트를 문제 도메인에 가까운 곳으로 옮길 방법들을 궁리해봐야 한다. 더 높은 추상화 수준에서 작업함으로써 사소한 구현의 세부사항들을 무시하고 도메인의 문제들을 푸는 일에만 정신을 집중할 수 있다.

## 추정

**추정을 통해 놀람을 피하라.**

### 얼마나 정확한 것이 충분히 정확한 것인가?

추정에서 사용하는 단위가 결과의 해석에 차이를 가져온다.

1~15일 일/ 3~8주 주/ 8~30주 달/30주 이상 추정치를 말하기 전데 다시 한번 생각하자.

### 추정치는 어디에서 오는가

모든 추정치는 문제의 모델에 기반한다. 항상 좋은 답을 알려주는 기본적인 추정 기술은 그 일을 해본사람에게 물어보는 것.

### 무엇을 묻고 있는지를 이해하자.

상대방이 무엇을 묻고있는지에 대해 이해해야 함.

### 시스템의 모델을 만들어보라.

클라이언트가 요청한 것이 무엇인지 이해한후에는 대략적이고, 꾸밈없는 모델을 만들어 보라.

만약 응답시간을 추정하고 있다면 여러분의 모델은 서버와 서버에 도달하는 몇 종류의 트래픽을 포함하게 될것.

### 모델을 컴포넌트로 나누어라

### 각 매개변수에 값을 주어라

### 답을 계산하라.

### 추정치과 결과를 비교

### 프로젝트 일정 추정하기

-   요구사항 체크
-   위험 분석
-   설계, 구현, 통합
-   사용자와 함께 검증

**코드와 함께 일정도 반복하며 조정하라**

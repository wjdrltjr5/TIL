# 코딩하는 동안 해야 할 일들

코딩할 때는 매분모다 결정을 내려야 하는데, 프로그램이 정확하고 생산적으로 작동하면서 천수를 누리기 위해서는 사려 깊은 생각과 판단을 통한 결정이 필요하다.

**실용주의 프로그래머는 모든 코드를 비판적인 눈으로 바라보는데, 자기 자신의 코드도 예외가 아니다.**

코드를 작성할 때는 언제가 그 코드를 테스트하게 될 것이라는 생각을 꼭 마음 한 구석에 두고 이썽야 한다.

**테스트하기 쉬운 코드를 만들어라**

## 우연에 맡기는 프로그래밍

우연에 맡기는 프로그래밍 곧 행운과 어쩌다 오는 성공에 의존하는 프로그래밍을 하지 말아야 한다. 대신 의도적으로 프로그래밍 해야 한다.

### 프로그래밍을 우연에 맡긴다면?

한정된 테스트를 했을 때는 코드가 잘 돌아가는 것 처럼 보이지만 단지 그때 운이좋았을 뿐이다.

-   정말로 제대로 돌아가는 것이 아닐지도 모른다. 우리에게만 그런 것처럼 보일 수도 있다.
-   여러분이 의존하는 조건이 단지 우연이 경우도 있다.
-   문서화되지 않는 동작은 라이브러리의 다음 릴리스에서 변경될 가능성이 있다.
-   불필요한 추가 호출은 코드를 더 느리게 만든다.
-   추가로 호출한 루틴 때문에 새로운 버그들이 코드에 들어올 가능성이 있다.

다른사람들이 호출할 코드를 작성할 때는 모듈화를 잘하거나 문서화가 잘된 작은 규모의 인터페이스 아래에 구현을 숨기는 것과 같은 기본 원칙들이 모두 도움이 된다.

### 우연적 맥락

확실한 것이 아닌데도 의존하고 있는 다른 것들은 있는가?

### 암묵적인 가정

확고한 사실에 근거 하지 않은 가정은 어떤 프로젝트에서든 재앙의 근원이 된다.

### 의도적으로 프로그래밍 하기

-   언제나 자기가 지금 무엇을 하고 있는지 알아야 한다.
-   맹목적으로 코딩하지 말라.
-   계획을 세우고 그것을 바탕으로 진행하라.
-   신뢰할 수 있는 것에만 기대라
-   여러분의 가정을 문서로 남겨라
-   코드만 테스트할 것이 아니라 여러분이 세운 가정도 테스트해 보아야 한다.
-   노력을 기울일 대상의 우선순위를 정하라.
-   과거의 노예가 되지 말라. 예전의 한일이 앞으로 할 일을 제약하지 못하도록 하라.

## 알고리즘의 속도

자원, 시간, 프로세서, 메모리, 속도 등등 추정

빅오 표기법은 우리가 측정하는 것의 상한값을 정하는 표기법이다.

### 상식적인 추정

-   간단한 반복문
-   겹친 반복문
-   반씩 잘라 나가기
-   나눠서 정복하기
-   조합적

### 실전에서의 알고리즘 속도

라이브러리에 존재하는 정렬 루틴이 아마 작성하는 것 보다는 성능이 좋을 것이다.

**여러분 알고리즘의 차수를 추정하라**
**여러분의 추정을 테스트하라**

### 최고라고 언제나 최고는 아니다.

적당한 알고리즘을 선택할 때도 실용적이어야 할 필요가 있다.

입력값의 규모가 작다면 단순한 삽입 정렬도 퀵정렬과 비슷한 성능을 내준다. 그러나 삽입 정렬 디버깅은 퀵정렬보다 적다.

**성급한 최적화를 조심하라.**

## 리팩터링

프로그램이 발전해가면, 초기에 내린 결정을 다시 고려하고 코드의 일부분을 다시 작성하는 일이 점점 더 필요해진다.

코드를 다시 작성하기, 다시 작업하기, 다시 설계하기는 총괄해서 리팩터링이라고 알려져 있다.

### 언제 해야 하는가?

-   중복 : DRY원치의 위반을 발견
-   직교성이 좋지 않은 설계 : 직교성 을 더 좋게 만들 수 있는 코드나 설계를 발견했다.
-   유효기간이 끝난 지식 : 사물은 변하고 요구사항은 변경되며, 지금 해결 중인 문제에 대한 여러분의 지식은 증가한다.
-   성능 : 성능을 개선하려면 시스템의 한 영역에서 다른 영역으로 기능을 옮겨야 한다.

리팩터링 하는 것은 고통관리를 실천하는 것이다.

### 현실 세계의 복잡한 문제들

클라이언트한테 잘 돌아가긴 하는데 리팩토링 해야 합니다?? 일정의 압박

리팩터링을 해야 하는 이유를 코드상의 종양이라고 생각하자.
**일찍 리팩터링하고 자주 리팩터링하라.**

### 리팩터링은 어떻게 하는가?

리팩터링은 천천히, 신중하게, 조심스럽게 진행해야 하는 작업이다.

손해보다 이득이 큰 방향으로 리팩터링을 하기 위한 조언들

-   리팩터링과 새로운 기능 추가를 동시에 하지 말라.
-   리팩터링을 시작하기 전 든든한 테스트 집합이 있는지 머넞 확인한다. 할 수 있는 한 자주 테스트들을 돌려본다.
-   단계를 작게 나누어서 신중하게 작업한다. 국지적인 변경들이 많이 모여서 커다란 규모의 변화를 낳는일

## 테스트하기 쉬운 코드

### 단위 테스트

소프트웨어 단위 테스트란 어떤 모듈에게 이것저것을 시켜보는 코드를 가리킨다. 일반적으로 일종의 인위적인 환경을 구축한 다음, 테스트할 모듈의 루틴들을 호출한다.

### 계약을 잘 지키는지 테스트해 보기

테스트는 우리에게 두가지 사실을 알려준다.

-   맡은바 계약을 잘 지키는가
-   코드로 표현된 계약의 의미가 우리가 생각하는 것과 일치하는가

**테스트를 염두에 두고 설계하라**
테스트르르 통과하고 계약을 지키는 코드를 설계하다 보면 자연스럽게 그렇게 설계하지 않았으면 생각나지 않았을 경계조건이나 다른 문제들을 고려하게 된다.

코드를 구현하기 전에 테스트를 먼저 만들어 보면(TDD) 크 코드의 인터페이스 고정되기 전에 미리 시험해 볼 수 있게 된다.

### 단위 테스트 작성하기

테스트는 귀중한 두가지 자원을 제공

-   어러분 모듈의 모든 기능을 어떻게 이용해야 하는지 보여주는 예제
-   후일 코드 변경시 검증하기 위한 회귀 테스트를 구축할 수 있는 수단.

### 테스트장치를 사용하기

ex. xUnit

테스트 장치는 반드시 다음과 같은 기능이 있어야 한다.

-   시작할 때 할일과 마칠 때 할 일을 지정할 수 있는 표준적인 방법
-   개별적인 테스트들을 선택하거나, 모든 테스트들을 한꺼번에 선택하게 해주는 메서드
-   예상한(또는 예상치 못한)결과에 비추어 결과를 분석할 수 있는 방법
-   실패를 보고하는 표준화된 형태

### 테스트 윈도우를 만들기

테스트 집합이 아무리 좋더라도 모든 버그를 발견할 가능성은 ㅇ벗다.

소프트웨어가 배치된 후에도 테스트해야만 하는 경우가 자주 생길 수 있다. 이때 소프트웨어의 혈관을 흐르는 것은 실데이터다.

로그 메시지는 반드시 규칙적이고 일관된 형식이어야 한다. 프로그램의 처리 시간이나 프로그램이 택한 논리 경로를 추론하기 위해 기록을 자동으로 파싱하고 싶을 때가 있기 떄문이다.

다른 애플리케이션에 내장이 가능하고 자유롭게 사용할 수 있는 HTTP웹 서버는 다양한 종류의 언어용으로 존재한다 이 웹서버를 찾는 일은 시작하기에 좋은 장소다.

### 테스트 문화

**소프트웨어를 테스트하라. 그렇지 않으면 사용자가 테스트하게 될 것이다**

## 사악한 마법사

**자신이 이해하지 못하는, 마법사가 만들어 준 코드는 사용하지 말라.**
